{"id": 182, "pattern_type": "import_statement", "file_path": "spring-ai-alibaba-studio/spring-ai-alibaba-studio-server/spring-ai-alibaba-studio-server-core/src/main/java/com/alibaba/cloud/ai/studio/core/utils/common/DateUtils.java", "file_extension": "java", "input": "/*\n * Copyright 2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alibaba.cloud.ai.studio.core.utils.common;\n\nimport org.apache.commons.lang3.time.DateFormatUtils;\n\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Locale;\n\n/**\n * Utility class for date and time operations.\n *\n * @since 1.0.0.3\n */\npublic class DateUtils extends org.apache.commons.lang3.time.DateUtils {\n\n\t// Date format patterns\n\tpublic static final String DATE_JFP_STR = \"yyyyMM\";\n\n\tpublic static final String DATE_YMD_STR = \"yyyyMMdd\";\n\n\tpublic static final String DATE_SMALL_STR = \"yyyy-MM-dd\";\n\n\tpublic static final String DATE_FULL_STR = \"yyyy-MM-dd HH:mm:ss\";\n\n\tpublic static final String DATE_KEY_STR = \"yyyyMMddHHmmss\";\n\n\tpublic static final String END_TIME_STR = \"9999-12-31 23:59:59\";\n\n\tpublic static final String DATE_SMALL_STR_SHOW = \"yyyy年MM月dd号HH点mm分\";\n\n\tpublic static final String DATE_MONTH_DAY_STR_SHOW = \"MM月dd号\";\n\n\t// Supported date parse patterns\n\tprivate static final String[] parsePatterns = { \"yyyy-MM-dd\", \"yyyy-MM-dd HH:mm:ss\", \"yyyy-MM-dd HH:mm\", \"yyyy-MM\",\n\t\t\t\"yyyy/MM/dd\", \"yyyy/MM/dd HH:mm:ss\", \"yyyy/MM/dd HH:mm\", \"yyyy/MM\", \"yyyy.MM.dd\", \"yyyy.MM.dd HH:mm:ss\",\n\t\t\t\"yyyy.MM.dd HH:mm\", \"yyyy.MM\", \"yyyyMMddHHmmss\", \"yyyyMMdd\" };\n\n\t/**\n\t * Format date to yyyyMMdd string\n\t */\n\tpublic static String formatSimple(Date date) {\n\t\tif (date == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn DateFormatUtils.format(date, DATE_YMD_STR);\n\t}\n\n\t/**\n\t * Get current date and time in full format (yyyy-MM-dd HH:mm:ss)\n\t */\n\tpublic static String getFullDate() {\n\t\treturn getDate(DATE_FULL_STR);\n\t}\n\n\t/**\n\t * Get current date in yyyy-MM-dd format\n\t */\n\tpublic static String getDate() {\n\t\treturn getDate(DATE_SMALL_STR);\n\t}\n\n\t/**\n\t * Get current date string in specified pattern\n\t * @param pattern Date format pattern\n\t */\n\tpublic static String getDate(String pattern) {\n\t\treturn DateFormatUtils.format(new Date(), pattern);\n\t}\n\n\t/**\n\t * Format date to string with specified pattern\n\t * @param date Date to format\n\t * @param pattern Format pattern\n\t */\n\tpublic static String formatDate(Date date, Object... pattern) {\n\t\tString formatDate = null;\n\t\tif (pattern != null && pattern.length > 0) {\n\t\t\tformatDate = DateFormatUtils.format(date, pattern[0].toString());\n\t\t}\n\t\telse {\n\t\t\tformatDate = DateFormatUtils.format(date, DATE_SMALL_STR);\n\t\t}\n\t\treturn formatDate;\n\t}\n\n\t/**\n\t * Format date to full datetime string (yyyy-MM-dd HH:mm:ss)\n\t */\n\tpublic static String formatDateTimeFull(Date date) {\n\t\tif (date == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn formatDate(date, DATE_FULL_STR);\n\t}\n\n\t/**\n\t * Format date to specified format\n\t */\n\tpublic static String formatDateTimeSmall(Date date, String format) {\n\t\treturn formatDate(date, format);\n\t}\n\n\t/**\n\t * Get current datetime in yyyyMMddHHmmss format\n\t */\n\tpublic static String getDateTime14() {\n\t\tlong currTime = System.currentTimeMillis();\n\t\tDate date = new Date(currTime);\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_KEY_STR);\n\t\treturn format.format(date);\n\t}\n\n\t/**\n\t * Format timestamp to yyyyMMddHHmmss string\n\t */\n\tpublic static String getDateTime14(long time) {\n\t\tDate date = new Date(time);\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_FULL_STR);\n\t\treturn format.format(date);\n\t}\n\n\t/**\n\t * Get current time in HH:mm:ss format\n\t */\n\tpublic static String getTime() {\n\t\treturn formatDate(new Date(), \"HH:mm:ss\");\n\t}\n\n\t/**\n\t * Get current datetime in yyyy-MM-dd HH:mm:ss format\n\t */\n\tpublic static String getDateTime() {\n\t\treturn formatDate(new Date(), DATE_FULL_STR);\n\t}\n\n\t/**\n\t * Get current year\n\t */\n\tpublic static String getYear() {\n\t\treturn formatDate(new Date(), \"yyyy\");\n\t}\n\n\t/**\n\t * Get current month\n\t */\n\tpublic static String getMonth() {\n\t\treturn formatDate(new Date(), \"MM\");\n\t}\n\n\t/**\n\t * Get current day\n\t */\n\tpublic static String getDay() {\n\t\treturn formatDate(new Date(), \"dd\");\n\t}\n\n\t/**\n\t * Get current weekday\n\t */\n\tpublic static String getWeek() {\n\t\treturn formatDate(new Date(), \"E\");\n\t}\n\n\t/**\n\t * Get current hour\n\t */\n\tpublic static Integer getHour() {\n\t\tCalendar calendar = Calendar.getInstance();\n\t\treturn calendar.get(Calendar.HOUR_OF_DAY);\n\t}\n\n\t/**\n\t * Parse date string to Date object Supports multiple date formats\n\t */\n\tpublic static Date parseDate(Object str) {\n\t\tif (str == null) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\treturn org.apache.commons.lang3.time.DateUtils.parseDate(str.toString(), parsePatterns);\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Parse date string in EEE MMM dd HH:mm:ss zzz yyyy format\n\t */\n\tpublic static Date parseDateString(String time) {\n\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\", Locale.ENGLISH);\n\t\tDate d = new Date();\n\t\ttry {\n\t\t\td = sdf.parse(time);\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn d;\n\t}\n\n\t/**\n\t * Calculate days between now and given date\n\t */\n\tpublic static long pastDays(Date date) {\n\t\tlong t = System.currentTimeMillis() - date.getTime();\n\t\treturn t / (24 * 60 * 60 * 1000);\n\t}\n\n\t/**\n\t * Calculate hours between now and given date\n\t */\n\tpublic static long pastHour(Date date) {\n\t\tlong t = System.currentTimeMillis() - date.getTime();\n\t\treturn t / (60 * 60 * 1000);\n\t}\n\n\t/**\n\t * Calculate minutes between now and given date\n\t */\n\tpublic static long pastMinutes(Date date) {\n\t\tlong t = System.currentTimeMillis() - date.getTime();\n\t\treturn t / (60 * 1000);\n\t}\n\n\t/**\n\t * Format milliseconds to time string (days,hours:minutes:seconds.milliseconds)\n\t */\n\tpublic static String formatDateTime(long timeMillis) {\n\t\tlong day = timeMillis / (24 * 60 * 60 * 1000);\n\t\tlong hour = (timeMillis / (60 * 60 * 1000) - day * 24);\n\t\tlong min = ((timeMillis / (60 * 1000)) - day * 24 * 60 - hour * 60);\n\t\tlong s = (timeMillis / 1000 - day * 24 * 60 * 60 - hour * 60 * 60 - min * 60);\n\t\tlong sss = (timeMillis - day * 24 * 60 * 60 * 1000 - hour * 60 * 60 * 1000 - min * 60 * 1000 - s * 1000);\n\t\treturn (day > 0 ? day + \",\" : \"\") + hour + \":\" + min + \":\" + s + \".\" + sss;\n\t}\n\n\t/**\n\t * Calculate days between two dates\n\t */\n\tpublic static double getDistanceOfTwoDate(Date before, Date after) {\n\t\tlong beforeTime = before.getTime();\n\t\tlong afterTime = after.getTime();\n\t\treturn (afterTime - beforeTime) / (1000 * 60 * 60 * 24);\n\t}\n\n\t/**\n\t * Add days to given date\n\t */\n\tpublic static Date calculateDate(Date date, int num) {\n\t\tCalendar calendar = Calendar.getInstance();\n\t\tcalendar.setTime(date);\n\t\tcalendar.add(Calendar.DATE, num);\n\t\treturn calendar.getTime();\n\t}\n\n\t/**\n\t * Calculate absolute days difference between two dates\n\t */\n\tpublic static Integer differDate(Date newDate, Date oldDate) {\n\t\tint days = (int) ((newDate.getTime() - oldDate.getTime()) / (1000 * 3600 * 24));\n\t\treturn Math.abs(days);\n\t}\n\n\t/**\n\t * Calculate absolute hours difference between two dates\n\t */\n\tpublic static Integer differDateHours(Date newDate, Date oldDate) {\n\t\tint hours = (int) ((newDate.getTime() - oldDate.getTime()) / (1000 * 60 * 60));\n\t\treturn Math.abs(hours);\n\t}\n\n\t/**\n\t * Calculate absolute minutes difference between two dates\n\t */\n\tpublic static Integer differDateMinutes(Date newDate, Date oldDate) {\n\t\tint minutes = (int) ((newDate.getTime() - oldDate.getTime()) / (1000 * 60));\n\t\treturn Math.abs(minutes);\n\t}\n\n\t/**\n\t * Calculate minutes difference between two dates\n\t */\n\tpublic static Integer differMinutes(Date newDate, Date oldDate) {\n\t\treturn (int) ((newDate.getTime() - oldDate.getTime()) / (1000 * 60));\n\t}\n\n\t/**\n\t * Calculate absolute seconds difference between two dates\n\t */\n\tpublic static Integer differDateSeconds(Date newDate, Date oldDate) {\n\t\tint minutes = (int) ((newDate.getTime() - oldDate.getTime()) / (1000));\n\t\treturn Math.abs(minutes);\n\t}\n\n\t/**\n\t * Calculate seconds difference between two dates\n\t */\n\tpublic static Integer differSeconds(Date newDate, Date oldDate) {\n\t\tint seconds = (int) ((newDate.getTime() - oldDate.getTime()) / (1000));\n\t\treturn Math.max(seconds, 0);\n\t}\n\n\t/**\n\t * Get first day of current month in yyyy-MM-dd format\n\t */\n\tpublic static String getMonthFristDay() {\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_SMALL_STR);\n\t\t// 获取当前月第一天：\n\t\tCalendar c = Calendar.getInstance();\n\t\tc.add(Calendar.MONTH, 0);\n\t\tc.set(Calendar.DAY_OF_MONTH, 1);// 设置为1号,当前日期既为本月第一天\n\t\tString first = format.format(c.getTime());\n\t\treturn first;\n\t}\n\n\t/**\n\t * Get last day of current month in yyyy-MM-dd format\n\t */\n\tpublic static String getMonthLastDay() {\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_SMALL_STR);\n\t\tCalendar ca = Calendar.getInstance();\n\t\tca.set(Calendar.DAY_OF_MONTH, ca.getActualMaximum(Calendar.DAY_OF_MONTH));\n\t\tString last = format.format(ca.getTime());\n\t\tSystem.out.println(\"===============last:\" + last);\n\t\treturn last;\n\t}\n\n\t/**\n\t * Get yesterday's date in yyyyMMdd format\n\t */\n\tpublic static String getYesterday() {\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_YMD_STR);\n\t\tCalendar ca = Calendar.getInstance();\n\t\tca.add(Calendar.DAY_OF_MONTH, -1);\n\t\treturn format.format(ca.getTime());\n\t}\n\n\t/**\n\t * Convert Unix timestamp to Date\n\t */\n\tpublic static Date unixTimeToDate(Long unixTime) {\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_FULL_STR);\n\t\tLong time = unixTime * 1000;\n\t\tString d = format.format(time);\n\t\tDate date = null;\n\t\ttry {\n\t\t\treturn format.parse(d);\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\te.getMessage();\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn date;\n\t}\n\n\t/**\n\t * Convert Date to Unix timestamp\n\t */\n\tpublic static Long toUnixTimestamp(Date date) {\n\t\tif (date == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn date.getTime() / 1000;\n\t}\n\n\t/**\n\t * Get current hour's start time\n\t */\n\tpublic static Date getCurrHourTime() {\n\t\tCalendar ca = Calendar.getInstance();\n\t\tca.set(Calendar.MINUTE, 0);\n\t\tca.set(Calendar.SECOND, 0);\n\t\treturn ca.getTime();\n\t}\n\n\t/**\n\t * Get N hours before current hour's start time\n\t */\n\tpublic static Date getNextHourTime(int n) {\n\t\tCalendar ca = Calendar.getInstance();\n\t\tca.set(Calendar.MINUTE, 0);\n\t\tca.set(Calendar.SECOND, 0);\n\t\tca.set(Calendar.HOUR_OF_DAY, ca.get(Calendar.HOUR_OF_DAY) - n);\n\t\treturn ca.getTime();\n\t}\n\n\t/**\n\t * Get date N days after current date\n\t */\n\tpublic static Date getAfterDayTime(int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(new Date());\n\t\tcal.add(Calendar.DATE, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get first second of N days after current date\n\t */\n\tpublic static Date getFirstSecondOfAfterDayTime(int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.add(Calendar.DATE, n);\n\t\tcal.set(Calendar.HOUR_OF_DAY, 0);\n\t\tcal.set(Calendar.MINUTE, 0);\n\t\tcal.set(Calendar.SECOND, 0);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N hours after current date\n\t */\n\tpublic static Date getAfterHourTime(int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(new Date());\n\t\tcal.add(Calendar.HOUR, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N minutes after current date\n\t */\n\tpublic static Date getAfterMinTime(int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(new Date());\n\t\tcal.add(Calendar.MINUTE, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N minutes after given date\n\t */\n\tpublic static Date getAfterMinTime(Date date, int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.add(Calendar.MINUTE, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N hours after given date\n\t */\n\tpublic static Date getAfterHourTimeForDate(Date date, int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.add(Calendar.HOUR, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N hours before given date\n\t */\n\tpublic static Date getBeforeHourTimeForDate(Date date, int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.add(Calendar.HOUR, -n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get end time (9999-12-31 23:59:59)\n\t */\n\tpublic static Date endTime() {\n\t\treturn parseDate(END_TIME_STR);\n\t}\n\n\t/**\n\t * Get last second of given date\n\t */\n\tpublic static Date getLastSecondOfDay(Date date) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.set(Calendar.HOUR_OF_DAY, 23);\n\t\tcal.set(Calendar.MINUTE, 59);\n\t\tcal.set(Calendar.SECOND, 59);\n\t\tcal.set(Calendar.MILLISECOND, 0);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get last second of given hour\n\t */\n\tpublic static Date getLastSecondOfHour(Date date) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.set(Calendar.MINUTE, 59);\n\t\tcal.set(Calendar.SECOND, 59);\n\t\tcal.set(Calendar.MILLISECOND, 0);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get datetime for given hour of current day\n\t */\n\tpublic static Date getGivenHourDateTime(String hourTime) {\n\t\t// 得到当天yyyy-mm-dd格式\n\t\tString dayTime = getDate();\n\t\tString fullTimeStr = dayTime + \" \" + hourTime;\n\t\tSimpleDateFormat sdf = new SimpleDateFormat(DATE_FULL_STR);\n\t\ttry {\n\t\t\tDate date = sdf.parse(fullTimeStr);\n\t\t\treturn date;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Calculate MetaQ delay level based on date difference\n\t */\n\tpublic static int getMetaqDelayLevel(Date date) {\n\t\tint diffMinutes = differDateMinutes(new Date(), date);\n\t\tif (diffMinutes >= 0 && diffMinutes <= 10) {\n\t\t\treturn diffMinutes + 4;\n\t\t}\n\t\telse if (diffMinutes > 10 && diffMinutes < 60) {\n\t\t\treturn 14;\n\t\t}\n\t\telse if (diffMinutes >= 60 && diffMinutes < 120) {\n\t\t\treturn 17;\n\t\t}\n\t\treturn 18;\n\n\t}\n\n\t/**\n\t * Validate if date string matches given format\n\t */\n\tpublic static boolean isLegalDate(String sDate, String format) {\n\t\tif ((sDate == null) || (sDate.length() != format.length())) {\n\t\t\treturn false;\n\t\t}\n\t\tDateFormat formatter = new SimpleDateFormat(format);\n\t\ttry {\n\t\t\tDate date = formatter.parse(sDate);\n\t\t\treturn sDate.equals(formatter.format(date));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Convert date string from one format to another\n\t */\n\tpublic static String covertDateFormat(String dateStr, String format) {\n\n\t\ttry {\n\t\t\tDate date = DateUtils.parseDate(dateStr, DateUtils.DATE_YMD_STR);\n\t\t\treturn DateUtils.formatDateTimeSmall(date, format);\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Get start of current day\n\t */\n\tpublic static Date getToday() {\n\t\tCalendar calendar = Calendar.getInstance();\n\t\tcalendar.set(Calendar.HOUR_OF_DAY, 0);\n\t\tcalendar.set(Calendar.MINUTE, 0);\n\t\tcalendar.set(Calendar.SECOND, 0);\n\t\treturn calendar.getTime();\n\t}\n\n}", "output": "/*\n * Copyright 2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alibaba.cloud.ai.studio.core.utils.common;\n\nimport org.apache.commons.lang3.time.DateFormatUtils;\n\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Locale;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Utility class for date and time operations.\n *\n * @since 1.0.0.3\n */\npublic class DateUtils extends org.apache.commons.lang3.time.DateUtils {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(DateUtils.class);\n\n\t// Date format patterns\n\tpublic static final String DATE_JFP_STR = \"yyyyMM\";\n\n\tpublic static final String DATE_YMD_STR = \"yyyyMMdd\";\n\n\tpublic static final String DATE_SMALL_STR = \"yyyy-MM-dd\";\n\n\tpublic static final String DATE_FULL_STR = \"yyyy-MM-dd HH:mm:ss\";\n\n\tpublic static final String DATE_KEY_STR = \"yyyyMMddHHmmss\";\n\n\tpublic static final String END_TIME_STR = \"9999-12-31 23:59:59\";\n\n\tpublic static final String DATE_SMALL_STR_SHOW = \"yyyy年MM月dd号HH点mm分\";\n\n\tpublic static final String DATE_MONTH_DAY_STR_SHOW = \"MM月dd号\";\n\n\t// Supported date parse patterns\n\tprivate static final String[] parsePatterns = { \"yyyy-MM-dd\", \"yyyy-MM-dd HH:mm:ss\", \"yyyy-MM-dd HH:mm\", \"yyyy-MM\",\n\t\t\t\"yyyy/MM/dd\", \"yyyy/MM/dd HH:mm:ss\", \"yyyy/MM/dd HH:mm\", \"yyyy/MM\", \"yyyy.MM.dd\", \"yyyy.MM.dd HH:mm:ss\",\n\t\t\t\"yyyy.MM.dd HH:mm\", \"yyyy.MM\", \"yyyyMMddHHmmss\", \"yyyyMMdd\" };\n\n\t/**\n\t * Format date to yyyyMMdd string\n\t */\n\tpublic static String formatSimple(Date date) {\n\t\tif (date == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn DateFormatUtils.format(date, DATE_YMD_STR);\n\t}\n\n\t/**\n\t * Get current date and time in full format (yyyy-MM-dd HH:mm:ss)\n\t */\n\tpublic static String getFullDate() {\n\t\treturn getDate(DATE_FULL_STR);\n\t}\n\n\t/**\n\t * Get current date in yyyy-MM-dd format\n\t */\n\tpublic static String getDate() {\n\t\treturn getDate(DATE_SMALL_STR);\n\t}\n\n\t/**\n\t * Get current date string in specified pattern\n\t * @param pattern Date format pattern\n\t */\n\tpublic static String getDate(String pattern) {\n\t\treturn DateFormatUtils.format(new Date(), pattern);\n\t}\n\n\t/**\n\t * Format date to string with specified pattern\n\t * @param date Date to format\n\t * @param pattern Format pattern\n\t */\n\tpublic static String formatDate(Date date, Object... pattern) {\n\t\tString formatDate = null;\n\t\tif (pattern != null && pattern.length > 0) {\n\t\t\tformatDate = DateFormatUtils.format(date, pattern[0].toString());\n\t\t}\n\t\telse {\n\t\t\tformatDate = DateFormatUtils.format(date, DATE_SMALL_STR);\n\t\t}\n\t\treturn formatDate;\n\t}\n\n\t/**\n\t * Format date to full datetime string (yyyy-MM-dd HH:mm:ss)\n\t */\n\tpublic static String formatDateTimeFull(Date date) {\n\t\tif (date == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn formatDate(date, DATE_FULL_STR);\n\t}\n\n\t/**\n\t * Format date to specified format\n\t */\n\tpublic static String formatDateTimeSmall(Date date, String format) {\n\t\treturn formatDate(date, format);\n\t}\n\n\t/**\n\t * Get current datetime in yyyyMMddHHmmss format\n\t */\n\tpublic static String getDateTime14() {\n\t\tlong currTime = System.currentTimeMillis();\n\t\tDate date = new Date(currTime);\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_KEY_STR);\n\t\treturn format.format(date);\n\t}\n\n\t/**\n\t * Format timestamp to yyyyMMddHHmmss string\n\t */\n\tpublic static String getDateTime14(long time) {\n\t\tDate date = new Date(time);\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_FULL_STR);\n\t\treturn format.format(date);\n\t}\n\n\t/**\n\t * Get current time in HH:mm:ss format\n\t */\n\tpublic static String getTime() {\n\t\treturn formatDate(new Date(), \"HH:mm:ss\");\n\t}\n\n\t/**\n\t * Get current datetime in yyyy-MM-dd HH:mm:ss format\n\t */\n\tpublic static String getDateTime() {\n\t\treturn formatDate(new Date(), DATE_FULL_STR);\n\t}\n\n\t/**\n\t * Get current year\n\t */\n\tpublic static String getYear() {\n\t\treturn formatDate(new Date(), \"yyyy\");\n\t}\n\n\t/**\n\t * Get current month\n\t */\n\tpublic static String getMonth() {\n\t\treturn formatDate(new Date(), \"MM\");\n\t}\n\n\t/**\n\t * Get current day\n\t */\n\tpublic static String getDay() {\n\t\treturn formatDate(new Date(), \"dd\");\n\t}\n\n\t/**\n\t * Get current weekday\n\t */\n\tpublic static String getWeek() {\n\t\treturn formatDate(new Date(), \"E\");\n\t}\n\n\t/**\n\t * Get current hour\n\t */\n\tpublic static Integer getHour() {\n\t\tCalendar calendar = Calendar.getInstance();\n\t\treturn calendar.get(Calendar.HOUR_OF_DAY);\n\t}\n\n\t/**\n\t * Parse date string to Date object Supports multiple date formats\n\t */\n\tpublic static Date parseDate(Object str) {\n\t\tif (str == null) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\treturn org.apache.commons.lang3.time.DateUtils.parseDate(str.toString(), parsePatterns);\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Parse date string in EEE MMM dd HH:mm:ss zzz yyyy format\n\t */\n\tpublic static Date parseDateString(String time) {\n\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\", Locale.ENGLISH);\n\t\ttry {\n\t\t\treturn sdf.parse(time);\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\tlogger.warn(\"Failed to parse date string: {}\", time, e);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Calculate days between now and given date\n\t */\n\tpublic static long pastDays(Date date) {\n\t\tlong t = System.currentTimeMillis() - date.getTime();\n\t\treturn t / (24 * 60 * 60 * 1000);\n\t}\n\n\t/**\n\t * Calculate hours between now and given date\n\t */\n\tpublic static long pastHour(Date date) {\n\t\tlong t = System.currentTimeMillis() - date.getTime();\n\t\treturn t / (60 * 60 * 1000);\n\t}\n\n\t/**\n\t * Calculate minutes between now and given date\n\t */\n\tpublic static long pastMinutes(Date date) {\n\t\tlong t = System.currentTimeMillis() - date.getTime();\n\t\treturn t / (60 * 1000);\n\t}\n\n\t/**\n\t * Format milliseconds to time string (days,hours:minutes:seconds.milliseconds)\n\t */\n\tpublic static String formatDateTime(long timeMillis) {\n\t\tlong day = timeMillis / (24 * 60 * 60 * 1000);\n\t\tlong hour = (timeMillis / (60 * 60 * 1000) - day * 24);\n\t\tlong min = ((timeMillis / (60 * 1000)) - day * 24 * 60 - hour * 60);\n\t\tlong s = (timeMillis / 1000 - day * 24 * 60 * 60 - hour * 60 * 60 - min * 60);\n\t\tlong sss = (timeMillis - day * 24 * 60 * 60 * 1000 - hour * 60 * 60 * 1000 - min * 60 * 1000 - s * 1000);\n\t\treturn (day > 0 ? day + \",\" : \"\") + hour + \":\" + min + \":\" + s + \".\" + sss;\n\t}\n\n\t/**\n\t * Calculate days between two dates\n\t */\n\tpublic static double getDistanceOfTwoDate(Date before, Date after) {\n\t\tlong beforeTime = before.getTime();\n\t\tlong afterTime = after.getTime();\n\t\treturn (afterTime - beforeTime) / (1000 * 60 * 60 * 24);\n\t}\n\n\t/**\n\t * Add days to given date\n\t */\n\tpublic static Date calculateDate(Date date, int num) {\n\t\tCalendar calendar = Calendar.getInstance();\n\t\tcalendar.setTime(date);\n\t\tcalendar.add(Calendar.DATE, num);\n\t\treturn calendar.getTime();\n\t}\n\n\t/**\n\t * Calculate absolute days difference between two dates\n\t */\n\tpublic static Integer differDate(Date newDate, Date oldDate) {\n\t\tint days = (int) ((newDate.getTime() - oldDate.getTime()) / (1000 * 3600 * 24));\n\t\treturn Math.abs(days);\n\t}\n\n\t/**\n\t * Calculate absolute hours difference between two dates\n\t */\n\tpublic static Integer differDateHours(Date newDate, Date oldDate) {\n\t\tint hours = (int) ((newDate.getTime() - oldDate.getTime()) / (1000 * 60 * 60));\n\t\treturn Math.abs(hours);\n\t}\n\n\t/**\n\t * Calculate absolute minutes difference between two dates\n\t */\n\tpublic static Integer differDateMinutes(Date newDate, Date oldDate) {\n\t\tint minutes = (int) ((newDate.getTime() - oldDate.getTime()) / (1000 * 60));\n\t\treturn Math.abs(minutes);\n\t}\n\n\t/**\n\t * Calculate minutes difference between two dates\n\t */\n\tpublic static Integer differMinutes(Date newDate, Date oldDate) {\n\t\treturn (int) ((newDate.getTime() - oldDate.getTime()) / (1000 * 60));\n\t}\n\n\t/**\n\t * Calculate absolute seconds difference between two dates\n\t */\n\tpublic static Integer differDateSeconds(Date newDate, Date oldDate) {\n\t\tint minutes = (int) ((newDate.getTime() - oldDate.getTime()) / (1000));\n\t\treturn Math.abs(minutes);\n\t}\n\n\t/**\n\t * Calculate seconds difference between two dates\n\t */\n\tpublic static Integer differSeconds(Date newDate, Date oldDate) {\n\t\tint seconds = (int) ((newDate.getTime() - oldDate.getTime()) / (1000));\n\t\treturn Math.max(seconds, 0);\n\t}\n\n\t/**\n\t * Get first day of current month in yyyy-MM-dd format\n\t */\n\tpublic static String getMonthFristDay() {\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_SMALL_STR);\n\t\t// 获取当前月第一天：\n\t\tCalendar c = Calendar.getInstance();\n\t\tc.add(Calendar.MONTH, 0);\n\t\tc.set(Calendar.DAY_OF_MONTH, 1);// 设置为1号,当前日期既为本月第一天\n\t\tString first = format.format(c.getTime());\n\t\treturn first;\n\t}\n\n\t/**\n\t * Get last day of current month in yyyy-MM-dd format\n\t */\n\tpublic static String getMonthLastDay() {\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_SMALL_STR);\n\t\tCalendar ca = Calendar.getInstance();\n\t\tca.set(Calendar.DAY_OF_MONTH, ca.getActualMaximum(Calendar.DAY_OF_MONTH));\n\t\tString last = format.format(ca.getTime());\n\t\tSystem.out.println(\"===============last:\" + last);\n\t\treturn last;\n\t}\n\n\t/**\n\t * Get yesterday's date in yyyyMMdd format\n\t */\n\tpublic static String getYesterday() {\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_YMD_STR);\n\t\tCalendar ca = Calendar.getInstance();\n\t\tca.add(Calendar.DAY_OF_MONTH, -1);\n\t\treturn format.format(ca.getTime());\n\t}\n\n\t/**\n\t * Convert Unix timestamp to Date\n\t */\n\tpublic static Date unixTimeToDate(Long unixTime) {\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_FULL_STR);\n\t\tLong time = unixTime * 1000;\n\t\tString d = format.format(time);\n\t\tDate date = null;\n\t\ttry {\n\t\t\treturn format.parse(d);\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\te.getMessage();\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn date;\n\t}\n\n\t/**\n\t * Convert Date to Unix timestamp\n\t */\n\tpublic static Long toUnixTimestamp(Date date) {\n\t\tif (date == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn date.getTime() / 1000;\n\t}\n\n\t/**\n\t * Get current hour's start time\n\t */\n\tpublic static Date getCurrHourTime() {\n\t\tCalendar ca = Calendar.getInstance();\n\t\tca.set(Calendar.MINUTE, 0);\n\t\tca.set(Calendar.SECOND, 0);\n\t\treturn ca.getTime();\n\t}\n\n\t/**\n\t * Get N hours before current hour's start time\n\t */\n\tpublic static Date getNextHourTime(int n) {\n\t\tCalendar ca = Calendar.getInstance();\n\t\tca.set(Calendar.MINUTE, 0);\n\t\tca.set(Calendar.SECOND, 0);\n\t\tca.set(Calendar.HOUR_OF_DAY, ca.get(Calendar.HOUR_OF_DAY) - n);\n\t\treturn ca.getTime();\n\t}\n\n\t/**\n\t * Get date N days after current date\n\t */\n\tpublic static Date getAfterDayTime(int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(new Date());\n\t\tcal.add(Calendar.DATE, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get first second of N days after current date\n\t */\n\tpublic static Date getFirstSecondOfAfterDayTime(int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.add(Calendar.DATE, n);\n\t\tcal.set(Calendar.HOUR_OF_DAY, 0);\n\t\tcal.set(Calendar.MINUTE, 0);\n\t\tcal.set(Calendar.SECOND, 0);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N hours after current date\n\t */\n\tpublic static Date getAfterHourTime(int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(new Date());\n\t\tcal.add(Calendar.HOUR, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N minutes after current date\n\t */\n\tpublic static Date getAfterMinTime(int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(new Date());\n\t\tcal.add(Calendar.MINUTE, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N minutes after given date\n\t */\n\tpublic static Date getAfterMinTime(Date date, int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.add(Calendar.MINUTE, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N hours after given date\n\t */\n\tpublic static Date getAfterHourTimeForDate(Date date, int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.add(Calendar.HOUR, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N hours before given date\n\t */\n\tpublic static Date getBeforeHourTimeForDate(Date date, int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.add(Calendar.HOUR, -n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get end time (9999-12-31 23:59:59)\n\t */\n\tpublic static Date endTime() {\n\t\treturn parseDate(END_TIME_STR);\n\t}\n\n\t/**\n\t * Get last second of given date\n\t */\n\tpublic static Date getLastSecondOfDay(Date date) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.set(Calendar.HOUR_OF_DAY, 23);\n\t\tcal.set(Calendar.MINUTE, 59);\n\t\tcal.set(Calendar.SECOND, 59);\n\t\tcal.set(Calendar.MILLISECOND, 0);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get last second of given hour\n\t */\n\tpublic static Date getLastSecondOfHour(Date date) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.set(Calendar.MINUTE, 59);\n\t\tcal.set(Calendar.SECOND, 59);\n\t\tcal.set(Calendar.MILLISECOND, 0);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get datetime for given hour of current day\n\t */\n\tpublic static Date getGivenHourDateTime(String hourTime) {\n\t\t// 得到当天yyyy-mm-dd格式\n\t\tString dayTime = getDate();\n\t\tString fullTimeStr = dayTime + \" \" + hourTime;\n\t\tSimpleDateFormat sdf = new SimpleDateFormat(DATE_FULL_STR);\n\t\ttry {\n\t\t\tDate date = sdf.parse(fullTimeStr);\n\t\t\treturn date;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Calculate MetaQ delay level based on date difference\n\t */\n\tpublic static int getMetaqDelayLevel(Date date) {\n\t\tint diffMinutes = differDateMinutes(new Date(), date);\n\t\tif (diffMinutes >= 0 && diffMinutes <= 10) {\n\t\t\treturn diffMinutes + 4;\n\t\t}\n\t\telse if (diffMinutes > 10 && diffMinutes < 60) {\n\t\t\treturn 14;\n\t\t}\n\t\telse if (diffMinutes >= 60 && diffMinutes < 120) {\n\t\t\treturn 17;\n\t\t}\n\t\treturn 18;\n\n\t}\n\n\t/**\n\t * Validate if date string matches given format\n\t */\n\tpublic static boolean isLegalDate(String sDate, String format) {\n\t\tif ((sDate == null) || (sDate.length() != format.length())) {\n\t\t\treturn false;\n\t\t}\n\t\tDateFormat formatter = new SimpleDateFormat(format);\n\t\ttry {\n\t\t\tDate date = formatter.parse(sDate);\n\t\t\treturn sDate.equals(formatter.format(date));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Convert date string from one format to another\n\t */\n\tpublic static String covertDateFormat(String dateStr, String format) {\n\n\t\ttry {\n\t\t\tDate date = DateUtils.parseDate(dateStr, DateUtils.DATE_YMD_STR);\n\t\t\treturn DateUtils.formatDateTimeSmall(date, format);\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Get start of current day\n\t */\n\tpublic static Date getToday() {\n\t\tCalendar calendar = Calendar.getInstance();\n\t\tcalendar.set(Calendar.HOUR_OF_DAY, 0);\n\t\tcalendar.set(Calendar.MINUTE, 0);\n\t\tcalendar.set(Calendar.SECOND, 0);\n\t\treturn calendar.getTime();\n\t}\n\n}", "metadata": {"commit_sha": "d5539604", "lines_added": 8, "lines_deleted": 5, "total_changes": 13, "chunks": 2}}
{"id": 14, "pattern_type": "refactoring", "file_path": "spring-ai-alibaba-studio/ui/src/pages/layout.tsx", "file_extension": "tsx", "input": "/**\n * Copyright 2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { useEffect, useState } from 'react';\nimport { Layout, Menu, Flex, Button, Radio } from 'antd';\nimport type { RadioChangeEvent } from 'antd';\nimport { Outlet, useNavigate, useLocation } from 'ice';\nimport styles from './layout.module.css';\nimport { useTranslation } from 'react-i18next';\nimport {\n  CloudTwoTone,\n  CodeTwoTone,\n  ExperimentTwoTone,\n} from '@ant-design/icons';\nimport { getCurrentPath } from '@/utils/locationUtil';\n\nexport default function PageLayout() {\n  const { t, i18n } = useTranslation();\n  const { Header } = Layout;\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  const [language, setLanguage] = useState('');\n\n  const languageOptions = [\n    {\n      value: 'zh',\n      label: t('chinese'),\n    },\n    {\n      value: 'en',\n      label: t('english'),\n    },\n  ];\n\n  const headerMenu = [\n    {\n      key: '/run',\n      icon: <CodeTwoTone />,\n      label: t('run'),\n    },\n    {\n      key: '/traces',\n      icon: <CloudTwoTone />,\n      label: t('traces'),\n    },\n    {\n      key: '/evaluate',\n      icon: <ExperimentTwoTone />,\n      label: t('evaluate'),\n    },\n  ];\n\n  const [selectedKey, setSelectedKey] = useState(\n    `/${getCurrentPath().split('/')[1]}` || headerMenu[0].key,\n  );\n\n  const onMenuClick = (e) => {\n    setSelectedKey(e.key);\n    navigate(e.key);\n  };\n\n  const onLanguageChange = ({ target: { value } }: RadioChangeEvent) => {\n    setLanguage(value);\n    i18n.changeLanguage(value);\n  };\n\n  useEffect(() => {\n    if (location.pathname === '/') {\n      navigate(headerMenu[0].key);\n      setSelectedKey(headerMenu[0].key);\n    }\n  }, [location, navigate]);\n\n  useEffect(() => {\n    setLanguage(i18n.language);\n  }, [i18n.language]);\n\n  return (\n    <Layout>\n      <Header className={styles.header}>\n        <span>alibaba-ai-studio</span>\n        <Flex justify={'center'}>\n          <Menu\n            style={{ minWidth: 300 }}\n            mode=\"horizontal\"\n            selectedKeys={[selectedKey]}\n            items={headerMenu}\n            onClick={onMenuClick}\n          />\n        </Flex>\n        <Flex>\n          <Button color=\"default\" variant=\"link\">\n            {t('github')}\n          </Button>\n          <Button color=\"default\" variant=\"link\">\n            {t('document')}\n          </Button>\n          <Radio.Group\n            options={languageOptions}\n            onChange={onLanguageChange}\n            value={language}\n            optionType=\"button\"\n            buttonStyle=\"solid\"\n          />\n        </Flex>\n      </Header>\n      <div className={styles.body}>\n        <Outlet />\n      </div>\n    </Layout>\n  );\n}", "output": "/**\n * Copyright 2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { useEffect, useState } from 'react';\nimport { Layout, Menu, Flex, Button, Radio } from 'antd';\nimport type { RadioChangeEvent } from 'antd';\nimport { Outlet, useNavigate, useLocation } from 'ice';\nimport styles from './layout.module.css';\nimport { useTranslation } from 'react-i18next';\nimport {\n  CloudTwoTone,\n  CodeTwoTone,\n  ExperimentTwoTone,\n} from '@ant-design/icons';\n\nexport default function PageLayout() {\n  const { t, i18n } = useTranslation();\n  const { Header } = Layout;\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  const [language, setLanguage] = useState('');\n\n  const languageOptions = [\n    {\n      value: 'zh',\n      label: t('chinese'),\n    },\n    {\n      value: 'en',\n      label: t('english'),\n    },\n  ];\n\n  const headerMenu = [\n    {\n      key: '/run',\n      icon: <CodeTwoTone />,\n      label: t('run'),\n    },\n    {\n      key: '/traces',\n      icon: <CloudTwoTone />,\n      label: t('traces'),\n    },\n    {\n      key: '/evaluate',\n      icon: <ExperimentTwoTone />,\n      label: t('evaluate'),\n    },\n  ];\n\n  const [selectedKey, setSelectedKey] = useState(\n    `/${location.pathname.split('/')[1]}` || headerMenu[0].key,\n  );\n\n  const onMenuClick = (e) => {\n    setSelectedKey(e.key);\n    navigate(e.key);\n  };\n\n  const onLanguageChange = ({ target: { value } }: RadioChangeEvent) => {\n    setLanguage(value);\n    i18n.changeLanguage(value);\n  };\n\n  useEffect(() => {\n    if (location.pathname === '/') {\n      navigate(headerMenu[0].key);\n      setSelectedKey(headerMenu[0].key);\n    }\n  }, [location, navigate]);\n\n  useEffect(() => {\n    setLanguage(i18n.language);\n  }, [i18n.language]);\n\n  return (\n    <Layout>\n      <Header className={styles.header}>\n        <span>alibaba-ai-studio</span>\n        <Flex justify={'center'}>\n          <Menu\n            style={{ minWidth: 300 }}\n            mode=\"horizontal\"\n            selectedKeys={[selectedKey]}\n            items={headerMenu}\n            onClick={onMenuClick}\n          />\n        </Flex>\n        <Flex>\n          <Button color=\"default\" variant=\"link\">\n            {t('github')}\n          </Button>\n          <Button color=\"default\" variant=\"link\">\n            {t('document')}\n          </Button>\n          <Radio.Group\n            options={languageOptions}\n            onChange={onLanguageChange}\n            value={language}\n            optionType=\"button\"\n            buttonStyle=\"solid\"\n          />\n        </Flex>\n      </Header>\n      <div className={styles.body}>\n        <Outlet />\n      </div>\n    </Layout>\n  );\n}", "metadata": {"commit_sha": "88321d25", "lines_added": 1, "lines_deleted": 2, "total_changes": 3, "chunks": 2}}
{"id": 166, "pattern_type": "function_signature_change", "file_path": "spring-ai-alibaba-graph/spring-ai-alibaba-graph-studio/src/main/java/com/alibaba/cloud/ai/service/dsl/adapters/DifyDSLAdapter.java", "file_extension": "java", "input": "/*\n * Copyright 2024-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.service.dsl.adapters;\n\nimport com.alibaba.cloud.ai.model.App;\nimport com.alibaba.cloud.ai.model.AppMetadata;\nimport com.alibaba.cloud.ai.model.Variable;\nimport com.alibaba.cloud.ai.model.chatbot.ChatBot;\nimport com.alibaba.cloud.ai.model.workflow.Edge;\nimport com.alibaba.cloud.ai.model.workflow.Graph;\nimport com.alibaba.cloud.ai.model.workflow.Node;\nimport com.alibaba.cloud.ai.model.workflow.NodeData;\nimport com.alibaba.cloud.ai.model.workflow.NodeType;\nimport com.alibaba.cloud.ai.model.workflow.Workflow;\nimport com.alibaba.cloud.ai.model.workflow.nodedata.CodeNodeData;\nimport com.alibaba.cloud.ai.model.workflow.nodedata.EmptyNodeData;\nimport com.alibaba.cloud.ai.model.workflow.nodedata.IterationNodeData;\nimport com.alibaba.cloud.ai.model.workflow.nodedata.VariableAggregatorNodeData;\nimport com.alibaba.cloud.ai.service.dsl.DSLDialectType;\nimport com.alibaba.cloud.ai.service.dsl.Serializer;\nimport com.alibaba.cloud.ai.service.dsl.NodeDataConverter;\nimport com.alibaba.cloud.ai.service.dsl.AbstractDSLAdapter;\nimport com.alibaba.cloud.ai.model.VariableSelector;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.PropertyNamingStrategies;\nimport org.apache.commons.lang3.NotImplementedException;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Component;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * DifyDSLAdapter converts Dify DSL to {@link App} and vice versa.\n */\n@Component\npublic class DifyDSLAdapter extends AbstractDSLAdapter {\n\n\tprivate static final String[] DIFY_CHATBOT_MODES = { \"chat\", \"completion\", \"agent-chat\" };\n\n\tprivate static final String[] DIFY_WORKFLOW_MODES = { \"workflow\", \"advanced-chat\" };\n\n\tprivate final List<NodeDataConverter<? extends NodeData>> nodeDataConverters;\n\n\tprivate final Serializer serializer;\n\n\tpublic DifyDSLAdapter(List<NodeDataConverter<? extends NodeData>> nodeDataConverters,\n\t\t\t@Qualifier(\"yaml\") Serializer serializer) {\n\t\tthis.nodeDataConverters = nodeDataConverters;\n\t\tthis.serializer = serializer;\n\t}\n\n\tprivate NodeDataConverter<? extends NodeData> getNodeDataConverter(NodeType nodeType) {\n\t\treturn nodeDataConverters.stream()\n\t\t\t.filter(converter -> converter.supportNodeType(nodeType))\n\t\t\t.findFirst()\n\t\t\t.orElseThrow(() -> new IllegalArgumentException(\"invalid dify node type \" + nodeType));\n\t}\n\n\t@Override\n\tpublic void validateDSLData(Map<String, Object> dslData) {\n\t\tif (dslData == null || !dslData.containsKey(\"app\")) {\n\t\t\tthrow new IllegalArgumentException(\"invalid dify dsl\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic Serializer getSerializer() {\n\t\treturn serializer;\n\t}\n\n\t@Override\n\tpublic AppMetadata mapToMetadata(Map<String, Object> data) {\n\t\tMap<String, Object> map = (Map<String, Object>) data.get(\"app\");\n\t\tAppMetadata metadata = new AppMetadata();\n\t\tif (Arrays.asList(DIFY_CHATBOT_MODES).contains((String) map.get(\"mode\"))) {\n\t\t\tmetadata.setMode(AppMetadata.CHATBOT_MODE);\n\t\t}\n\t\telse if (Arrays.asList(DIFY_WORKFLOW_MODES).contains((String) map.get(\"mode\"))) {\n\t\t\tmetadata.setMode(AppMetadata.WORKFLOW_MODE);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"unknown dify app mode\" + map.get(\"mode\"));\n\t\t}\n\t\tmetadata.setId(UUID.randomUUID().toString());\n\t\tmetadata.setName((String) map.getOrDefault(\"name\", metadata.getMode() + \"-\" + metadata.getId()));\n\t\tmetadata.setDescription((String) map.getOrDefault(\"description\", \"\"));\n\t\treturn metadata;\n\t}\n\n\t@Override\n\tpublic Map<String, Object> metadataToMap(AppMetadata metadata) {\n\t\tMap<String, Object> data = new HashMap<>();\n\t\tString difyMode = metadata.getMode().equals(AppMetadata.WORKFLOW_MODE) ? \"workflow\" : \"agent-chat\";\n\t\tdata.put(\"app\", Map.of(\"name\", metadata.getName(), \"description\", metadata.getDescription(), \"mode\", difyMode));\n\t\tdata.put(\"kind\", \"app\");\n\t\treturn data;\n\t}\n\n\t@Override\n\tpublic Workflow mapToWorkflow(Map<String, Object> data) {\n\t\tMap<String, Object> workflowData = (Map<String, Object>) data.get(\"workflow\");\n\t\tWorkflow workflow = new Workflow();\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tobjectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\t\t// map key is snake_case style\n\t\tobjectMapper.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);\n\t\tList<Variable> convVars = new ArrayList<>();\n\t\tif (workflowData.containsKey(\"conversation_variables\")) {\n\t\t\tList<Map<String, Object>> variables = (List<Map<String, Object>>) workflowData\n\t\t\t\t.get(\"conversation_variables\");\n\t\t\tconvVars = variables.stream().map(variable -> objectMapper.convertValue(variable, Variable.class)).toList();\n\t\t}\n\n\t\tif (workflowData.containsKey(\"environment_variables\")) {\n\t\t\tList<Map<String, Object>> variables = (List<Map<String, Object>>) workflowData.get(\"environment_variables\");\n\t\t\tList<Variable> envVars = variables.stream()\n\t\t\t\t.map(variable -> objectMapper.convertValue(variable, Variable.class))\n\t\t\t\t.collect(Collectors.toList());\n\t\t\tworkflow.setEnvVars(envVars);\n\t\t}\n\n\t\tGraph graph = constructGraph((Map<String, Object>) workflowData.get(\"graph\"));\n\n\t\t// del codeNode\n\t\tMap<String, String> idToVarName = graph.getNodes()\n\t\t\t.stream()\n\t\t\t.collect(Collectors.toMap(Node::getId, n -> n.getData().getVarName()));\n\n\t\tfor (Node node : graph.getNodes()) {\n\t\t\tif (NodeType.CODE.value().equals(node.getType())) {\n\t\t\t\tCodeNodeData cd = (CodeNodeData) node.getData();\n\t\t\t\tfor (VariableSelector sel : cd.getInputs()) {\n\t\t\t\t\tString upstreamId = sel.getNamespace();\n\t\t\t\t\tString upstreamVar = idToVarName.get(upstreamId);\n\t\t\t\t\t// 可能来自一个节点的多个变量\n\t\t\t\t\tsel.setName(upstreamVar + \".\" + sel.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tworkflow.setGraph(graph);\n\t\t// register overAllState output key\n\t\tList<Variable> extraVars = graph.getNodes().stream().flatMap(node -> {\n\t\t\tNodeType type = NodeType.fromValue(node.getType())\n\t\t\t\t.orElseThrow(() -> new IllegalArgumentException(\"Unsupported NodeType: \" + node.getType()));\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tNodeDataConverter<NodeData> conv = (NodeDataConverter<NodeData>) getNodeDataConverter(type);\n\t\t\treturn conv.extractWorkflowVars(node.getData());\n\t\t}).toList();\n\n\t\tList<Variable> allVars = new ArrayList<>(Stream.concat(convVars.stream(), extraVars.stream())\n\t\t\t.collect(Collectors.toMap(Variable::getName, v -> v, (v1, v2) -> v1))\n\t\t\t.values());\n\n\t\tworkflow.setWorkflowVars(allVars);\n\n\t\treturn workflow;\n\t}\n\n\tprivate Graph constructGraph(Map<String, Object> data) {\n\t\tGraph graph = new Graph();\n\t\tList<Node> nodes = new ArrayList<>();\n\t\tList<Edge> edges = new ArrayList<>();\n\t\t// convert nodes\n\t\tif (data.containsKey(\"nodes\")) {\n\t\t\tList<Map<String, Object>> nodeMaps = (List<Map<String, Object>>) data.get(\"nodes\");\n\t\t\tnodes = constructNodes(nodeMaps);\n\t\t}\n\t\t// convert edges\n\t\tif (data.containsKey(\"edges\")) {\n\t\t\tList<Map<String, Object>> edgeMaps = (List<Map<String, Object>>) data.get(\"edges\");\n\t\t\tedges = constructEdges(edgeMaps);\n\t\t}\n\n\t\tgraph.setNodes(nodes);\n\t\tgraph.setEdges(edges);\n\t\treturn graph;\n\t}\n\n\tprivate List<Node> constructNodes(List<Map<String, Object>> nodeMaps) {\n\t\tObjectMapper objectMapper = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,\n\t\t\t\tfalse);\n\n\t\tMap<NodeType, Integer> counters = new HashMap<>();\n\t\tList<Node> nodes = new ArrayList<>();\n\n\t\tfor (Map<String, Object> nodeMap : nodeMaps) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tMap<String, Object> nodeDataMap = (Map<String, Object>) nodeMap.get(\"data\");\n\t\t\tString difyNodeType = (String) nodeDataMap.get(\"type\");\n\t\t\tif (difyNodeType == null || difyNodeType.isBlank()) {\n\t\t\t\t// This node is just a \"note\", skip it, and the corresponding node will\n\t\t\t\t// not be generated [compatible dify]\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString nodeId = (String) nodeMap.get(\"id\");\n\t\t\tnodeDataMap.put(\"id\", nodeId);\n\t\t\t// determine the type of dify node is supported yet\n\t\t\tNodeType nodeType = NodeType.fromDifyValue(difyNodeType)\n\t\t\t\t.orElseThrow(() -> new NotImplementedException(\"unsupported node type \" + difyNodeType));\n\n\t\t\t// convert node map to workflow node using jackson\n\t\t\tnodeMap.remove(\"data\");\n\t\t\tNode node = objectMapper.convertValue(nodeMap, Node.class);\n\t\t\t// set title and desc\n\t\t\tnode.setTitle((String) nodeDataMap.get(\"title\")).setDesc((String) nodeDataMap.get(\"desc\"));\n\n\t\t\t// convert node data using specific WorkflowNodeDataConverter\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tNodeDataConverter<NodeData> converter = (NodeDataConverter<NodeData>) getNodeDataConverter(nodeType);\n\n\t\t\tNodeData data = converter.parseMapData(nodeDataMap, DSLDialectType.DIFY);\n\n\t\t\t// Generate a readable varName and inject it into NodeData\n\t\t\tint count = counters.merge(nodeType, 1, Integer::sum);\n\t\t\tString varName = converter.generateVarName(count);\n\n\t\t\tdata.setVarName(varName);\n\n\t\t\t// Post-processing: Overwrite the default outputKey and refresh the outputs\n\t\t\tconverter.postProcess(data, varName);\n\n\t\t\tnode.setData(data);\n\t\t\tnode.setType(nodeType.value());\n\t\t\tnodes.add(node);\n\t\t}\n\n\t\t// 等待所有的节点都生成了变量名后，补充迭代节点的起始名称\n\t\tMap<String, String> varNames = nodes.stream()\n\t\t\t.collect(Collectors.toMap(Node::getId, n -> n.getData().getVarName()));\n\t\tfor (Node node : nodes) {\n\t\t\tif (node.getData() instanceof IterationNodeData iterationNodeData) {\n\t\t\t\titerationNodeData\n\t\t\t\t\t.setStartNodeName(varNames.getOrDefault(iterationNodeData.getStartNodeId(), \"unknown\"));\n\t\t\t\titerationNodeData.setEndNodeName(varNames.getOrDefault(iterationNodeData.getEndNodeId(), \"unknown\"));\n\t\t\t}\n\t\t}\n\n\t\tMap<String, String> idToOutputKey = nodes.stream()\n\t\t\t.filter(n -> !(n.getData() instanceof EmptyNodeData))\n\t\t\t.collect(Collectors.toMap(Node::getId, n -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn ((VariableAggregatorNodeData) n.getData()).getOutputKey();\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\treturn n.getData().getOutputs().get(0).getName();\n\t\t\t\t}\n\t\t\t}));\n\n\t\t// Replace all variable paths in all aggregation nodes.\n\t\tfor (Node node : nodes) {\n\t\t\tif (node.getData() instanceof VariableAggregatorNodeData agg) {\n\t\t\t\tList<List<String>> newVars = agg.getVariables().stream().map(path -> {\n\t\t\t\t\tString srcId = path.get(0);\n\t\t\t\t\tString tail = path.get(1);\n\t\t\t\t\tString mapped = idToOutputKey.getOrDefault(srcId, srcId);\n\t\t\t\t\treturn List.of(mapped, tail);\n\t\t\t\t}).toList();\n\t\t\t\tagg.setVariables(newVars);\n\n\t\t\t\tvar adv = agg.getAdvancedSettings();\n\t\t\t\tif (adv != null && adv.getGroups() != null) {\n\t\t\t\t\tfor (var group : adv.getGroups()) {\n\t\t\t\t\t\tList<List<String>> newGroupVars = group.getVariables().stream().map(path -> {\n\t\t\t\t\t\t\tString srcId = path.get(0);\n\t\t\t\t\t\t\tString tail = path.get(1);\n\t\t\t\t\t\t\tString mapped = idToOutputKey.getOrDefault(srcId, srcId);\n\t\t\t\t\t\t\treturn List.of(mapped, tail);\n\t\t\t\t\t\t}).toList();\n\t\t\t\t\t\tgroup.setVariables(newGroupVars);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn nodes;\n\t}\n\n\tprivate List<Edge> constructEdges(List<Map<String, Object>> edgeMaps) {\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tobjectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\t\treturn edgeMaps.stream().map(edgeMap -> objectMapper.convertValue(edgeMap, Edge.class)).toList();\n\t}\n\n\t@Override\n\tpublic Map<String, Object> workflowToMap(Workflow workflow) {\n\t\tMap<String, Object> data = new HashMap<>();\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tobjectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\t\tList<Map<String, Object>> workflowVars = objectMapper.convertValue(workflow.getWorkflowVars(), List.class);\n\t\tList<Map<String, Object>> envVars = objectMapper.convertValue(workflow.getEnvVars(), List.class);\n\t\tGraph graph = workflow.getGraph();\n\t\tMap<String, Object> graphMap = deconstructGraph(graph);\n\t\tdata.put(\"workflow\",\n\t\t\t\tMap.of(\"conversation_variables\", workflowVars, \"environment_variables\", envVars, \"graph\", graphMap));\n\t\treturn data;\n\t}\n\n\tprivate Map<String, Object> deconstructGraph(Graph graph) {\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tobjectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\t\t// deconstruct edge\n\t\tList<Map<String, Object>> edgeMaps = deconstructEdge(graph.getEdges());\n\t\t// deconstruct node\n\t\tList<Map<String, Object>> nodeMaps = deconstructNode(graph.getNodes());\n\t\treturn Map.of(\"edges\", edgeMaps, \"nodes\", nodeMaps);\n\t}\n\n\tprivate List<Map<String, Object>> deconstructEdge(List<Edge> edges) {\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tobjectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\t\treturn edges.stream().map(edge -> {\n\t\t\tMap<String, Object> edgeMap = objectMapper.convertValue(edge, new TypeReference<>() {\n\t\t\t});\n\t\t\tedgeMap.put(\"type\", \"custom\");\n\t\t\treturn edgeMap;\n\t\t}).toList();\n\n\t}\n\n\tprivate List<Map<String, Object>> deconstructNode(List<Node> nodes) {\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tList<Map<String, Object>> nodeMaps = new ArrayList<>();\n\t\tobjectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\t\tfor (Node node : nodes) {\n\t\t\tMap<String, Object> n = objectMapper.convertValue(node, new TypeReference<>() {\n\t\t\t});\n\t\t\tNodeType nodeType = NodeType.fromValue(node.getType())\n\t\t\t\t.orElseThrow(() -> new NotImplementedException(\"Unsupported NodeType: \" + node.getType()));\n\t\t\tNodeDataConverter<? extends NodeData> nodeDataConverter = getNodeDataConverter(nodeType);\n\t\t\tMap<String, Object> nodeData = dumpMapData(nodeDataConverter, node.getData());\n\t\t\tnodeData.put(\"type\", nodeType.difyValue());\n\t\t\tnodeData.put(\"title\", node.getTitle());\n\t\t\tnodeData.put(\"desc\", node.getDesc());\n\t\t\tn.put(\"data\", nodeData);\n\t\t\tn.put(\"type\", \"custom\");\n\t\t\tnodeMaps.add(n);\n\t\t}\n\t\treturn nodeMaps;\n\t}\n\n\tprivate <T extends NodeData> Map<String, Object> dumpMapData(NodeDataConverter<T> converter, NodeData data) {\n\t\treturn converter.dumpMapData((T) data, DSLDialectType.DIFY);\n\t}\n\n\t@Override\n\tpublic ChatBot mapToChatBot(Map<String, Object> data) {\n\t\t// TODO\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Map<String, Object> chatbotToMap(ChatBot chatBot) {\n\t\t// TODO\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Boolean supportDialect(DSLDialectType dialectType) {\n\t\treturn DSLDialectType.DIFY.equals(dialectType);\n\t}\n\n}", "output": "/*\n * Copyright 2024-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.service.dsl.adapters;\n\nimport com.alibaba.cloud.ai.model.App;\nimport com.alibaba.cloud.ai.model.AppMetadata;\nimport com.alibaba.cloud.ai.model.Variable;\nimport com.alibaba.cloud.ai.model.chatbot.ChatBot;\nimport com.alibaba.cloud.ai.model.workflow.Edge;\nimport com.alibaba.cloud.ai.model.workflow.Graph;\nimport com.alibaba.cloud.ai.model.workflow.Node;\nimport com.alibaba.cloud.ai.model.workflow.NodeData;\nimport com.alibaba.cloud.ai.model.workflow.NodeType;\nimport com.alibaba.cloud.ai.model.workflow.Workflow;\nimport com.alibaba.cloud.ai.model.workflow.nodedata.CodeNodeData;\nimport com.alibaba.cloud.ai.model.workflow.nodedata.EmptyNodeData;\nimport com.alibaba.cloud.ai.model.workflow.nodedata.IterationNodeData;\nimport com.alibaba.cloud.ai.model.workflow.nodedata.VariableAggregatorNodeData;\nimport com.alibaba.cloud.ai.service.dsl.DSLDialectType;\nimport com.alibaba.cloud.ai.service.dsl.Serializer;\nimport com.alibaba.cloud.ai.service.dsl.NodeDataConverter;\nimport com.alibaba.cloud.ai.service.dsl.AbstractDSLAdapter;\nimport com.alibaba.cloud.ai.model.VariableSelector;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.PropertyNamingStrategies;\nimport org.apache.commons.lang3.NotImplementedException;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Component;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * DifyDSLAdapter converts Dify DSL to {@link App} and vice versa.\n */\n@Component\npublic class DifyDSLAdapter extends AbstractDSLAdapter {\n\n\tprivate static final String[] DIFY_CHATBOT_MODES = { \"chat\", \"completion\", \"agent-chat\" };\n\n\tprivate static final String[] DIFY_WORKFLOW_MODES = { \"workflow\", \"advanced-chat\" };\n\n\tprivate final List<NodeDataConverter<? extends NodeData>> nodeDataConverters;\n\n\tprivate final Serializer serializer;\n\n\tpublic DifyDSLAdapter(List<NodeDataConverter<? extends NodeData>> nodeDataConverters,\n\t\t\t@Qualifier(\"yaml\") Serializer serializer) {\n\t\tthis.nodeDataConverters = nodeDataConverters;\n\t\tthis.serializer = serializer;\n\t}\n\n\tprivate NodeDataConverter<? extends NodeData> getNodeDataConverter(NodeType nodeType) {\n\t\treturn nodeDataConverters.stream()\n\t\t\t.filter(converter -> converter.supportNodeType(nodeType))\n\t\t\t.findFirst()\n\t\t\t.orElseThrow(() -> new IllegalArgumentException(\"invalid dify node type \" + nodeType));\n\t}\n\n\t@Override\n\tpublic void validateDSLData(Map<String, Object> dslData) {\n\t\tif (dslData == null || !dslData.containsKey(\"app\")) {\n\t\t\tthrow new IllegalArgumentException(\"invalid dify dsl\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic Serializer getSerializer() {\n\t\treturn serializer;\n\t}\n\n\t@Override\n\tpublic AppMetadata mapToMetadata(Map<String, Object> data) {\n\t\tMap<String, Object> map = (Map<String, Object>) data.get(\"app\");\n\t\tAppMetadata metadata = new AppMetadata();\n\t\tif (Arrays.asList(DIFY_CHATBOT_MODES).contains((String) map.get(\"mode\"))) {\n\t\t\tmetadata.setMode(AppMetadata.CHATBOT_MODE);\n\t\t}\n\t\telse if (Arrays.asList(DIFY_WORKFLOW_MODES).contains((String) map.get(\"mode\"))) {\n\t\t\tmetadata.setMode(AppMetadata.WORKFLOW_MODE);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"unknown dify app mode\" + map.get(\"mode\"));\n\t\t}\n\t\tmetadata.setId(UUID.randomUUID().toString());\n\t\tmetadata.setName((String) map.getOrDefault(\"name\", metadata.getMode() + \"-\" + metadata.getId()));\n\t\tmetadata.setDescription((String) map.getOrDefault(\"description\", \"\"));\n\t\treturn metadata;\n\t}\n\n\t@Override\n\tpublic Map<String, Object> metadataToMap(AppMetadata metadata) {\n\t\tMap<String, Object> data = new HashMap<>();\n\t\tString difyMode = metadata.getMode().equals(AppMetadata.WORKFLOW_MODE) ? \"workflow\" : \"agent-chat\";\n\t\tdata.put(\"app\", Map.of(\"name\", metadata.getName(), \"description\", metadata.getDescription(), \"mode\", difyMode));\n\t\tdata.put(\"kind\", \"app\");\n\t\treturn data;\n\t}\n\n\t@Override\n\tpublic Workflow mapToWorkflow(Map<String, Object> data) {\n\t\tMap<String, Object> workflowData = (Map<String, Object>) data.get(\"workflow\");\n\t\tWorkflow workflow = new Workflow();\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tobjectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\t\t// map key is snake_case style\n\t\tobjectMapper.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);\n\t\tList<Variable> convVars = new ArrayList<>();\n\t\tif (workflowData.containsKey(\"conversation_variables\")) {\n\t\t\tList<Map<String, Object>> variables = (List<Map<String, Object>>) workflowData\n\t\t\t\t.get(\"conversation_variables\");\n\t\t\tconvVars = variables.stream().map(variable -> convertToVariable(variable, objectMapper)).toList();\n\t\t}\n\n\t\tif (workflowData.containsKey(\"environment_variables\")) {\n\t\t\tList<Map<String, Object>> variables = (List<Map<String, Object>>) workflowData.get(\"environment_variables\");\n\t\t\tList<Variable> envVars = variables.stream()\n\t\t\t\t.map(variable -> convertToVariable(variable, objectMapper))\n\t\t\t\t.collect(Collectors.toList());\n\t\t\tworkflow.setEnvVars(envVars);\n\t\t}\n\n\t\tGraph graph = constructGraph((Map<String, Object>) workflowData.get(\"graph\"));\n\n\t\t// del codeNode\n\t\tMap<String, String> idToVarName = graph.getNodes()\n\t\t\t.stream()\n\t\t\t.collect(Collectors.toMap(Node::getId, n -> n.getData().getVarName()));\n\n\t\tfor (Node node : graph.getNodes()) {\n\t\t\tif (NodeType.CODE.value().equals(node.getType())) {\n\t\t\t\tCodeNodeData cd = (CodeNodeData) node.getData();\n\t\t\t\tfor (VariableSelector sel : cd.getInputs()) {\n\t\t\t\t\tString upstreamId = sel.getNamespace();\n\t\t\t\t\tString upstreamVar = idToVarName.get(upstreamId);\n\t\t\t\t\t// 可能来自一个节点的多个变量\n\t\t\t\t\tsel.setName(upstreamVar + \".\" + sel.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tworkflow.setGraph(graph);\n\t\t// register overAllState output key\n\t\tList<Variable> extraVars = graph.getNodes().stream().flatMap(node -> {\n\t\t\tNodeType type = NodeType.fromValue(node.getType())\n\t\t\t\t.orElseThrow(() -> new IllegalArgumentException(\"Unsupported NodeType: \" + node.getType()));\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tNodeDataConverter<NodeData> conv = (NodeDataConverter<NodeData>) getNodeDataConverter(type);\n\t\t\treturn conv.extractWorkflowVars(node.getData());\n\t\t}).toList();\n\n\t\tList<Variable> allVars = new ArrayList<>(Stream.concat(convVars.stream(), extraVars.stream())\n\t\t\t.collect(Collectors.toMap(Variable::getName, v -> v, (v1, v2) -> v1))\n\t\t\t.values());\n\n\t\tworkflow.setWorkflowVars(allVars);\n\n\t\treturn workflow;\n\t}\n\n\tprivate Graph constructGraph(Map<String, Object> data) {\n\t\tGraph graph = new Graph();\n\t\tList<Node> nodes = new ArrayList<>();\n\t\tList<Edge> edges = new ArrayList<>();\n\t\t// convert nodes\n\t\tif (data.containsKey(\"nodes\")) {\n\t\t\tList<Map<String, Object>> nodeMaps = (List<Map<String, Object>>) data.get(\"nodes\");\n\t\t\tnodes = constructNodes(nodeMaps);\n\t\t}\n\t\t// convert edges\n\t\tif (data.containsKey(\"edges\")) {\n\t\t\tList<Map<String, Object>> edgeMaps = (List<Map<String, Object>>) data.get(\"edges\");\n\t\t\tedges = constructEdges(edgeMaps);\n\t\t}\n\n\t\tgraph.setNodes(nodes);\n\t\tgraph.setEdges(edges);\n\t\treturn graph;\n\t}\n\n\tprivate List<Node> constructNodes(List<Map<String, Object>> nodeMaps) {\n\t\tObjectMapper objectMapper = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,\n\t\t\t\tfalse);\n\n\t\tMap<NodeType, Integer> counters = new HashMap<>();\n\t\tList<Node> nodes = new ArrayList<>();\n\n\t\tfor (Map<String, Object> nodeMap : nodeMaps) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tMap<String, Object> nodeDataMap = (Map<String, Object>) nodeMap.get(\"data\");\n\t\t\tString difyNodeType = (String) nodeDataMap.get(\"type\");\n\t\t\tif (difyNodeType == null || difyNodeType.isBlank()) {\n\t\t\t\t// This node is just a \"note\", skip it, and the corresponding node will\n\t\t\t\t// not be generated [compatible dify]\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString nodeId = (String) nodeMap.get(\"id\");\n\t\t\tnodeDataMap.put(\"id\", nodeId);\n\t\t\t// determine the type of dify node is supported yet\n\t\t\tNodeType nodeType = NodeType.fromDifyValue(difyNodeType)\n\t\t\t\t.orElseThrow(() -> new NotImplementedException(\"unsupported node type \" + difyNodeType));\n\n\t\t\t// convert node map to workflow node using jackson\n\t\t\tnodeMap.remove(\"data\");\n\t\t\tNode node = objectMapper.convertValue(nodeMap, Node.class);\n\t\t\t// set title and desc\n\t\t\tnode.setTitle((String) nodeDataMap.get(\"title\")).setDesc((String) nodeDataMap.get(\"desc\"));\n\n\t\t\t// convert node data using specific WorkflowNodeDataConverter\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tNodeDataConverter<NodeData> converter = (NodeDataConverter<NodeData>) getNodeDataConverter(nodeType);\n\n\t\t\tNodeData data = converter.parseMapData(nodeDataMap, DSLDialectType.DIFY);\n\n\t\t\t// Generate a readable varName and inject it into NodeData\n\t\t\tint count = counters.merge(nodeType, 1, Integer::sum);\n\t\t\tString varName = converter.generateVarName(count);\n\n\t\t\tdata.setVarName(varName);\n\n\t\t\t// Post-processing: Overwrite the default outputKey and refresh the outputs\n\t\t\tconverter.postProcess(data, varName);\n\n\t\t\tnode.setData(data);\n\t\t\tnode.setType(nodeType.value());\n\t\t\tnodes.add(node);\n\t\t}\n\n\t\t// 等待所有的节点都生成了变量名后，补充迭代节点的起始名称\n\t\tMap<String, String> varNames = nodes.stream()\n\t\t\t.collect(Collectors.toMap(Node::getId, n -> n.getData().getVarName()));\n\t\tfor (Node node : nodes) {\n\t\t\tif (node.getData() instanceof IterationNodeData iterationNodeData) {\n\t\t\t\titerationNodeData\n\t\t\t\t\t.setStartNodeName(varNames.getOrDefault(iterationNodeData.getStartNodeId(), \"unknown\"));\n\t\t\t\titerationNodeData.setEndNodeName(varNames.getOrDefault(iterationNodeData.getEndNodeId(), \"unknown\"));\n\t\t\t}\n\t\t}\n\n\t\tMap<String, String> idToOutputKey = nodes.stream()\n\t\t\t.filter(n -> !(n.getData() instanceof EmptyNodeData))\n\t\t\t.collect(Collectors.toMap(Node::getId, n -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn ((VariableAggregatorNodeData) n.getData()).getOutputKey();\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\treturn n.getData().getOutputs().get(0).getName();\n\t\t\t\t}\n\t\t\t}));\n\n\t\t// Replace all variable paths in all aggregation nodes.\n\t\tfor (Node node : nodes) {\n\t\t\tif (node.getData() instanceof VariableAggregatorNodeData agg) {\n\t\t\t\tList<List<String>> newVars = agg.getVariables().stream().map(path -> {\n\t\t\t\t\tString srcId = path.get(0);\n\t\t\t\t\tString tail = path.get(1);\n\t\t\t\t\tString mapped = idToOutputKey.getOrDefault(srcId, srcId);\n\t\t\t\t\treturn List.of(mapped, tail);\n\t\t\t\t}).toList();\n\t\t\t\tagg.setVariables(newVars);\n\n\t\t\t\tvar adv = agg.getAdvancedSettings();\n\t\t\t\tif (adv != null && adv.getGroups() != null) {\n\t\t\t\t\tfor (var group : adv.getGroups()) {\n\t\t\t\t\t\tList<List<String>> newGroupVars = group.getVariables().stream().map(path -> {\n\t\t\t\t\t\t\tString srcId = path.get(0);\n\t\t\t\t\t\t\tString tail = path.get(1);\n\t\t\t\t\t\t\tString mapped = idToOutputKey.getOrDefault(srcId, srcId);\n\t\t\t\t\t\t\treturn List.of(mapped, tail);\n\t\t\t\t\t\t}).toList();\n\t\t\t\t\t\tgroup.setVariables(newGroupVars);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn nodes;\n\t}\n\n\tprivate List<Edge> constructEdges(List<Map<String, Object>> edgeMaps) {\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tobjectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\t\treturn edgeMaps.stream().map(edgeMap -> objectMapper.convertValue(edgeMap, Edge.class)).toList();\n\t}\n\n\t@Override\n\tpublic Map<String, Object> workflowToMap(Workflow workflow) {\n\t\tMap<String, Object> data = new HashMap<>();\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tobjectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\t\tList<Map<String, Object>> workflowVars = objectMapper.convertValue(workflow.getWorkflowVars(), List.class);\n\t\tList<Map<String, Object>> envVars = objectMapper.convertValue(workflow.getEnvVars(), List.class);\n\t\tGraph graph = workflow.getGraph();\n\t\tMap<String, Object> graphMap = deconstructGraph(graph);\n\t\tdata.put(\"workflow\",\n\t\t\t\tMap.of(\"conversation_variables\", workflowVars, \"environment_variables\", envVars, \"graph\", graphMap));\n\t\treturn data;\n\t}\n\n\tprivate Map<String, Object> deconstructGraph(Graph graph) {\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tobjectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\t\t// deconstruct edge\n\t\tList<Map<String, Object>> edgeMaps = deconstructEdge(graph.getEdges());\n\t\t// deconstruct node\n\t\tList<Map<String, Object>> nodeMaps = deconstructNode(graph.getNodes());\n\t\treturn Map.of(\"edges\", edgeMaps, \"nodes\", nodeMaps);\n\t}\n\n\tprivate List<Map<String, Object>> deconstructEdge(List<Edge> edges) {\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tobjectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\t\treturn edges.stream().map(edge -> {\n\t\t\tMap<String, Object> edgeMap = objectMapper.convertValue(edge, new TypeReference<>() {\n\t\t\t});\n\t\t\tedgeMap.put(\"type\", \"custom\");\n\t\t\treturn edgeMap;\n\t\t}).toList();\n\n\t}\n\n\tprivate List<Map<String, Object>> deconstructNode(List<Node> nodes) {\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tList<Map<String, Object>> nodeMaps = new ArrayList<>();\n\t\tobjectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\t\tfor (Node node : nodes) {\n\t\t\tMap<String, Object> n = objectMapper.convertValue(node, new TypeReference<>() {\n\t\t\t});\n\t\t\tNodeType nodeType = NodeType.fromValue(node.getType())\n\t\t\t\t.orElseThrow(() -> new NotImplementedException(\"Unsupported NodeType: \" + node.getType()));\n\t\t\tNodeDataConverter<? extends NodeData> nodeDataConverter = getNodeDataConverter(nodeType);\n\t\t\tMap<String, Object> nodeData = dumpMapData(nodeDataConverter, node.getData());\n\t\t\tnodeData.put(\"type\", nodeType.difyValue());\n\t\t\tnodeData.put(\"title\", node.getTitle());\n\t\t\tnodeData.put(\"desc\", node.getDesc());\n\t\t\tn.put(\"data\", nodeData);\n\t\t\tn.put(\"type\", \"custom\");\n\t\t\tnodeMaps.add(n);\n\t\t}\n\t\treturn nodeMaps;\n\t}\n\n\tprivate <T extends NodeData> Map<String, Object> dumpMapData(NodeDataConverter<T> converter, NodeData data) {\n\t\treturn converter.dumpMapData((T) data, DSLDialectType.DIFY);\n\t}\n\n\t@Override\n\tpublic ChatBot mapToChatBot(Map<String, Object> data) {\n\t\t// TODO\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Map<String, Object> chatbotToMap(ChatBot chatBot) {\n\t\t// TODO\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Boolean supportDialect(DSLDialectType dialectType) {\n\t\treturn DSLDialectType.DIFY.equals(dialectType);\n\t}\n\n\tprivate Variable convertToVariable(Map<String, Object> variableMap, ObjectMapper objectMapper) {\n\t\ttry {\n\t\t\tMap<String, Object> processedMap = new HashMap<>(variableMap);\n\n\t\t\tObject value = processedMap.get(\"value\");\n\t\t\tif (value != null && !(value instanceof String)) {\n\t\t\t\tprocessedMap.put(\"value\", objectMapper.writeValueAsString(value));\n\t\t\t}\n\n\t\t\treturn objectMapper.convertValue(processedMap, Variable.class);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new IllegalArgumentException(\"Failed to convert variable: \" + variableMap, e);\n\t\t}\n\t}\n\n}", "metadata": {"commit_sha": "6a27df47", "lines_added": 18, "lines_deleted": 2, "total_changes": 20, "chunks": 2}}
{"id": 157, "pattern_type": "import_statement", "file_path": "spring-ai-alibaba-jmanus/src/main/java/com/alibaba/cloud/ai/example/manus/dynamic/mcp/model/vo/McpTool.java", "file_extension": "java", "input": "/*\n * Copyright 2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.example.manus.dynamic.mcp.model.vo;\n\nimport com.alibaba.cloud.ai.example.manus.dynamic.mcp.service.McpStateHolderService;\nimport com.alibaba.cloud.ai.example.manus.tool.AbstractBaseTool;\nimport com.alibaba.cloud.ai.example.manus.tool.code.ToolExecuteResult;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.springframework.ai.tool.ToolCallback;\n\nimport java.util.Map;\n\npublic class McpTool extends AbstractBaseTool<Map<String, Object>> {\n\n\tprivate final ToolCallback toolCallback;\n\n\tprivate String serviceNameString;\n\n\tprivate McpStateHolderService mcpStateHolderService;\n\n\tpublic McpTool(ToolCallback toolCallback, String serviceNameString, String planId,\n\t\t\tMcpStateHolderService mcpStateHolderService) {\n\t\tthis.toolCallback = toolCallback;\n\t\tthis.serviceNameString = serviceNameString;\n\t\tthis.currentPlanId = planId;\n\t\tthis.mcpStateHolderService = mcpStateHolderService;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn toolCallback.getToolDefinition().name();\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn toolCallback.getToolDefinition().description();\n\t}\n\n\t@Override\n\tpublic String getParameters() {\n\t\treturn toolCallback.getToolDefinition().inputSchema();\n\t}\n\n\t@Override\n\tpublic Class<Map<String, Object>> getInputType() {\n\t\treturn (Class<Map<String, Object>>) (Class<?>) Map.class;\n\t}\n\n\t@Override\n\tpublic String getCurrentToolStateString() {\n\t\tMcpState mcpState = mcpStateHolderService.getMcpState(currentPlanId);\n\t\tif (mcpState != null) {\n\t\t\treturn mcpState.getState();\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t@Override\n\tpublic ToolExecuteResult run(Map<String, Object> inputMap) {\n\t\t// Convert Map to JSON string, as ToolCallback expects string input\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tString jsonInput;\n\t\ttry {\n\t\t\tjsonInput = objectMapper.writeValueAsString(inputMap);\n\t\t}\n\t\tcatch (JsonProcessingException e) {\n\t\t\treturn new ToolExecuteResult(\"Error: Failed to serialize input to JSON - \" + e.getMessage());\n\t\t}\n\n\t\tString result = toolCallback.call(jsonInput, null);\n\t\tif (result == null) {\n\t\t\tresult = \"\";\n\t\t}\n\t\t// Here we can store the result to McpStateHolderService\n\t\tMcpState mcpState = mcpStateHolderService.getMcpState(currentPlanId);\n\t\tif (mcpState == null) {\n\t\t\tmcpState = new McpState();\n\t\t\tmcpStateHolderService.setMcpState(currentPlanId, mcpState);\n\t\t}\n\t\tmcpState.setState(result);\n\n\t\treturn new ToolExecuteResult(result);\n\t}\n\n\t@Override\n\tpublic void cleanup(String planId) {\n\t\tmcpStateHolderService.removeMcpState(planId);\n\t}\n\n\t@Override\n\tpublic String getServiceGroup() {\n\t\treturn serviceNameString;\n\t}\n\n}", "output": "/*\n * Copyright 2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.example.manus.dynamic.mcp.model.vo;\n\nimport com.alibaba.cloud.ai.example.manus.dynamic.mcp.service.McpStateHolderService;\nimport com.alibaba.cloud.ai.example.manus.tool.AbstractBaseTool;\nimport com.alibaba.cloud.ai.example.manus.tool.code.ToolExecuteResult;\nimport com.alibaba.cloud.ai.example.manus.tool.innerStorage.ISmartContentSavingService;\nimport com.alibaba.cloud.ai.example.manus.tool.innerStorage.SmartContentSavingService;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.springframework.ai.tool.ToolCallback;\n\nimport java.util.Map;\n\npublic class McpTool extends AbstractBaseTool<Map<String, Object>> {\n\n\tprivate final ToolCallback toolCallback;\n\n\tprivate String serviceNameString;\n\n\tprivate McpStateHolderService mcpStateHolderService;\n\n\tprivate ISmartContentSavingService smartContentSavingService;\n\n\tpublic McpTool(ToolCallback toolCallback, String serviceNameString, String planId,\n\t\t\tMcpStateHolderService mcpStateHolderService, ISmartContentSavingService smartContentSavingService) {\n\t\tthis.toolCallback = toolCallback;\n\t\tthis.serviceNameString = serviceNameString;\n\t\tthis.currentPlanId = planId;\n\t\tthis.mcpStateHolderService = mcpStateHolderService;\n\t\tthis.smartContentSavingService = smartContentSavingService;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn toolCallback.getToolDefinition().name();\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn toolCallback.getToolDefinition().description();\n\t}\n\n\t@Override\n\tpublic String getParameters() {\n\t\treturn toolCallback.getToolDefinition().inputSchema();\n\t}\n\n\t@Override\n\tpublic Class<Map<String, Object>> getInputType() {\n\t\treturn (Class<Map<String, Object>>) (Class<?>) Map.class;\n\t}\n\n\t@Override\n\tpublic String getCurrentToolStateString() {\n\t\tMcpState mcpState = mcpStateHolderService.getMcpState(currentPlanId);\n\t\tif (mcpState != null) {\n\t\t\treturn mcpState.getState();\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t@Override\n\tpublic ToolExecuteResult run(Map<String, Object> inputMap) {\n\t\t// Convert Map to JSON string, as ToolCallback expects string input\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tString jsonInput;\n\t\ttry {\n\t\t\tjsonInput = objectMapper.writeValueAsString(inputMap);\n\t\t}\n\t\tcatch (JsonProcessingException e) {\n\t\t\treturn new ToolExecuteResult(\"Error: Failed to serialize input to JSON - \" + e.getMessage());\n\t\t}\n\n\t\tString result = toolCallback.call(jsonInput, null);\n\t\tif (result == null) {\n\t\t\tresult = \"\";\n\t\t}\n\n\t\tSmartContentSavingService.SmartProcessResult smartProcessResult = smartContentSavingService\n\t\t\t.processContent(currentPlanId, result, getName());\n\t\tresult = smartProcessResult.getSummary();\n\t\t// Here we can store the result to McpStateHolderService\n\t\tMcpState mcpState = mcpStateHolderService.getMcpState(currentPlanId);\n\t\tif (mcpState == null) {\n\t\t\tmcpState = new McpState();\n\t\t\tmcpStateHolderService.setMcpState(currentPlanId, mcpState);\n\t\t}\n\t\tmcpState.setState(result);\n\n\t\treturn new ToolExecuteResult(result);\n\t}\n\n\t@Override\n\tpublic void cleanup(String planId) {\n\t\tmcpStateHolderService.removeMcpState(planId);\n\t}\n\n\t@Override\n\tpublic String getServiceGroup() {\n\t\treturn serviceNameString;\n\t}\n\n}", "metadata": {"commit_sha": "1b147756", "lines_added": 10, "lines_deleted": 1, "total_changes": 11, "chunks": 2}}
{"id": 54, "pattern_type": "refactoring", "file_path": "community/openmanus/src/main/java/com/alibaba/cloud/ai/example/manus/config/ManusChromeDriverInit.java", "file_extension": "java", "input": "/*\n * Copyright 2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alibaba.cloud.ai.example.manus.config;\n\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Paths;\n\nimport com.alibaba.cloud.ai.example.manus.OpenManusSpringBootApplication;\n\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author yuluo\n * @author <a href=\"mailto:yuluo08290126@gmail.com\">yuluo</a>\n */\n\n@Component\npublic class ManusChromeDriverInit implements ApplicationRunner {\n\n\t@Override\n\tpublic void run(ApplicationArguments args) throws Exception {\n\n\t\tString chromedriverPath;\n\n\t\tif (checkOS()) {\n\t\t\tchromedriverPath = getChromedriverPath(\"data/chromedriver.exe\");\n\t\t} else {\n\t\t\tchromedriverPath = getChromedriverPath(\"data/chromedriver\");\n\t\t}\n\n\t\tsetChromeDriver(chromedriverPath);\n\t}\n\n\tprivate String getChromedriverPath(String resourcePath) throws URISyntaxException {\n\n\t\tURL resource = OpenManusSpringBootApplication.class.getClassLoader().getResource(resourcePath);\n\t\tif (resource == null) {\n\t\t\tthrow new IllegalStateException(\"Chromedriver not found: \" + resourcePath);\n\t\t}\n\n\t\treturn Paths.get(resource.toURI()).toFile().getAbsolutePath();\n\t}\n\n\tprivate static Boolean checkOS() {\n\n\t\tString os = System.getProperty(\"os.name\").toLowerCase();\n\n\t\tif (os.contains(\"win\")) {\n\t\t\treturn true;\n\t\t} else if (os.contains(\"mac\")) {\n\t\t\treturn false;\n\t\t} else if (os.contains(\"nix\") || os.contains(\"nux\") || os.contains(\"aix\")) {\n\t\t\tSystem.out.println(\"Operating System: Unix/Linux\");\n\t\t\treturn false;\n\t\t} else {\n\t\t\tSystem.out.println(\"Operating System: Unknown\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static void setChromeDriver(String path) {\n\n\t\tSystem.setProperty(\"webdriver.chrome.driver\", path);\n\t}\n\n}", "output": "/*\n * Copyright 2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alibaba.cloud.ai.example.manus.config;\n\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Paths;\n\nimport com.alibaba.cloud.ai.example.manus.OpenManusSpringBootApplication;\n\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author yuluo\n * @author <a href=\"mailto:yuluo08290126@gmail.com\">yuluo</a>\n */\n\n@Component\npublic class ManusChromeDriverInit implements ApplicationRunner {\n\n\t@Override\n\tpublic void run(ApplicationArguments args) throws Exception {\n\n\t\tString chromedriverPath;\n\n\t\tif (checkOS()) {\n\t\t\tchromedriverPath = getChromedriverPath(\"data/chromedriver.exe\");\n\t\t}\n\t\telse {\n\t\t\tchromedriverPath = getChromedriverPath(\"data/chromedriver\");\n\t\t}\n\n\t\tsetChromeDriver(chromedriverPath);\n\t}\n\n\tprivate String getChromedriverPath(String resourcePath) throws URISyntaxException {\n\n\t\tURL resource = OpenManusSpringBootApplication.class.getClassLoader().getResource(resourcePath);\n\t\tif (resource == null) {\n\t\t\tthrow new IllegalStateException(\"Chromedriver not found: \" + resourcePath);\n\t\t}\n\n\t\treturn Paths.get(resource.toURI()).toFile().getAbsolutePath();\n\t}\n\n\tprivate static Boolean checkOS() {\n\n\t\tString os = System.getProperty(\"os.name\").toLowerCase();\n\n\t\tif (os.contains(\"win\")) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (os.contains(\"mac\")) {\n\t\t\treturn false;\n\t\t}\n\t\telse if (os.contains(\"nix\") || os.contains(\"nux\") || os.contains(\"aix\")) {\n\t\t\tSystem.out.println(\"Operating System: Unix/Linux\");\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"Operating System: Unknown\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static void setChromeDriver(String path) {\n\n\t\tSystem.setProperty(\"webdriver.chrome.driver\", path);\n\t}\n\n}", "metadata": {"commit_sha": "694831b0", "lines_added": 8, "lines_deleted": 4, "total_changes": 12, "chunks": 2}}
{"id": 82, "pattern_type": "import_statement", "file_path": "spring-ai-alibaba-graph/spring-ai-alibaba-graph-core/src/main/java/com/alibaba/cloud/ai/graph/OverAllState.java", "file_extension": "java", "input": "/*\n * Copyright 2024-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.graph;\n\nimport org.springframework.util.CollectionUtils;\n\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport static java.util.Collections.unmodifiableMap;\nimport static java.util.Optional.ofNullable;\n\npublic final class OverAllState implements Serializable {\n\n\tprivate final Map<String, Object> data;\n\n\tprivate final Map<String, KeyStrategy> keyStrategies;\n\n\tprivate Boolean resume;\n\n\tprivate HumanFeedback humanFeedback;\n\n\tprivate String interruptMessage;\n\n\t/**\n\t * The constant DEFAULT_INPUT_KEY.\n\t */\n\tpublic static final String DEFAULT_INPUT_KEY = \"input\";\n\n\tpublic void reset() {\n\t\tthis.data.clear();\n\t}\n\n\tpublic Optional<OverAllState> snapShot() {\n\t\treturn Optional.of(new OverAllState(new HashMap<>(this.data), new HashMap<>(this.keyStrategies), this.resume));\n\t}\n\n\t/**\n\t * Instantiates a new Over all state.\n\t * @param resume the is resume\n\t */\n\tpublic OverAllState(boolean resume) {\n\t\tthis.data = new HashMap<>();\n\t\tthis.keyStrategies = new HashMap<>();\n\t\tthis.resume = resume;\n\t}\n\n\t/**\n\t * Instantiates a new Over all state.\n\t * @param data the data\n\t */\n\tpublic OverAllState(Map<String, Object> data) {\n\t\tthis.data = new HashMap<>(data);\n\t\tthis.keyStrategies = new HashMap<>();\n\t\tthis.resume = false;\n\t}\n\n\t/**\n\t * Instantiates a new Over all state.\n\t */\n\tpublic OverAllState() {\n\t\tthis.data = new HashMap<>();\n\t\tthis.keyStrategies = new HashMap<>();\n\t\tthis.registerKeyAndStrategy(OverAllState.DEFAULT_INPUT_KEY, (o, o2) -> o2);\n\t\tthis.resume = false;\n\t}\n\n\tprivate OverAllState(Map<String, Object> data, Map<String, KeyStrategy> keyStrategies, Boolean resume) {\n\t\tthis.data = data;\n\t\tthis.keyStrategies = keyStrategies;\n\t\tthis.registerKeyAndStrategy(OverAllState.DEFAULT_INPUT_KEY, (o, o2) -> o2);\n\t\tthis.resume = resume;\n\t}\n\n\tpublic String interruptMessage() {\n\t\treturn interruptMessage;\n\t}\n\n\tpublic void setInterruptMessage(String interruptMessage) {\n\t\tthis.interruptMessage = interruptMessage;\n\t}\n\n\tpublic void withHumanFeedback(HumanFeedback humanFeedback) {\n\t\tthis.humanFeedback = humanFeedback;\n\t}\n\n\tpublic HumanFeedback humanFeedback() {\n\t\treturn this.humanFeedback;\n\t}\n\n\t/**\n\t * Copy with resume over all state.\n\t * @return the over all state\n\t */\n\tpublic OverAllState copyWithResume() {\n\t\treturn new OverAllState(this.data, this.keyStrategies, true);\n\t}\n\n\tpublic void withResume() {\n\t\tthis.resume = true;\n\t}\n\n\tpublic void withoutResume() {\n\t\tthis.resume = false;\n\t}\n\n\t/**\n\t * Is resume boolean.\n\t * @return the boolean\n\t */\n\tpublic boolean isResume() {\n\t\treturn this.resume;\n\t}\n\n\t/**\n\t * Inputs over all state.\n\t * @param input the input\n\t * @return the over all state\n\t */\n\tpublic OverAllState input(Map<String, Object> input) {\n\t\tif (CollectionUtils.isEmpty(input))\n\t\t\treturn this;\n\t\tthis.data.putAll(input);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add key and strategy over all state.\n\t * @param key the key\n\t * @param strategy the strategy\n\t * @return the over all state\n\t */\n\tpublic OverAllState registerKeyAndStrategy(String key, KeyStrategy strategy) {\n\t\tthis.keyStrategies.put(key, strategy);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Is contain strategy boolean.\n\t * @param key the key\n\t * @return the boolean\n\t */\n\tpublic boolean containStrategy(String key) {\n\t\treturn this.keyStrategies.containsKey(key);\n\t}\n\n\t/**\n\t * Update state map.\n\t * @param partialState the partial state\n\t * @return the map\n\t */\n\tpublic Map<String, Object> updateState(Map<String, Object> partialState) {\n\t\tMap<String, KeyStrategy> keyStrategies = keyStrategies();\n\t\tpartialState.keySet().stream().filter(key -> keyStrategies.containsKey(key)).forEach(key -> {\n\t\t\tthis.data.put(key, keyStrategies.get(key).apply(value(key, null), partialState.get(key)));\n\t\t});\n\t\treturn data();\n\t}\n\n\t/**\n\t * Key verify boolean.\n\t * @return the boolean\n\t */\n\tprotected boolean keyVerify() {\n\t\treturn hasCommonKey(this.data, getKeyStrategies());\n\t}\n\n\tprivate Map<?, ?> getKeyStrategies() {\n\t\treturn this.keyStrategies;\n\t}\n\n\tprivate boolean hasCommonKey(Map<?, ?> map1, Map<?, ?> map2) {\n\t\tSet<?> keys1 = map1.keySet();\n\t\tfor (Object key : map2.keySet()) {\n\t\t\tif (keys1.contains(key)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Updates a state with the provided partial state. The merge function is used to\n\t * merge the current state value with the new value.\n\t * @param state the current state\n\t * @param partialState the partial state to update from\n\t * @return the updated state\n\t * @throws NullPointerException if state is null\n\t */\n\tpublic static Map<String, Object> updateState(Map<String, Object> state, Map<String, Object> partialState) {\n\t\tObjects.requireNonNull(state, \"state cannot be null\");\n\t\tif (partialState == null || partialState.isEmpty()) {\n\t\t\treturn state;\n\t\t}\n\n\t\treturn Stream.concat(state.entrySet().stream(), partialState.entrySet().stream())\n\t\t\t.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, OverAllState::mergeFunction));\n\t}\n\n\tpublic static Map<String, Object> updateState(Map<String, Object> state, Map<String, Object> partialState,\n\t\t\tMap<String, KeyStrategy> keyStrategies) {\n\t\tObjects.requireNonNull(state, \"state cannot be null\");\n\t\tif (partialState == null || partialState.isEmpty()) {\n\t\t\treturn state;\n\t\t}\n\n\t\treturn Stream.concat(state.entrySet().stream(), partialState.entrySet().stream())\n\t\t\t.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -> {\n\t\t\t\tString key = (Stream.of(state.entrySet(), partialState.entrySet())\n\t\t\t\t\t.flatMap(Set::stream)\n\t\t\t\t\t.filter(entry -> entry.getValue() == oldValue || entry.getValue() == newValue)\n\t\t\t\t\t.findFirst()\n\t\t\t\t\t.orElseThrow()).getKey();\n\t\t\t\tKeyStrategy strategy = keyStrategies.getOrDefault(key, OverAllState::mergeFunction);\n\t\t\t\treturn strategy.apply(oldValue, newValue);\n\t\t\t}));\n\t}\n\n\t/**\n\t * Merges the current value with the new value using the appropriate merge function.\n\t * @param currentValue the current value\n\t * @param newValue the new value\n\t * @return the merged value\n\t */\n\tprivate static Object mergeFunction(Object currentValue, Object newValue) {\n\t\treturn newValue;\n\t}\n\n\t/**\n\t * Key strategies map.\n\t * @return the map\n\t */\n\tpublic final Map<String, KeyStrategy> keyStrategies() {\n\t\treturn unmodifiableMap(keyStrategies);\n\t}\n\n\t/**\n\t * Data map.\n\t * @return the map\n\t */\n\tpublic final Map<String, Object> data() {\n\t\treturn unmodifiableMap(data);\n\t}\n\n\t/**\n\t * Value optional.\n\t * @param <T> the type parameter\n\t * @param key the key\n\t * @return the optional\n\t */\n\tpublic final <T> Optional<T> value(String key) {\n\t\treturn ofNullable((T) data().get(key));\n\t}\n\n\tpublic final <T> Optional<T> value(String key, Class<T> type) {\n\t\tif (type != null) {\n\t\t\treturn ofNullable(type.cast(data().get(key)));\n\t\t}\n\t\treturn value(key);\n\t}\n\n\t/**\n\t * Value t.\n\t * @param <T> the type parameter\n\t * @param key the key\n\t * @param defaultValue the default value\n\t * @return the t\n\t */\n\tpublic final <T> T value(String key, T defaultValue) {\n\t\treturn (T) value(key).orElse(defaultValue);\n\t}\n\n\tpublic static class HumanFeedback {\n\n\t\tprivate Map<String, Object> data;\n\n\t\tprivate String nextNodeId;\n\n\t\tprivate String currentNodeId;\n\n\t\tpublic HumanFeedback(Map<String, Object> data, String nextNodeId) {\n\t\t\tthis.data = data;\n\t\t\tthis.nextNodeId = nextNodeId;\n\t\t}\n\n\t\tpublic Map<String, Object> data() {\n\t\t\treturn data;\n\t\t}\n\n\t\tpublic String nextNodeId() {\n\t\t\treturn nextNodeId;\n\t\t}\n\n\t\tpublic void setData(Map<String, Object> data) {\n\t\t\tthis.data = data;\n\t\t}\n\n\t\tpublic void setNextNodeId(String nextNodeId) {\n\t\t\tthis.nextNodeId = nextNodeId;\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"OverAllState{\" + \"data=\" + data + \", keyStrategies=\" + keyStrategies + \", resume=\" + resume\n\t\t\t\t+ \", humanFeedback=\" + humanFeedback + \", interruptMessage='\" + interruptMessage + '\\'' + '}';\n\t}\n\n}", "output": "/*\n * Copyright 2024-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.graph;\n\nimport org.springframework.util.CollectionUtils;\n\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport com.alibaba.cloud.ai.graph.state.strategy.ReplaceStrategy;\n\nimport static java.util.Collections.unmodifiableMap;\nimport static java.util.Optional.ofNullable;\n\npublic final class OverAllState implements Serializable {\n\n\tprivate final Map<String, Object> data;\n\n\tprivate final Map<String, KeyStrategy> keyStrategies;\n\n\tprivate Boolean resume;\n\n\tprivate HumanFeedback humanFeedback;\n\n\tprivate String interruptMessage;\n\n\t/**\n\t * The constant DEFAULT_INPUT_KEY.\n\t */\n\tpublic static final String DEFAULT_INPUT_KEY = \"input\";\n\n\tpublic void reset() {\n\t\tthis.data.clear();\n\t}\n\n\tpublic Optional<OverAllState> snapShot() {\n\t\treturn Optional.of(new OverAllState(new HashMap<>(this.data), new HashMap<>(this.keyStrategies), this.resume));\n\t}\n\n\t/**\n\t * Instantiates a new Over all state.\n\t * @param resume the is resume\n\t */\n\tpublic OverAllState(boolean resume) {\n\t\tthis.data = new HashMap<>();\n\t\tthis.keyStrategies = new HashMap<>();\n\t\tthis.resume = resume;\n\t}\n\n\t/**\n\t * Instantiates a new Over all state.\n\t * @param data the data\n\t */\n\tpublic OverAllState(Map<String, Object> data) {\n\t\tthis.data = new HashMap<>(data);\n\t\tthis.keyStrategies = new HashMap<>();\n\t\tthis.resume = false;\n\t}\n\n\t/**\n\t * Instantiates a new Over all state.\n\t */\n\tpublic OverAllState() {\n\t\tthis.data = new HashMap<>();\n\t\tthis.keyStrategies = new HashMap<>();\n\t\tthis.registerKeyAndStrategy(OverAllState.DEFAULT_INPUT_KEY, new ReplaceStrategy());\n\t\tthis.resume = false;\n\t}\n\n\tprivate OverAllState(Map<String, Object> data, Map<String, KeyStrategy> keyStrategies, Boolean resume) {\n\t\tthis.data = data;\n\t\tthis.keyStrategies = keyStrategies;\n\t\tthis.registerKeyAndStrategy(OverAllState.DEFAULT_INPUT_KEY, new ReplaceStrategy());\n\t\tthis.resume = resume;\n\t}\n\n\tpublic String interruptMessage() {\n\t\treturn interruptMessage;\n\t}\n\n\tpublic void setInterruptMessage(String interruptMessage) {\n\t\tthis.interruptMessage = interruptMessage;\n\t}\n\n\tpublic void withHumanFeedback(HumanFeedback humanFeedback) {\n\t\tthis.humanFeedback = humanFeedback;\n\t}\n\n\tpublic HumanFeedback humanFeedback() {\n\t\treturn this.humanFeedback;\n\t}\n\n\t/**\n\t * Copy with resume over all state.\n\t * @return the over all state\n\t */\n\tpublic OverAllState copyWithResume() {\n\t\treturn new OverAllState(this.data, this.keyStrategies, true);\n\t}\n\n\tpublic void withResume() {\n\t\tthis.resume = true;\n\t}\n\n\tpublic void withoutResume() {\n\t\tthis.resume = false;\n\t}\n\n\t/**\n\t * Is resume boolean.\n\t * @return the boolean\n\t */\n\tpublic boolean isResume() {\n\t\treturn this.resume;\n\t}\n\n\t/**\n\t * Inputs over all state.\n\t * @param input the input\n\t * @return the over all state\n\t */\n\tpublic OverAllState input(Map<String, Object> input) {\n\t\tif (CollectionUtils.isEmpty(input))\n\t\t\treturn this;\n\t\tthis.data.putAll(input);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add key and strategy over all state.\n\t * @param key the key\n\t * @param strategy the strategy\n\t * @return the over all state\n\t */\n\tpublic OverAllState registerKeyAndStrategy(String key, KeyStrategy strategy) {\n\t\tthis.keyStrategies.put(key, strategy);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Is contain strategy boolean.\n\t * @param key the key\n\t * @return the boolean\n\t */\n\tpublic boolean containStrategy(String key) {\n\t\treturn this.keyStrategies.containsKey(key);\n\t}\n\n\t/**\n\t * Update state map.\n\t * @param partialState the partial state\n\t * @return the map\n\t */\n\tpublic Map<String, Object> updateState(Map<String, Object> partialState) {\n\t\tMap<String, KeyStrategy> keyStrategies = keyStrategies();\n\t\tpartialState.keySet().stream().filter(key -> keyStrategies.containsKey(key)).forEach(key -> {\n\t\t\tthis.data.put(key, keyStrategies.get(key).apply(value(key, null), partialState.get(key)));\n\t\t});\n\t\treturn data();\n\t}\n\n\t/**\n\t * Key verify boolean.\n\t * @return the boolean\n\t */\n\tprotected boolean keyVerify() {\n\t\treturn hasCommonKey(this.data, getKeyStrategies());\n\t}\n\n\tprivate Map<?, ?> getKeyStrategies() {\n\t\treturn this.keyStrategies;\n\t}\n\n\tprivate boolean hasCommonKey(Map<?, ?> map1, Map<?, ?> map2) {\n\t\tSet<?> keys1 = map1.keySet();\n\t\tfor (Object key : map2.keySet()) {\n\t\t\tif (keys1.contains(key)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Updates a state with the provided partial state. The merge function is used to\n\t * merge the current state value with the new value.\n\t * @param state the current state\n\t * @param partialState the partial state to update from\n\t * @return the updated state\n\t * @throws NullPointerException if state is null\n\t */\n\tpublic static Map<String, Object> updateState(Map<String, Object> state, Map<String, Object> partialState) {\n\t\tObjects.requireNonNull(state, \"state cannot be null\");\n\t\tif (partialState == null || partialState.isEmpty()) {\n\t\t\treturn state;\n\t\t}\n\n\t\treturn Stream.concat(state.entrySet().stream(), partialState.entrySet().stream())\n\t\t\t.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, OverAllState::mergeFunction));\n\t}\n\n\tpublic static Map<String, Object> updateState(Map<String, Object> state, Map<String, Object> partialState,\n\t\t\tMap<String, KeyStrategy> keyStrategies) {\n\t\tObjects.requireNonNull(state, \"state cannot be null\");\n\t\tif (partialState == null || partialState.isEmpty()) {\n\t\t\treturn state;\n\t\t}\n\n\t\treturn Stream.concat(state.entrySet().stream(), partialState.entrySet().stream())\n\t\t\t.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -> {\n\t\t\t\tString key = (Stream.of(state.entrySet(), partialState.entrySet())\n\t\t\t\t\t.flatMap(Set::stream)\n\t\t\t\t\t.filter(entry -> entry.getValue() == oldValue || entry.getValue() == newValue)\n\t\t\t\t\t.findFirst()\n\t\t\t\t\t.orElseThrow()).getKey();\n\t\t\t\tKeyStrategy strategy = keyStrategies.getOrDefault(key, OverAllState::mergeFunction);\n\t\t\t\treturn strategy.apply(oldValue, newValue);\n\t\t\t}));\n\t}\n\n\t/**\n\t * Merges the current value with the new value using the appropriate merge function.\n\t * @param currentValue the current value\n\t * @param newValue the new value\n\t * @return the merged value\n\t */\n\tprivate static Object mergeFunction(Object currentValue, Object newValue) {\n\t\treturn newValue;\n\t}\n\n\t/**\n\t * Key strategies map.\n\t * @return the map\n\t */\n\tpublic final Map<String, KeyStrategy> keyStrategies() {\n\t\treturn unmodifiableMap(keyStrategies);\n\t}\n\n\t/**\n\t * Data map.\n\t * @return the map\n\t */\n\tpublic final Map<String, Object> data() {\n\t\treturn unmodifiableMap(data);\n\t}\n\n\t/**\n\t * Value optional.\n\t * @param <T> the type parameter\n\t * @param key the key\n\t * @return the optional\n\t */\n\tpublic final <T> Optional<T> value(String key) {\n\t\treturn ofNullable((T) data().get(key));\n\t}\n\n\tpublic final <T> Optional<T> value(String key, Class<T> type) {\n\t\tif (type != null) {\n\t\t\treturn ofNullable(type.cast(data().get(key)));\n\t\t}\n\t\treturn value(key);\n\t}\n\n\t/**\n\t * Value t.\n\t * @param <T> the type parameter\n\t * @param key the key\n\t * @param defaultValue the default value\n\t * @return the t\n\t */\n\tpublic final <T> T value(String key, T defaultValue) {\n\t\treturn (T) value(key).orElse(defaultValue);\n\t}\n\n\tpublic static class HumanFeedback {\n\n\t\tprivate Map<String, Object> data;\n\n\t\tprivate String nextNodeId;\n\n\t\tprivate String currentNodeId;\n\n\t\tpublic HumanFeedback(Map<String, Object> data, String nextNodeId) {\n\t\t\tthis.data = data;\n\t\t\tthis.nextNodeId = nextNodeId;\n\t\t}\n\n\t\tpublic Map<String, Object> data() {\n\t\t\treturn data;\n\t\t}\n\n\t\tpublic String nextNodeId() {\n\t\t\treturn nextNodeId;\n\t\t}\n\n\t\tpublic void setData(Map<String, Object> data) {\n\t\t\tthis.data = data;\n\t\t}\n\n\t\tpublic void setNextNodeId(String nextNodeId) {\n\t\t\tthis.nextNodeId = nextNodeId;\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"OverAllState{\" + \"data=\" + data + \", keyStrategies=\" + keyStrategies + \", resume=\" + resume\n\t\t\t\t+ \", humanFeedback=\" + humanFeedback + \", interruptMessage='\" + interruptMessage + '\\'' + '}';\n\t}\n\n}", "metadata": {"commit_sha": "c6e634c6", "lines_added": 4, "lines_deleted": 2, "total_changes": 6, "chunks": 2}}
{"id": 154, "pattern_type": "function_signature_change", "file_path": "spring-ai-alibaba-graph/spring-ai-alibaba-graph-core/src/main/java/com/alibaba/cloud/ai/graph/CompiledGraph.java", "file_extension": "java", "input": "/*\n * Copyright 2024-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.graph;\n\nimport com.alibaba.cloud.ai.graph.action.AsyncCommandAction;\nimport com.alibaba.cloud.ai.graph.action.AsyncNodeAction;\nimport com.alibaba.cloud.ai.graph.action.AsyncNodeActionWithConfig;\nimport com.alibaba.cloud.ai.graph.action.Command;\nimport com.alibaba.cloud.ai.graph.async.AsyncGenerator;\nimport com.alibaba.cloud.ai.graph.checkpoint.BaseCheckpointSaver;\nimport com.alibaba.cloud.ai.graph.checkpoint.Checkpoint;\nimport com.alibaba.cloud.ai.graph.exception.Errors;\nimport com.alibaba.cloud.ai.graph.exception.GraphRunnerException;\nimport com.alibaba.cloud.ai.graph.exception.GraphStateException;\nimport com.alibaba.cloud.ai.graph.exception.RunnableErrors;\nimport com.alibaba.cloud.ai.graph.internal.edge.Edge;\nimport com.alibaba.cloud.ai.graph.internal.edge.EdgeValue;\nimport com.alibaba.cloud.ai.graph.internal.node.CommandNode;\nimport com.alibaba.cloud.ai.graph.internal.node.ParallelNode;\nimport com.alibaba.cloud.ai.graph.state.StateSnapshot;\nimport com.alibaba.cloud.ai.graph.streaming.AsyncGeneratorUtils;\nimport com.alibaba.cloud.ai.graph.utils.SystemClock;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.util.CollectionUtils;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionException;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport static com.alibaba.cloud.ai.graph.StateGraph.END;\nimport static com.alibaba.cloud.ai.graph.StateGraph.ERROR;\nimport static com.alibaba.cloud.ai.graph.StateGraph.NODE_AFTER;\nimport static com.alibaba.cloud.ai.graph.StateGraph.NODE_BEFORE;\nimport static com.alibaba.cloud.ai.graph.StateGraph.START;\nimport static java.lang.String.format;\nimport static java.util.concurrent.CompletableFuture.completedFuture;\nimport static java.util.stream.Collectors.toList;\n\n/**\n * The type Compiled graph.\n */\npublic class CompiledGraph {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(CompiledGraph.class);\n\n\t/**\n\t * The enum Stream mode.\n\t */\n\tpublic enum StreamMode {\n\n\t\t/**\n\t\t * Values stream mode.\n\t\t */\n\t\tVALUES,\n\t\t/**\n\t\t * Snapshots stream mode.\n\t\t */\n\t\tSNAPSHOTS\n\n\t}\n\n\t/**\n\t * The State graph.\n\t */\n\tpublic final StateGraph stateGraph;\n\n\tprivate final Map<String, KeyStrategy> keyStrategyMap;\n\n\t/**\n\t * The Nodes.\n\t */\n\tfinal Map<String, AsyncNodeActionWithConfig> nodes = new LinkedHashMap<>();\n\n\t/**\n\t * The Edges.\n\t */\n\tfinal Map<String, EdgeValue> edges = new LinkedHashMap<>();\n\n\tprivate final ProcessedNodesEdgesAndConfig processedData;\n\n\tprivate int maxIterations = 25;\n\n\t/**\n\t * The Compile config.\n\t */\n\tpublic final CompileConfig compileConfig;\n\n\t/**\n\t * Constructs a CompiledGraph with the given StateGraph.\n\t * @param stateGraph the StateGraph to be used in this CompiledGraph\n\t * @param compileConfig the compile config\n\t * @throws GraphStateException the graph state exception\n\t */\n\tprotected CompiledGraph(StateGraph stateGraph, CompileConfig compileConfig) throws GraphStateException {\n\t\tthis.stateGraph = stateGraph;\n\t\tthis.keyStrategyMap = Objects.isNull(stateGraph.getOverAllStateFactory())\n\t\t\t\t? stateGraph.getKeyStrategyFactory()\n\t\t\t\t\t.apply()\n\t\t\t\t\t.entrySet()\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(e -> Map.entry(e.getKey(), e.getValue()))\n\t\t\t\t\t.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))\n\t\t\t\t: stateGraph.getOverAllStateFactory().create().keyStrategies();\n\n\t\tthis.processedData = ProcessedNodesEdgesAndConfig.process(stateGraph, compileConfig);\n\n\t\t// CHECK INTERRUPTIONS\n\t\tfor (String interruption : processedData.interruptsBefore()) {\n\t\t\tif (!processedData.nodes().anyMatchById(interruption)) {\n\t\t\t\tthrow Errors.interruptionNodeNotExist.exception(interruption);\n\t\t\t}\n\t\t}\n\t\tfor (String interruption : processedData.interruptsBefore()) {\n\t\t\tif (!processedData.nodes().anyMatchById(interruption)) {\n\t\t\t\tthrow Errors.interruptionNodeNotExist.exception(interruption);\n\t\t\t}\n\t\t}\n\n\t\t// RE-CREATE THE EVENTUALLY UPDATED COMPILE CONFIG\n\t\tthis.compileConfig = CompileConfig.builder(compileConfig)\n\t\t\t.interruptsBefore(processedData.interruptsBefore())\n\t\t\t.interruptsAfter(processedData.interruptsAfter())\n\t\t\t.build();\n\n\t\t// EVALUATES NODES\n\t\tfor (var n : processedData.nodes().elements) {\n\t\t\tvar factory = n.actionFactory();\n\t\t\tObjects.requireNonNull(factory, format(\"action factory for node id '%s' is null!\", n.id()));\n\t\t\tnodes.put(n.id(), factory.apply(compileConfig));\n\t\t}\n\n\t\t// EVALUATE EDGES\n\t\tfor (var e : processedData.edges().elements) {\n\t\t\tvar targets = e.targets();\n\t\t\tif (targets.size() == 1) {\n\t\t\t\tedges.put(e.sourceId(), targets.get(0));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSupplier<Stream<EdgeValue>> parallelNodeStream = () -> targets.stream()\n\t\t\t\t\t.filter(target -> nodes.containsKey(target.id()));\n\n\t\t\t\tvar parallelNodeEdges = parallelNodeStream.get()\n\t\t\t\t\t.map(target -> new Edge(target.id()))\n\t\t\t\t\t.filter(ee -> processedData.edges().elements.contains(ee))\n\t\t\t\t\t.map(ee -> processedData.edges().elements.indexOf(ee))\n\t\t\t\t\t.map(index -> processedData.edges().elements.get(index))\n\t\t\t\t\t.toList();\n\n\t\t\t\tvar parallelNodeTargets = parallelNodeEdges.stream()\n\t\t\t\t\t.map(ee -> ee.target().id())\n\t\t\t\t\t.collect(Collectors.toSet());\n\n\t\t\t\tif (parallelNodeTargets.size() > 1) {\n\n\t\t\t\t\tvar conditionalEdges = parallelNodeEdges.stream()\n\t\t\t\t\t\t.filter(ee -> ee.target().value() != null)\n\t\t\t\t\t\t.toList();\n\t\t\t\t\tif (!conditionalEdges.isEmpty()) {\n\t\t\t\t\t\tthrow Errors.unsupportedConditionalEdgeOnParallelNode.exception(e.sourceId(),\n\t\t\t\t\t\t\t\tconditionalEdges.stream().map(Edge::sourceId).toList());\n\t\t\t\t\t}\n\t\t\t\t\tthrow Errors.illegalMultipleTargetsOnParallelNode.exception(e.sourceId(), parallelNodeTargets);\n\t\t\t\t}\n\n\t\t\t\tvar actions = parallelNodeStream.get()\n\t\t\t\t\t// .map( target -> nodes.remove(target.id()) )\n\t\t\t\t\t.map(target -> nodes.get(target.id()))\n\t\t\t\t\t.toList();\n\n\t\t\t\tvar parallelNode = new ParallelNode(e.sourceId(), actions, keyStrategyMap);\n\n\t\t\t\tnodes.put(parallelNode.id(), parallelNode.actionFactory().apply(compileConfig));\n\n\t\t\t\tedges.put(e.sourceId(), new EdgeValue(parallelNode.id()));\n\n\t\t\t\tedges.put(parallelNode.id(), new EdgeValue(parallelNodeTargets.iterator().next()));\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\tpublic Collection<StateSnapshot> getStateHistory(RunnableConfig config) {\n\t\tBaseCheckpointSaver saver = compileConfig.checkpointSaver()\n\t\t\t.orElseThrow(() -> (new IllegalStateException(\"Missing CheckpointSaver!\")));\n\n\t\treturn saver.list(config)\n\t\t\t.stream()\n\t\t\t.map(checkpoint -> StateSnapshot.of(keyStrategyMap, checkpoint, config, stateGraph.getStateFactory()))\n\t\t\t.collect(toList());\n\t}\n\n\t/**\n\t * Same of {@link #stateOf(RunnableConfig)} but throws an IllegalStateException if\n\t * checkpoint is not found.\n\t * @param config the RunnableConfig\n\t * @return the StateSnapshot of the given RunnableConfig\n\t * @throws IllegalStateException if the saver is not defined, or no checkpoint is\n\t * found\n\t */\n\tpublic StateSnapshot getState(RunnableConfig config) {\n\t\treturn stateOf(config).orElseThrow(() -> (new IllegalStateException(\"Missing Checkpoint!\")));\n\t}\n\n\t/**\n\t * Get the StateSnapshot of the given RunnableConfig.\n\t * @param config the RunnableConfig\n\t * @return an Optional of StateSnapshot of the given RunnableConfig\n\t * @throws IllegalStateException if the saver is not defined\n\t */\n\tpublic Optional<StateSnapshot> stateOf(RunnableConfig config) {\n\t\tBaseCheckpointSaver saver = compileConfig.checkpointSaver()\n\t\t\t.orElseThrow(() -> (new IllegalStateException(\"Missing CheckpointSaver!\")));\n\n\t\treturn saver.get(config)\n\t\t\t.map(checkpoint -> StateSnapshot.of(keyStrategyMap, checkpoint, config, stateGraph.getStateFactory()));\n\n\t}\n\n\t/**\n\t * Update the state of the graph with the given values. If asNode is given, it will be\n\t * used to determine the next node to run. If not given, the next node will be\n\t * determined by the state graph.\n\t * @param config the RunnableConfig containing the graph state\n\t * @param values the values to be updated\n\t * @param asNode the node id to be used for the next node. can be null\n\t * @return the updated RunnableConfig\n\t * @throws Exception when something goes wrong\n\t */\n\tpublic RunnableConfig updateState(RunnableConfig config, Map<String, Object> values, String asNode)\n\t\t\tthrows Exception {\n\t\tBaseCheckpointSaver saver = compileConfig.checkpointSaver()\n\t\t\t.orElseThrow(() -> (new IllegalStateException(\"Missing CheckpointSaver!\")));\n\n\t\t// merge values with checkpoint values\n\t\tCheckpoint branchCheckpoint = saver.get(config)\n\t\t\t.map(Checkpoint::new)\n\t\t\t.map(cp -> cp.updateState(values, keyStrategyMap))\n\t\t\t.orElseThrow(() -> (new IllegalStateException(\"Missing Checkpoint!\")));\n\n\t\tString nextNodeId = null;\n\t\tif (asNode != null) {\n\t\t\tvar nextNodeCommand = nextNodeId(asNode, branchCheckpoint.getState(), config);\n\n\t\t\tnextNodeId = nextNodeCommand.gotoNode();\n\t\t\tbranchCheckpoint = branchCheckpoint.updateState(nextNodeCommand.update(), keyStrategyMap);\n\n\t\t}\n\t\t// update checkpoint in saver\n\t\tRunnableConfig newConfig = saver.put(config, branchCheckpoint);\n\n\t\treturn RunnableConfig.builder(newConfig).checkPointId(branchCheckpoint.getId()).nextNode(nextNodeId).build();\n\t}\n\n\t/***\n\t * Update the state of the graph with the given values.\n\t * @param config the RunnableConfig containing the graph state\n\t * @param values the values to be updated\n\t * @return the updated RunnableConfig\n\t * @throws Exception when something goes wrong\n\t */\n\tpublic RunnableConfig updateState(RunnableConfig config, Map<String, Object> values) throws Exception {\n\t\treturn updateState(config, values, null);\n\t}\n\n\t/**\n\t * Sets the maximum number of iterations for the graph execution.\n\t * @param maxIterations the maximum number of iterations\n\t * @throws IllegalArgumentException if maxIterations is less than or equal to 0\n\t */\n\tpublic void setMaxIterations(int maxIterations) {\n\t\tif (maxIterations <= 0) {\n\t\t\tthrow new IllegalArgumentException(\"maxIterations must be > 0!\");\n\t\t}\n\t\tthis.maxIterations = maxIterations;\n\t}\n\n\tprivate Command nextNodeId(EdgeValue route, Map<String, Object> state, String nodeId, RunnableConfig config)\n\t\t\tthrows Exception {\n\n\t\tif (route == null) {\n\t\t\tthrow RunnableErrors.missingEdge.exception(nodeId);\n\t\t}\n\t\tif (route.id() != null) {\n\t\t\treturn new Command(route.id(), state);\n\t\t}\n\t\tif (route.value() != null) {\n\t\t\tOverAllState derefState = stateGraph.getStateFactory().apply(state);\n\n\t\t\tvar command = route.value().action().apply(derefState, config).get();\n\n\t\t\tvar newRoute = command.gotoNode();\n\n\t\t\tString result = route.value().mappings().get(newRoute);\n\t\t\tif (result == null) {\n\t\t\t\tthrow RunnableErrors.missingNodeInEdgeMapping.exception(nodeId, newRoute);\n\t\t\t}\n\n\t\t\tvar currentState = OverAllState.updateState(state, command.update(), keyStrategyMap);\n\n\t\t\treturn new Command(result, currentState);\n\t\t}\n\t\tthrow RunnableErrors.executionError.exception(format(\"invalid edge value for nodeId: [%s] !\", nodeId));\n\t}\n\n\t/**\n\t * Determines the next node ID based on the current node ID and state.\n\t * @param nodeId the current node ID\n\t * @param state the current state\n\t * @return the next node command\n\t * @throws Exception if there is an error determining the next node ID\n\t */\n\tprivate Command nextNodeId(String nodeId, Map<String, Object> state, RunnableConfig config) throws Exception {\n\t\treturn nextNodeId(edges.get(nodeId), state, nodeId, config);\n\n\t}\n\n\tprivate Command getEntryPoint(Map<String, Object> state, RunnableConfig config) throws Exception {\n\t\tvar entryPoint = this.edges.get(START);\n\t\treturn nextNodeId(entryPoint, state, \"entryPoint\", config);\n\t}\n\n\tprivate boolean shouldInterruptBefore(String nodeId, String previousNodeId) {\n\t\tif (previousNodeId == null) { // FIX RESUME ERROR\n\t\t\treturn false;\n\t\t}\n\t\treturn compileConfig.interruptsBefore().contains(nodeId);\n\t}\n\n\tprivate boolean shouldInterruptAfter(String nodeId, String previousNodeId) {\n\t\tif (nodeId == null) { // FIX RESUME ERROR\n\t\t\treturn false;\n\t\t}\n\t\treturn compileConfig.interruptsAfter().contains(nodeId);\n\t}\n\n\tprivate Optional<Checkpoint> addCheckpoint(RunnableConfig config, String nodeId, Map<String, Object> state,\n\t\t\tString nextNodeId) throws Exception {\n\t\tif (compileConfig.checkpointSaver().isPresent()) {\n\t\t\tvar cp = Checkpoint.builder().nodeId(nodeId).state(cloneState(state)).nextNodeId(nextNodeId).build();\n\t\t\tcompileConfig.checkpointSaver().get().put(config, cp);\n\t\t\treturn Optional.of(cp);\n\t\t}\n\t\treturn Optional.empty();\n\n\t}\n\n\t/**\n\t * Gets initial state.\n\t * @param inputs the inputs\n\t * @param config the config\n\t * @return the initial state\n\t */\n\tMap<String, Object> getInitialState(Map<String, Object> inputs, RunnableConfig config) {\n\n\t\treturn compileConfig.checkpointSaver()\n\t\t\t.flatMap(saver -> saver.get(config))\n\t\t\t.map(cp -> OverAllState.updateState(cp.getState(), inputs, keyStrategyMap))\n\t\t\t.orElseGet(() -> OverAllState.updateState(new HashMap<>(), inputs, keyStrategyMap));\n\t}\n\n\t/**\n\t * Clone state over all state.\n\t * @param data the data\n\t * @return the over all state\n\t */\n\tOverAllState cloneState(Map<String, Object> data) throws IOException, ClassNotFoundException {\n\t\treturn stateGraph.getStateSerializer().cloneObject(data);\n\t}\n\n\t/**\n\t * Creates an AsyncGenerator stream of NodeOutput based on the provided inputs.\n\t * @param inputs the input map\n\t * @param config the invoke configuration\n\t * @return an AsyncGenerator stream of NodeOutput\n\t */\n\tpublic AsyncGenerator<NodeOutput> stream(Map<String, Object> inputs, RunnableConfig config)\n\t\t\tthrows GraphRunnerException {\n\t\tObjects.requireNonNull(config, \"config cannot be null\");\n\t\tfinal AsyncNodeGenerator<NodeOutput> generator = new AsyncNodeGenerator<>(stateCreate(inputs), config);\n\n\t\treturn new AsyncGenerator.WithEmbed<>(generator);\n\t}\n\n\t/**\n\t * Stream async generator.\n\t * @param overAllState the over all state\n\t * @param config the config\n\t * @return the async generator\n\t */\n\tpublic AsyncGenerator<NodeOutput> streamFromInitialNode(OverAllState overAllState, RunnableConfig config)\n\t\t\tthrows GraphRunnerException {\n\t\tObjects.requireNonNull(config, \"config cannot be null\");\n\t\tfinal AsyncNodeGenerator<NodeOutput> generator = new AsyncNodeGenerator<>(overAllState, config);\n\n\t\treturn new AsyncGenerator.WithEmbed<>(generator);\n\t}\n\n\t/**\n\t * Creates an AsyncGenerator stream of NodeOutput based on the provided inputs.\n\t * @param inputs the input map\n\t * @return an AsyncGenerator stream of NodeOutput\n\t */\n\tpublic AsyncGenerator<NodeOutput> stream(Map<String, Object> inputs) throws GraphRunnerException {\n\t\treturn this.streamFromInitialNode(stateCreate(inputs), RunnableConfig.builder().build());\n\t}\n\n\t/**\n\t * Stream async generator.\n\t * @return the async generator\n\t */\n\tpublic AsyncGenerator<NodeOutput> stream() throws GraphRunnerException {\n\t\treturn this.stream(Map.of(), RunnableConfig.builder().build());\n\t}\n\n\t/**\n\t * Invokes the graph execution with the provided inputs and returns the final state.\n\t * @param inputs the input map\n\t * @param config the invoke configuration\n\t * @return an Optional containing the final state if present, otherwise an empty\n\t * Optional\n\t */\n\tpublic Optional<OverAllState> invoke(Map<String, Object> inputs, RunnableConfig config)\n\t\t\tthrows GraphRunnerException {\n\t\treturn stream(inputs, config).stream().reduce((a, b) -> b).map(NodeOutput::state);\n\t}\n\n\t/**\n\t * Invoke optional.\n\t * @param overAllState the over all state\n\t * @param config the config\n\t * @return the optional\n\t */\n\tpublic Optional<OverAllState> invoke(OverAllState overAllState, RunnableConfig config) throws GraphRunnerException {\n\t\treturn streamFromInitialNode(overAllState, config).stream().reduce((a, b) -> b).map(NodeOutput::state);\n\t}\n\n\t/**\n\t * Invokes the graph execution with the provided inputs and returns the final state.\n\t * @param inputs the input map\n\t * @return an Optional containing the final state if present, otherwise an empty\n\t * Optional\n\t */\n\tpublic Optional<OverAllState> invoke(Map<String, Object> inputs) throws GraphRunnerException {\n\t\treturn this.invoke(stateCreate(inputs), RunnableConfig.builder().build());\n\t}\n\n\tprivate OverAllState stateCreate(Map<String, Object> inputs) {\n\t\t// Creates a new OverAllState instance based on the presence of an\n\t\t// OverAllStateFactory in the stateGraph.\n\t\t// If no factory is present, constructs a new state using key strategies from\n\t\t// the\n\t\t// graph and provided input data.\n\t\t// If a factory exists, uses it to create the state and applies the input data.\n\t\treturn Objects.isNull(stateGraph.getOverAllStateFactory()) ? OverAllStateBuilder.builder()\n\t\t\t.withKeyStrategies(stateGraph.getKeyStrategyFactory().apply())\n\t\t\t.withData(inputs)\n\t\t\t.build() : stateGraph.getOverAllStateFactory().create().input(inputs);\n\t}\n\n\t/**\n\t * Experimental API\n\t * @param feedback the feedback\n\t * @param config the config\n\t * @return the optional\n\t */\n\tpublic Optional<OverAllState> resume(OverAllState.HumanFeedback feedback, RunnableConfig config)\n\t\t\tthrows GraphRunnerException {\n\t\tStateSnapshot stateSnapshot = this.getState(config);\n\t\tOverAllState resumeState = stateCreate(stateSnapshot.state().data());\n\t\tresumeState.withResume();\n\t\tresumeState.withHumanFeedback(feedback);\n\n\t\treturn this.invoke(resumeState, config);\n\t}\n\n\t/**\n\t * Creates an AsyncGenerator stream of NodeOutput based on the provided inputs.\n\t * @param inputs the input map\n\t * @param config the invoke configuration\n\t * @return an AsyncGenerator stream of NodeOutput\n\t */\n\tpublic AsyncGenerator<NodeOutput> streamSnapshots(Map<String, Object> inputs, RunnableConfig config)\n\t\t\tthrows GraphRunnerException {\n\t\tObjects.requireNonNull(config, \"config cannot be null\");\n\n\t\tfinal AsyncNodeGenerator<NodeOutput> generator = new AsyncNodeGenerator<>(stateCreate(inputs),\n\t\t\t\tconfig.withStreamMode(StreamMode.SNAPSHOTS));\n\n\t\treturn new AsyncGenerator.WithEmbed<>(generator);\n\t}\n\n\t/**\n\t * Generates a drawable graph representation of the state graph.\n\t * @param type the type of graph representation to generate\n\t * @param title the title of the graph\n\t * @param printConditionalEdges whether to print conditional edges\n\t * @return a diagram code of the state graph\n\t */\n\tpublic GraphRepresentation getGraph(GraphRepresentation.Type type, String title, boolean printConditionalEdges) {\n\n\t\tString content = type.generator.generate(processedData.nodes(), processedData.edges(), title,\n\t\t\t\tprintConditionalEdges);\n\n\t\treturn new GraphRepresentation(type, content);\n\t}\n\n\t/**\n\t * Get the last StateSnapshot of the given RunnableConfig.\n\t * @param config - the RunnableConfig\n\t * @return the last StateSnapshot of the given RunnableConfig if any\n\t */\n\tOptional<StateSnapshot> lastStateOf(RunnableConfig config) {\n\t\treturn getStateHistory(config).stream().findFirst();\n\t}\n\n\t/**\n\t * Generates a drawable graph representation of the state graph.\n\t * @param type the type of graph representation to generate\n\t * @param title the title of the graph\n\t * @return a diagram code of the state graph\n\t */\n\tpublic GraphRepresentation getGraph(GraphRepresentation.Type type, String title) {\n\n\t\tString content = type.generator.generate(processedData.nodes(), processedData.edges(), title, true);\n\n\t\treturn new GraphRepresentation(type, content);\n\t}\n\n\t/**\n\t * Generates a drawable graph representation of the state graph with default title.\n\t * @param type the type of graph representation to generate\n\t * @return a diagram code of the state graph\n\t */\n\tpublic GraphRepresentation getGraph(GraphRepresentation.Type type) {\n\t\treturn getGraph(type, \"Graph Diagram\", true);\n\t}\n\n\t/**\n\t * Async Generator for streaming outputs.\n\t *\n\t * @param <Output> the type of the output\n\t */\n\tpublic class AsyncNodeGenerator<Output extends NodeOutput> implements AsyncGenerator<Output> {\n\n\t\t/**\n\t\t * The Current state.\n\t\t */\n\t\tMap<String, Object> currentState;\n\n\t\t/**\n\t\t * The Current node id.\n\t\t */\n\t\tString currentNodeId;\n\n\t\t/**\n\t\t * The Next node id.\n\t\t */\n\t\tString nextNodeId;\n\n\t\t/**\n\t\t * The Over all state.\n\t\t */\n\t\tOverAllState overAllState;\n\n\t\t/**\n\t\t * The Iteration.\n\t\t */\n\t\tint iteration = 0;\n\n\t\t/**\n\t\t * The Config.\n\t\t */\n\t\tRunnableConfig config;\n\n\t\t/**\n\t\t * The Resumed from embed.\n\t\t */\n\t\tboolean resumedFromEmbed = false;\n\n\t\t/**\n\t\t * Instantiates a new Async node generator.\n\t\t * @param overAllState the over all state\n\t\t * @param config the config\n\t\t */\n\t\tprotected AsyncNodeGenerator(OverAllState overAllState, RunnableConfig config) throws GraphRunnerException {\n\n\t\t\tif (overAllState.isResume()) {\n\n\t\t\t\tlog.trace(\"RESUME REQUEST\");\n\n\t\t\t\tBaseCheckpointSaver saver = compileConfig.checkpointSaver()\n\t\t\t\t\t.orElseThrow(() -> (new IllegalStateException(\n\t\t\t\t\t\t\t\"inputs cannot be null (ie. resume request) if no checkpoint saver is configured\")));\n\t\t\t\tCheckpoint startCheckpoint = saver.get(config)\n\t\t\t\t\t.orElseThrow(() -> (new IllegalStateException(\"Resume request without a saved checkpoint!\")));\n\n\t\t\t\tthis.currentState = startCheckpoint.getState();\n\n\t\t\t\t// Reset checkpoint id\n\t\t\t\tthis.config = config.withCheckPointId(null);\n\t\t\t\tthis.overAllState = overAllState.input(this.currentState);\n\t\t\t\tthis.nextNodeId = startCheckpoint.getNextNodeId();\n\t\t\t\tthis.currentNodeId = null;\n\t\t\t\tlog.trace(\"RESUME FROM {}\", startCheckpoint.getNodeId());\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tlog.trace(\"START\");\n\t\t\t\tMap<String, Object> inputs = overAllState.data();\n\t\t\t\tboolean verify = overAllState.keyVerify();\n\t\t\t\tif (!CollectionUtils.isEmpty(inputs) && !verify) {\n\t\t\t\t\tthrow RunnableErrors.initializationError.exception(Arrays.toString(inputs.keySet().toArray()));\n\t\t\t\t}\n\t\t\t\t// patch for backward support of AppendableValue\n\t\t\t\tthis.currentState = getInitialState(inputs, config);\n\t\t\t\tthis.overAllState = overAllState.input(currentState);\n\t\t\t\tthis.nextNodeId = null;\n\t\t\t\tthis.currentNodeId = START;\n\t\t\t\tthis.config = config;\n\t\t\t}\n\t\t}\n\n\t\tprivate Optional<BaseCheckpointSaver.Tag> releaseThread() throws Exception {\n\t\t\tif (compileConfig.releaseThread() && compileConfig.checkpointSaver().isPresent()) {\n\t\t\t\treturn Optional.of(compileConfig.checkpointSaver().get().release(config));\n\t\t\t}\n\t\t\treturn Optional.empty();\n\t\t}\n\n\t\t/**\n\t\t * Build node output output.\n\t\t * @param nodeId the node id\n\t\t * @return the output\n\t\t */\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprotected Output buildNodeOutput(String nodeId) {\n\t\t\treturn (Output) NodeOutput.of(nodeId, cloneState(currentState));\n\t\t}\n\n\t\t/**\n\t\t * Clone state over all state.\n\t\t * @param data the data\n\t\t * @return the over all state\n\t\t */\n\t\tOverAllState cloneState(Map<String, Object> data) {\n\t\t\treturn new OverAllState(data, keyStrategyMap, overAllState.isResume());\n\t\t}\n\n\t\t/**\n\t\t * Build state snapshot output.\n\t\t * @param checkpoint the checkpoint\n\t\t * @return the output\n\t\t */\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprotected Output buildStateSnapshot(Checkpoint checkpoint) {\n\t\t\treturn (Output) StateSnapshot.of(keyStrategyMap, checkpoint, config,\n\t\t\t\t\tstateGraph.getStateSerializer().stateFactory());\n\t\t}\n\n\t\t/**\n\t\t * Gets embed generator from partial state.\n\t\t * @param partialState the partial state containing generator instances\n\t\t * @return an Optional containing Data with the generator if found, empty\n\t\t * otherwise\n\t\t */\n\t\tprivate Optional<Data<Output>> getEmbedGenerator(Map<String, Object> partialState) {\n\t\t\t// Extract all AsyncGenerator instances\n\t\t\tList<AsyncGenerator<Output>> asyncNodeGenerators = new ArrayList<>();\n\t\t\tvar generatorEntries = partialState.entrySet().stream().filter(e -> {\n\t\t\t\t// Fixed when parallel nodes return asynchronous generating the same key\n\t\t\t\tObject value = e.getValue();\n\t\t\t\tif (value instanceof AsyncGenerator) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (value instanceof Collection collection) {\n\t\t\t\t\tcollection.forEach(o -> {\n\t\t\t\t\t\tif (o instanceof AsyncGenerator<?>) {\n\t\t\t\t\t\t\tasyncNodeGenerators.add((AsyncGenerator<Output>) o);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}).collect(Collectors.toList());\n\n\t\t\tif (generatorEntries.isEmpty() && asyncNodeGenerators.isEmpty()) {\n\t\t\t\treturn Optional.empty();\n\t\t\t}\n\n\t\t\t// Log information about found generators\n\t\t\tif (generatorEntries.size() > 1) {\n\t\t\t\tlog.debug(\"Multiple generators found: {} - keys: {}\", generatorEntries.size(),\n\t\t\t\t\t\tgeneratorEntries.stream().map(Map.Entry::getKey).collect(Collectors.joining(\", \")));\n\t\t\t}\n\n\t\t\t// Create appropriate generator (single or merged)\n\t\t\tAsyncGenerator<Output> generator = AsyncGeneratorUtils.createAppropriateGenerator(generatorEntries,\n\t\t\t\t\tasyncNodeGenerators, keyStrategyMap);\n\n\t\t\t// Create data processing logic for the generator\n\t\t\treturn Optional.of(Data.composeWith(generator.map(n -> {\n\t\t\t\tn.setSubGraph(true);\n\t\t\t\treturn n;\n\t\t\t}), data -> processGeneratorOutput(data, partialState, generatorEntries)));\n\t\t}\n\n\t\t/**\n\t\t * Processes output data from generator.\n\t\t * @param data output data from generator\n\t\t * @param partialState partial state\n\t\t * @param generatorEntries generator entries list\n\t\t * @throws Exception if an error occurs during processing\n\t\t */\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprivate void processGeneratorOutput(Object data, Map<String, Object> partialState,\n\t\t\t\tList<Map.Entry<String, Object>> generatorEntries) throws Exception {\n\t\t\t// Remove all generators\n\t\t\tMap<String, Object> partialStateWithoutGenerators = new HashMap<>();\n\t\t\tfor (Map.Entry<String, Object> entry : partialState.entrySet()) {\n\t\t\t\tif (entry.getValue() instanceof AsyncGenerator) {\n\t\t\t\t\tcontinue; // Skip top-level AsyncGenerator values\n\t\t\t\t}\n\n\t\t\t\tif (entry.getValue() instanceof Collection<?>) {\n\t\t\t\t\tCollection<?> collection = (Collection<?>) entry.getValue();\n\t\t\t\t\tArrayList<Object> filteredCollection = new ArrayList<>();\n\n\t\t\t\t\tfor (Object item : collection) {\n\t\t\t\t\t\tif (!(item instanceof AsyncGenerator)) {\n\t\t\t\t\t\t\tfilteredCollection.add(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!filteredCollection.isEmpty()) {\n\t\t\t\t\t\tpartialStateWithoutGenerators.put(entry.getKey(), filteredCollection);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Keep the entry if it's not an AsyncGenerator and not a collection\n\t\t\t\t\t// containing it\n\t\t\t\t\tpartialStateWithoutGenerators.put(entry.getKey(), entry.getValue());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update state with partial state without generators\n\t\t\tvar intermediateState = OverAllState.updateState(currentState, partialStateWithoutGenerators,\n\t\t\t\t\tkeyStrategyMap);\n\t\t\tcurrentState = intermediateState;\n\t\t\toverAllState.updateState(partialStateWithoutGenerators);\n\n\t\t\t// If data is not null and is a Map, update state with it\n\t\t\tif (data != null) {\n\t\t\t\tif (data instanceof Map<?, ?>) {\n\t\t\t\t\tcurrentState = OverAllState.updateState(intermediateState, (Map<String, Object>) data,\n\t\t\t\t\t\t\tkeyStrategyMap);\n\t\t\t\t\toverAllState.updateState((Map<String, Object>) data);\n\n\t\t\t\t\tif (log.isDebugEnabled() && generatorEntries.size() > 1) {\n\t\t\t\t\t\tlog.debug(\"Updated state with data keys: {}\",\n\t\t\t\t\t\t\t\t((Map<String, Object>) data).keySet().stream().collect(Collectors.joining(\", \")));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Embedded generator must return a Map\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Get next node command\n\t\t\tvar nextNodeCommand = nextNodeId(currentNodeId, overAllState, currentState, config);\n\t\t\tnextNodeId = nextNodeCommand.gotoNode();\n\t\t\tcurrentState = nextNodeCommand.update();\n\t\t\tresumedFromEmbed = true;\n\t\t}\n\n\t\tprivate CompletableFuture<Data<Output>> evaluateAction(AsyncNodeActionWithConfig action,\n\t\t\t\tOverAllState withState) {\n\t\t\tdoListeners(NODE_BEFORE, null);\n\t\t\treturn action.apply(withState, config).thenApply(updateState -> {\n\t\t\t\ttry {\n\t\t\t\t\tif (action instanceof CommandNode.AsyncCommandNodeActionWithConfig) {\n\t\t\t\t\t\tAsyncCommandAction commandAction = (AsyncCommandAction) updateState.get(\"command\");\n\t\t\t\t\t\tCommand command = commandAction.apply(withState, config).join();\n\n\t\t\t\t\t\tthis.currentState = OverAllState.updateState(currentState, command.update(), keyStrategyMap);\n\t\t\t\t\t\tthis.overAllState.updateState(command.update());\n\t\t\t\t\t\tnextNodeId = command.gotoNode();\n\t\t\t\t\t\treturn Data.of(getNodeOutput());\n\t\t\t\t\t}\n\n\t\t\t\t\tOptional<Data<Output>> embed = getEmbedGenerator(updateState);\n\t\t\t\t\tif (embed.isPresent()) {\n\t\t\t\t\t\treturn embed.get();\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.currentState = OverAllState.updateState(currentState, updateState, keyStrategyMap);\n\t\t\t\t\tthis.overAllState.updateState(updateState);\n\t\t\t\t\tvar nextNodeCommand = nextNodeId(currentNodeId, overAllState, currentState, config);\n\t\t\t\t\tnextNodeId = nextNodeCommand.gotoNode();\n\t\t\t\t\tthis.currentState = nextNodeCommand.update();\n\n\t\t\t\t\treturn Data.of(getNodeOutput());\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new CompletionException(e);\n\t\t\t\t}\n\t\t\t}).whenComplete((outputData, throwable) -> doListeners(NODE_AFTER, null));\n\t\t}\n\n\t\tprivate Command nextNodeId(String nodeId, OverAllState overAllState, Map<String, Object> state,\n\t\t\t\tRunnableConfig config) throws Exception {\n\t\t\tEdgeValue route = edges.get(nodeId);\n\n\t\t\tif (route == null) {\n\t\t\t\tthrow RunnableErrors.missingEdge.exception(nodeId);\n\t\t\t}\n\t\t\tif (route.id() != null) {\n\t\t\t\treturn new Command(route.id(), state);\n\t\t\t}\n\t\t\tif (route.value() != null) {\n\t\t\t\tvar command = route.value().action().apply(overAllState, config).get();\n\n\t\t\t\tvar newRoute = command.gotoNode();\n\n\t\t\t\tString result = route.value().mappings().get(newRoute);\n\t\t\t\tif (result == null) {\n\t\t\t\t\tthrow RunnableErrors.missingNodeInEdgeMapping.exception(nodeId, newRoute);\n\t\t\t\t}\n\n\t\t\t\tvar currentState = OverAllState.updateState(state, command.update(), keyStrategyMap);\n\n\t\t\t\toverAllState.updateState(command.update());\n\n\t\t\t\treturn new Command(result, currentState);\n\t\t\t}\n\t\t\tthrow RunnableErrors.executionError.exception(format(\"invalid edge value for nodeId: [%s] !\", nodeId));\n\t\t}\n\n\t\t/**\n\t\t * evaluate Action without nested support\n\t\t */\n\t\tprivate CompletableFuture<Output> evaluateActionWithoutNested(AsyncNodeAction action, OverAllState withState) {\n\n\t\t\treturn action.apply(withState).thenApply(partialState -> {\n\t\t\t\ttry {\n\t\t\t\t\tcurrentState = OverAllState.updateState(currentState, partialState, keyStrategyMap);\n\n\t\t\t\t\tvar nextNodeCommand = nextNodeId(currentNodeId, overAllState, currentState, config);\n\t\t\t\t\tnextNodeId = nextNodeCommand.gotoNode();\n\t\t\t\t\tcurrentState = nextNodeCommand.update();\n\n\t\t\t\t\tOptional<Checkpoint> cp = addCheckpoint(config, currentNodeId, currentState, nextNodeId);\n\t\t\t\t\treturn (cp.isPresent() && config.streamMode() == StreamMode.SNAPSHOTS)\n\t\t\t\t\t\t\t? buildStateSnapshot(cp.get()) : buildNodeOutput(currentNodeId);\n\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new CompletionException(e);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tprivate CompletableFuture<Output> getNodeOutput() throws Exception {\n\t\t\tOptional<Checkpoint> cp = addCheckpoint(config, currentNodeId, currentState, nextNodeId);\n\t\t\treturn completedFuture((cp.isPresent() && config.streamMode() == StreamMode.SNAPSHOTS)\n\t\t\t\t\t? buildStateSnapshot(cp.get()) : buildNodeOutput(currentNodeId));\n\t\t}\n\n\t\t@Override\n\t\tpublic Data<Output> next() {\n\t\t\ttry {\n\t\t\t\t// GUARD: CHECK MAX ITERATION REACHED\n\t\t\t\tif (++iteration > maxIterations) {\n\t\t\t\t\t// log.warn( \"Maximum number of iterations ({}) reached!\",\n\t\t\t\t\t// maxIterations);\n\t\t\t\t\treturn Data.error(new IllegalStateException(\n\t\t\t\t\t\t\tformat(\"Maximum number of iterations (%d) reached!\", maxIterations)));\n\t\t\t\t}\n\n\t\t\t\t// GUARD: CHECK IF IT IS END\n\t\t\t\tif (nextNodeId == null && currentNodeId == null) {\n\t\t\t\t\treturn releaseThread().map(Data::<Output>done).orElseGet(() -> Data.done(currentState));\n\t\t\t\t}\n\n\t\t\t\t// IS IT A RESUME FROM EMBED ?\n\t\t\t\tif (resumedFromEmbed) {\n\t\t\t\t\tfinal CompletableFuture<Output> future = getNodeOutput();\n\t\t\t\t\tresumedFromEmbed = false;\n\t\t\t\t\treturn Data.of(future);\n\t\t\t\t}\n\n\t\t\t\tif (START.equals(currentNodeId)) {\n\t\t\t\t\tdoListeners(START, null);\n\t\t\t\t\tvar nextNodeCommand = getEntryPoint(currentState, config);\n\t\t\t\t\tnextNodeId = nextNodeCommand.gotoNode();\n\t\t\t\t\tcurrentState = nextNodeCommand.update();\n\n\t\t\t\t\tvar cp = addCheckpoint(config, START, currentState, nextNodeId);\n\n\t\t\t\t\tvar output = (cp.isPresent() && config.streamMode() == StreamMode.SNAPSHOTS)\n\t\t\t\t\t\t\t? buildStateSnapshot(cp.get()) : buildNodeOutput(currentNodeId);\n\n\t\t\t\t\tcurrentNodeId = nextNodeId;\n\n\t\t\t\t\treturn Data.of(output);\n\t\t\t\t}\n\n\t\t\t\tif (END.equals(nextNodeId)) {\n\t\t\t\t\tnextNodeId = null;\n\t\t\t\t\tcurrentNodeId = null;\n\t\t\t\t\tdoListeners(END, null);\n\t\t\t\t\treturn Data.of(buildNodeOutput(END));\n\t\t\t\t}\n\n\t\t\t\t// check on previous node\n\t\t\t\tif (shouldInterruptAfter(currentNodeId, nextNodeId)) {\n\t\t\t\t\treturn Data.done(currentNodeId);\n\t\t\t\t}\n\n\t\t\t\tif (shouldInterruptBefore(nextNodeId, currentNodeId)) {\n\t\t\t\t\treturn Data.done(nextNodeId);\n\t\t\t\t}\n\n\t\t\t\tcurrentNodeId = nextNodeId;\n\n\t\t\t\tvar action = nodes.get(currentNodeId);\n\n\t\t\t\tif (action == null)\n\t\t\t\t\tthrow RunnableErrors.missingNode.exception(currentNodeId);\n\n\t\t\t\treturn evaluateAction(action, this.overAllState).get();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tdoListeners(ERROR, e);\n\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\treturn Data.error(e);\n\t\t\t}\n\t\t}\n\n\t\tprivate void doListeners(String scene, Exception e) {\n\t\t\tDeque<GraphLifecycleListener> listeners = new LinkedBlockingDeque<>(compileConfig.lifecycleListeners());\n\n\t\t\tprocessListenersLIFO(listeners, scene, e);\n\t\t}\n\n\t\tprivate void processListenersLIFO(Deque<GraphLifecycleListener> listeners, String scene, Exception e) {\n\t\t\tif (listeners.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tGraphLifecycleListener listener = listeners.pollLast();\n\n\t\t\ttry {\n\t\t\t\tif (START.equals(scene)) {\n\t\t\t\t\tlistener.onStart(START, this.currentState, this.config);\n\t\t\t\t}\n\t\t\t\telse if (END.equals(scene)) {\n\t\t\t\t\tlistener.onComplete(END, this.currentState, this.config);\n\t\t\t\t}\n\t\t\t\telse if (ERROR.equals(scene)) {\n\t\t\t\t\tlistener.onError(this.currentNodeId, this.currentState, e, this.config);\n\t\t\t\t}\n\t\t\t\telse if (NODE_BEFORE.equals(scene)) {\n\t\t\t\t\tlistener.before(this.currentNodeId, this.currentState, this.config, SystemClock.now());\n\t\t\t\t}\n\t\t\t\telse if (NODE_AFTER.equals(scene)) {\n\t\t\t\t\tlistener.after(this.currentNodeId, this.currentState, this.config, SystemClock.now());\n\t\t\t\t}\n\n\t\t\t\tprocessListenersLIFO(listeners, scene, e);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlog.debug(\"Error occurred during listener processing: {}\", ex.getMessage());\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\n/**\n * The type Processed nodes edges and config.\n */\nrecord ProcessedNodesEdgesAndConfig(StateGraph.Nodes nodes, StateGraph.Edges edges, Set<String> interruptsBefore,\n\t\tSet<String> interruptsAfter) {\n\n\t/**\n\t * Instantiates a new Processed nodes edges and config.\n\t * @param stateGraph the state graph\n\t * @param config the config\n\t */\n\tProcessedNodesEdgesAndConfig(StateGraph stateGraph, CompileConfig config) {\n\t\tthis(stateGraph.nodes, stateGraph.edges, config.interruptsBefore(), config.interruptsAfter());\n\t}\n\n\t/**\n\t * Process processed nodes edges and config.\n\t * @param stateGraph the state graph\n\t * @param config the config\n\t * @return the processed nodes edges and config\n\t * @throws GraphStateException the graph state exception\n\t */\n\tstatic ProcessedNodesEdgesAndConfig process(StateGraph stateGraph, CompileConfig config)\n\t\t\tthrows GraphStateException {\n\n\t\tvar subgraphNodes = stateGraph.nodes.onlySubStateGraphNodes();\n\n\t\tif (subgraphNodes.isEmpty()) {\n\t\t\treturn new ProcessedNodesEdgesAndConfig(stateGraph, config);\n\t\t}\n\n\t\tvar interruptsBefore = config.interruptsBefore();\n\t\tvar interruptsAfter = config.interruptsAfter();\n\t\tvar nodes = new StateGraph.Nodes(stateGraph.nodes.exceptSubStateGraphNodes());\n\t\tvar edges = new StateGraph.Edges(stateGraph.edges.elements);\n\n\t\tfor (var subgraphNode : subgraphNodes) {\n\n\t\t\tvar sgWorkflow = subgraphNode.subGraph();\n\n\t\t\t//\n\t\t\t// Process START Node\n\t\t\t//\n\t\t\tvar sgEdgeStart = sgWorkflow.edges.edgeBySourceId(START).orElseThrow();\n\n\t\t\tif (sgEdgeStart.isParallel()) {\n\t\t\t\tthrow new GraphStateException(\"subgraph not support start with parallel branches yet!\");\n\t\t\t}\n\n\t\t\tvar sgEdgeStartTarget = sgEdgeStart.target();\n\n\t\t\tif (sgEdgeStartTarget.id() == null) {\n\t\t\t\tthrow new GraphStateException(format(\"the target for node '%s' is null!\", subgraphNode.id()));\n\t\t\t}\n\n\t\t\tvar sgEdgeStartRealTargetId = subgraphNode.formatId(sgEdgeStartTarget.id());\n\n\t\t\t// Process Interruption (Before) Subgraph(s)\n\t\t\tinterruptsBefore = interruptsBefore.stream()\n\t\t\t\t.map(interrupt -> Objects.equals(subgraphNode.id(), interrupt) ? sgEdgeStartRealTargetId : interrupt)\n\t\t\t\t.collect(Collectors.toUnmodifiableSet());\n\n\t\t\tvar edgesWithSubgraphTargetId = edges.edgesByTargetId(subgraphNode.id());\n\n\t\t\tif (edgesWithSubgraphTargetId.isEmpty()) {\n\t\t\t\tthrow new GraphStateException(\n\t\t\t\t\t\tformat(\"the node '%s' is not present as target in graph!\", subgraphNode.id()));\n\t\t\t}\n\n\t\t\tfor (var edgeWithSubgraphTargetId : edgesWithSubgraphTargetId) {\n\n\t\t\t\tvar newEdge = edgeWithSubgraphTargetId.withSourceAndTargetIdsUpdated(subgraphNode, Function.identity(),\n\t\t\t\t\t\tid -> new EdgeValue((Objects.equals(id, subgraphNode.id())\n\t\t\t\t\t\t\t\t? subgraphNode.formatId(sgEdgeStartTarget.id()) : id)));\n\t\t\t\tedges.elements.remove(edgeWithSubgraphTargetId);\n\t\t\t\tedges.elements.add(newEdge);\n\t\t\t}\n\t\t\t//\n\t\t\t// Process END Nodes\n\t\t\t//\n\t\t\tvar sgEdgesEnd = sgWorkflow.edges.edgesByTargetId(END);\n\n\t\t\tvar edgeWithSubgraphSourceId = edges.edgeBySourceId(subgraphNode.id()).orElseThrow();\n\n\t\t\tif (edgeWithSubgraphSourceId.isParallel()) {\n\t\t\t\tthrow new GraphStateException(\"subgraph not support routes to parallel branches yet!\");\n\t\t\t}\n\n\t\t\t// Process Interruption (After) Subgraph(s)\n\t\t\tif (interruptsAfter.contains(subgraphNode.id())) {\n\n\t\t\t\tvar exceptionMessage = (edgeWithSubgraphSourceId.target()\n\t\t\t\t\t.id() == null) ? \"'interruption after' on subgraph is not supported yet!\" : format(\n\t\t\t\t\t\t\t\"'interruption after' on subgraph is not supported yet! consider to use 'interruption before' node: '%s'\",\n\t\t\t\t\t\t\tedgeWithSubgraphSourceId.target().id());\n\t\t\t\tthrow new GraphStateException(exceptionMessage);\n\t\t\t}\n\n\t\t\tsgEdgesEnd.stream()\n\t\t\t\t.map(e -> e.withSourceAndTargetIdsUpdated(subgraphNode, subgraphNode::formatId,\n\t\t\t\t\t\tid -> (Objects.equals(id, END) ? edgeWithSubgraphSourceId.target()\n\t\t\t\t\t\t\t\t: new EdgeValue(subgraphNode.formatId(id)))))\n\t\t\t\t.forEach(edges.elements::add);\n\t\t\tedges.elements.remove(edgeWithSubgraphSourceId);\n\n\t\t\t//\n\t\t\t// Process edges\n\t\t\t//\n\t\t\tsgWorkflow.edges.elements.stream()\n\t\t\t\t.filter(e -> !Objects.equals(e.sourceId(), START))\n\t\t\t\t.filter(e -> !e.anyMatchByTargetId(END))\n\t\t\t\t.map(e -> e.withSourceAndTargetIdsUpdated(subgraphNode, subgraphNode::formatId,\n\t\t\t\t\t\tid -> new EdgeValue(subgraphNode.formatId(id))))\n\t\t\t\t.forEach(edges.elements::add);\n\n\t\t\t//\n\t\t\t// Process nodes\n\t\t\t//\n\t\t\tsgWorkflow.nodes.elements.stream().map(n -> {\n\t\t\t\tif (n instanceof CommandNode commandNode) {\n\t\t\t\t\tMap<String, String> mappings = commandNode.getMappings();\n\t\t\t\t\tHashMap<String, String> newMappings = new HashMap<>();\n\t\t\t\t\tmappings.forEach((key, value) -> {\n\t\t\t\t\t\tnewMappings.put(key, subgraphNode.formatId(value));\n\t\t\t\t\t});\n\t\t\t\t\treturn new CommandNode(subgraphNode.formatId(n.id()),\n\t\t\t\t\t\t\tAsyncCommandAction.node_async((state, config1) -> {\n\t\t\t\t\t\t\t\tCommand command = commandNode.getAction().apply(state, config1).join();\n\t\t\t\t\t\t\t\tString NewGoToNode = subgraphNode.formatId(command.gotoNode());\n\t\t\t\t\t\t\t\treturn new Command(NewGoToNode, command.update());\n\t\t\t\t\t\t\t}), newMappings);\n\t\t\t\t}\n\t\t\t\treturn n.withIdUpdated(subgraphNode::formatId);\n\t\t\t}).forEach(nodes.elements::add);\n\t\t}\n\n\t\treturn new ProcessedNodesEdgesAndConfig(nodes, edges, interruptsBefore, interruptsAfter);\n\t}\n}", "output": "/*\n * Copyright 2024-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.graph;\n\nimport com.alibaba.cloud.ai.graph.action.AsyncCommandAction;\nimport com.alibaba.cloud.ai.graph.action.AsyncNodeAction;\nimport com.alibaba.cloud.ai.graph.action.AsyncNodeActionWithConfig;\nimport com.alibaba.cloud.ai.graph.action.Command;\nimport com.alibaba.cloud.ai.graph.async.AsyncGenerator;\nimport com.alibaba.cloud.ai.graph.checkpoint.BaseCheckpointSaver;\nimport com.alibaba.cloud.ai.graph.checkpoint.Checkpoint;\nimport com.alibaba.cloud.ai.graph.exception.Errors;\nimport com.alibaba.cloud.ai.graph.exception.GraphRunnerException;\nimport com.alibaba.cloud.ai.graph.exception.GraphStateException;\nimport com.alibaba.cloud.ai.graph.exception.RunnableErrors;\nimport com.alibaba.cloud.ai.graph.internal.edge.Edge;\nimport com.alibaba.cloud.ai.graph.internal.edge.EdgeValue;\nimport com.alibaba.cloud.ai.graph.internal.node.CommandNode;\nimport com.alibaba.cloud.ai.graph.internal.node.ParallelNode;\nimport com.alibaba.cloud.ai.graph.state.StateSnapshot;\nimport com.alibaba.cloud.ai.graph.streaming.AsyncGeneratorUtils;\nimport com.alibaba.cloud.ai.graph.utils.SystemClock;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.util.CollectionUtils;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionException;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport static com.alibaba.cloud.ai.graph.StateGraph.END;\nimport static com.alibaba.cloud.ai.graph.StateGraph.ERROR;\nimport static com.alibaba.cloud.ai.graph.StateGraph.NODE_AFTER;\nimport static com.alibaba.cloud.ai.graph.StateGraph.NODE_BEFORE;\nimport static com.alibaba.cloud.ai.graph.StateGraph.START;\nimport static java.lang.String.format;\nimport static java.util.concurrent.CompletableFuture.completedFuture;\nimport static java.util.stream.Collectors.toList;\n\n/**\n * The type Compiled graph.\n */\npublic class CompiledGraph {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(CompiledGraph.class);\n\n\t/**\n\t * The enum Stream mode.\n\t */\n\tpublic enum StreamMode {\n\n\t\t/**\n\t\t * Values stream mode.\n\t\t */\n\t\tVALUES,\n\t\t/**\n\t\t * Snapshots stream mode.\n\t\t */\n\t\tSNAPSHOTS\n\n\t}\n\n\t/**\n\t * The State graph.\n\t */\n\tpublic final StateGraph stateGraph;\n\n\tprivate final Map<String, KeyStrategy> keyStrategyMap;\n\n\t/**\n\t * The Nodes.\n\t */\n\tfinal Map<String, AsyncNodeActionWithConfig> nodes = new LinkedHashMap<>();\n\n\t/**\n\t * The Edges.\n\t */\n\tfinal Map<String, EdgeValue> edges = new LinkedHashMap<>();\n\n\tprivate final ProcessedNodesEdgesAndConfig processedData;\n\n\tprivate int maxIterations = 25;\n\n\t/**\n\t * The Compile config.\n\t */\n\tpublic final CompileConfig compileConfig;\n\n\t/**\n\t * Constructs a CompiledGraph with the given StateGraph.\n\t * @param stateGraph the StateGraph to be used in this CompiledGraph\n\t * @param compileConfig the compile config\n\t * @throws GraphStateException the graph state exception\n\t */\n\tprotected CompiledGraph(StateGraph stateGraph, CompileConfig compileConfig) throws GraphStateException {\n\t\tthis.stateGraph = stateGraph;\n\t\tthis.keyStrategyMap = Objects.isNull(stateGraph.getOverAllStateFactory())\n\t\t\t\t? stateGraph.getKeyStrategyFactory()\n\t\t\t\t\t.apply()\n\t\t\t\t\t.entrySet()\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(e -> Map.entry(e.getKey(), e.getValue()))\n\t\t\t\t\t.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))\n\t\t\t\t: stateGraph.getOverAllStateFactory().create().keyStrategies();\n\n\t\tthis.processedData = ProcessedNodesEdgesAndConfig.process(stateGraph, compileConfig);\n\n\t\t// CHECK INTERRUPTIONS\n\t\tfor (String interruption : processedData.interruptsBefore()) {\n\t\t\tif (!processedData.nodes().anyMatchById(interruption)) {\n\t\t\t\tthrow Errors.interruptionNodeNotExist.exception(interruption);\n\t\t\t}\n\t\t}\n\t\tfor (String interruption : processedData.interruptsBefore()) {\n\t\t\tif (!processedData.nodes().anyMatchById(interruption)) {\n\t\t\t\tthrow Errors.interruptionNodeNotExist.exception(interruption);\n\t\t\t}\n\t\t}\n\n\t\t// RE-CREATE THE EVENTUALLY UPDATED COMPILE CONFIG\n\t\tthis.compileConfig = CompileConfig.builder(compileConfig)\n\t\t\t.interruptsBefore(processedData.interruptsBefore())\n\t\t\t.interruptsAfter(processedData.interruptsAfter())\n\t\t\t.build();\n\n\t\t// EVALUATES NODES\n\t\tfor (var n : processedData.nodes().elements) {\n\t\t\tvar factory = n.actionFactory();\n\t\t\tObjects.requireNonNull(factory, format(\"action factory for node id '%s' is null!\", n.id()));\n\t\t\tnodes.put(n.id(), factory.apply(compileConfig));\n\t\t}\n\n\t\t// EVALUATE EDGES\n\t\tfor (var e : processedData.edges().elements) {\n\t\t\tvar targets = e.targets();\n\t\t\tif (targets.size() == 1) {\n\t\t\t\tedges.put(e.sourceId(), targets.get(0));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSupplier<Stream<EdgeValue>> parallelNodeStream = () -> targets.stream()\n\t\t\t\t\t.filter(target -> nodes.containsKey(target.id()));\n\n\t\t\t\tvar parallelNodeEdges = parallelNodeStream.get()\n\t\t\t\t\t.map(target -> new Edge(target.id()))\n\t\t\t\t\t.filter(ee -> processedData.edges().elements.contains(ee))\n\t\t\t\t\t.map(ee -> processedData.edges().elements.indexOf(ee))\n\t\t\t\t\t.map(index -> processedData.edges().elements.get(index))\n\t\t\t\t\t.toList();\n\n\t\t\t\tvar parallelNodeTargets = parallelNodeEdges.stream()\n\t\t\t\t\t.map(ee -> ee.target().id())\n\t\t\t\t\t.collect(Collectors.toSet());\n\n\t\t\t\tif (parallelNodeTargets.size() > 1) {\n\n\t\t\t\t\tvar conditionalEdges = parallelNodeEdges.stream()\n\t\t\t\t\t\t.filter(ee -> ee.target().value() != null)\n\t\t\t\t\t\t.toList();\n\t\t\t\t\tif (!conditionalEdges.isEmpty()) {\n\t\t\t\t\t\tthrow Errors.unsupportedConditionalEdgeOnParallelNode.exception(e.sourceId(),\n\t\t\t\t\t\t\t\tconditionalEdges.stream().map(Edge::sourceId).toList());\n\t\t\t\t\t}\n\t\t\t\t\tthrow Errors.illegalMultipleTargetsOnParallelNode.exception(e.sourceId(), parallelNodeTargets);\n\t\t\t\t}\n\n\t\t\t\tvar actions = parallelNodeStream.get()\n\t\t\t\t\t// .map( target -> nodes.remove(target.id()) )\n\t\t\t\t\t.map(target -> nodes.get(target.id()))\n\t\t\t\t\t.toList();\n\n\t\t\t\tvar parallelNode = new ParallelNode(e.sourceId(), actions, keyStrategyMap);\n\n\t\t\t\tnodes.put(parallelNode.id(), parallelNode.actionFactory().apply(compileConfig));\n\n\t\t\t\tedges.put(e.sourceId(), new EdgeValue(parallelNode.id()));\n\n\t\t\t\tedges.put(parallelNode.id(), new EdgeValue(parallelNodeTargets.iterator().next()));\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\tpublic Collection<StateSnapshot> getStateHistory(RunnableConfig config) {\n\t\tBaseCheckpointSaver saver = compileConfig.checkpointSaver()\n\t\t\t.orElseThrow(() -> (new IllegalStateException(\"Missing CheckpointSaver!\")));\n\n\t\treturn saver.list(config)\n\t\t\t.stream()\n\t\t\t.map(checkpoint -> StateSnapshot.of(keyStrategyMap, checkpoint, config, stateGraph.getStateFactory()))\n\t\t\t.collect(toList());\n\t}\n\n\t/**\n\t * Same of {@link #stateOf(RunnableConfig)} but throws an IllegalStateException if\n\t * checkpoint is not found.\n\t * @param config the RunnableConfig\n\t * @return the StateSnapshot of the given RunnableConfig\n\t * @throws IllegalStateException if the saver is not defined, or no checkpoint is\n\t * found\n\t */\n\tpublic StateSnapshot getState(RunnableConfig config) {\n\t\treturn stateOf(config).orElseThrow(() -> (new IllegalStateException(\"Missing Checkpoint!\")));\n\t}\n\n\t/**\n\t * Get the StateSnapshot of the given RunnableConfig.\n\t * @param config the RunnableConfig\n\t * @return an Optional of StateSnapshot of the given RunnableConfig\n\t * @throws IllegalStateException if the saver is not defined\n\t */\n\tpublic Optional<StateSnapshot> stateOf(RunnableConfig config) {\n\t\tBaseCheckpointSaver saver = compileConfig.checkpointSaver()\n\t\t\t.orElseThrow(() -> (new IllegalStateException(\"Missing CheckpointSaver!\")));\n\n\t\treturn saver.get(config)\n\t\t\t.map(checkpoint -> StateSnapshot.of(keyStrategyMap, checkpoint, config, stateGraph.getStateFactory()));\n\n\t}\n\n\t/**\n\t * Update the state of the graph with the given values. If asNode is given, it will be\n\t * used to determine the next node to run. If not given, the next node will be\n\t * determined by the state graph.\n\t * @param config the RunnableConfig containing the graph state\n\t * @param values the values to be updated\n\t * @param asNode the node id to be used for the next node. can be null\n\t * @return the updated RunnableConfig\n\t * @throws Exception when something goes wrong\n\t */\n\tpublic RunnableConfig updateState(RunnableConfig config, Map<String, Object> values, String asNode)\n\t\t\tthrows Exception {\n\t\tBaseCheckpointSaver saver = compileConfig.checkpointSaver()\n\t\t\t.orElseThrow(() -> (new IllegalStateException(\"Missing CheckpointSaver!\")));\n\n\t\t// merge values with checkpoint values\n\t\tCheckpoint branchCheckpoint = saver.get(config)\n\t\t\t.map(Checkpoint::new)\n\t\t\t.map(cp -> cp.updateState(values, keyStrategyMap))\n\t\t\t.orElseThrow(() -> (new IllegalStateException(\"Missing Checkpoint!\")));\n\n\t\tString nextNodeId = null;\n\t\tif (asNode != null) {\n\t\t\tvar nextNodeCommand = nextNodeId(asNode, branchCheckpoint.getState(), config);\n\n\t\t\tnextNodeId = nextNodeCommand.gotoNode();\n\t\t\tbranchCheckpoint = branchCheckpoint.updateState(nextNodeCommand.update(), keyStrategyMap);\n\n\t\t}\n\t\t// update checkpoint in saver\n\t\tRunnableConfig newConfig = saver.put(config, branchCheckpoint);\n\n\t\treturn RunnableConfig.builder(newConfig).checkPointId(branchCheckpoint.getId()).nextNode(nextNodeId).build();\n\t}\n\n\t/***\n\t * Update the state of the graph with the given values.\n\t * @param config the RunnableConfig containing the graph state\n\t * @param values the values to be updated\n\t * @return the updated RunnableConfig\n\t * @throws Exception when something goes wrong\n\t */\n\tpublic RunnableConfig updateState(RunnableConfig config, Map<String, Object> values) throws Exception {\n\t\treturn updateState(config, values, null);\n\t}\n\n\t/**\n\t * Sets the maximum number of iterations for the graph execution.\n\t * @param maxIterations the maximum number of iterations\n\t * @throws IllegalArgumentException if maxIterations is less than or equal to 0\n\t */\n\tpublic void setMaxIterations(int maxIterations) {\n\t\tif (maxIterations <= 0) {\n\t\t\tthrow new IllegalArgumentException(\"maxIterations must be > 0!\");\n\t\t}\n\t\tthis.maxIterations = maxIterations;\n\t}\n\n\tprivate Command nextNodeId(EdgeValue route, Map<String, Object> state, String nodeId, RunnableConfig config)\n\t\t\tthrows Exception {\n\n\t\tif (route == null) {\n\t\t\tthrow RunnableErrors.missingEdge.exception(nodeId);\n\t\t}\n\t\tif (route.id() != null) {\n\t\t\treturn new Command(route.id(), state);\n\t\t}\n\t\tif (route.value() != null) {\n\t\t\tOverAllState derefState = stateGraph.getStateFactory().apply(state);\n\n\t\t\tvar command = route.value().action().apply(derefState, config).get();\n\n\t\t\tvar newRoute = command.gotoNode();\n\n\t\t\tString result = route.value().mappings().get(newRoute);\n\t\t\tif (result == null) {\n\t\t\t\tthrow RunnableErrors.missingNodeInEdgeMapping.exception(nodeId, newRoute);\n\t\t\t}\n\n\t\t\tvar currentState = OverAllState.updateState(state, command.update(), keyStrategyMap);\n\n\t\t\treturn new Command(result, currentState);\n\t\t}\n\t\tthrow RunnableErrors.executionError.exception(format(\"invalid edge value for nodeId: [%s] !\", nodeId));\n\t}\n\n\t/**\n\t * Determines the next node ID based on the current node ID and state.\n\t * @param nodeId the current node ID\n\t * @param state the current state\n\t * @return the next node command\n\t * @throws Exception if there is an error determining the next node ID\n\t */\n\tprivate Command nextNodeId(String nodeId, Map<String, Object> state, RunnableConfig config) throws Exception {\n\t\treturn nextNodeId(edges.get(nodeId), state, nodeId, config);\n\n\t}\n\n\tprivate Command getEntryPoint(Map<String, Object> state, RunnableConfig config) throws Exception {\n\t\tvar entryPoint = this.edges.get(START);\n\t\treturn nextNodeId(entryPoint, state, \"entryPoint\", config);\n\t}\n\n\tprivate boolean shouldInterruptBefore(String nodeId, String previousNodeId) {\n\t\tif (previousNodeId == null) { // FIX RESUME ERROR\n\t\t\treturn false;\n\t\t}\n\t\treturn compileConfig.interruptsBefore().contains(nodeId);\n\t}\n\n\tprivate boolean shouldInterruptAfter(String nodeId, String previousNodeId) {\n\t\tif (nodeId == null) { // FIX RESUME ERROR\n\t\t\treturn false;\n\t\t}\n\t\treturn compileConfig.interruptsAfter().contains(nodeId);\n\t}\n\n\tprivate Optional<Checkpoint> addCheckpoint(RunnableConfig config, String nodeId, Map<String, Object> state,\n\t\t\tString nextNodeId) throws Exception {\n\t\tif (compileConfig.checkpointSaver().isPresent()) {\n\t\t\tvar cp = Checkpoint.builder().nodeId(nodeId).state(cloneState(state)).nextNodeId(nextNodeId).build();\n\t\t\tcompileConfig.checkpointSaver().get().put(config, cp);\n\t\t\treturn Optional.of(cp);\n\t\t}\n\t\treturn Optional.empty();\n\n\t}\n\n\t/**\n\t * Gets initial state.\n\t * @param inputs the inputs\n\t * @param config the config\n\t * @return the initial state\n\t */\n\tMap<String, Object> getInitialState(Map<String, Object> inputs, RunnableConfig config) {\n\n\t\treturn compileConfig.checkpointSaver()\n\t\t\t.flatMap(saver -> saver.get(config))\n\t\t\t.map(cp -> OverAllState.updateState(cp.getState(), inputs, keyStrategyMap))\n\t\t\t.orElseGet(() -> OverAllState.updateState(new HashMap<>(), inputs, keyStrategyMap));\n\t}\n\n\t/**\n\t * Clone state over all state.\n\t * @param data the data\n\t * @return the over all state\n\t */\n\tOverAllState cloneState(Map<String, Object> data) throws IOException, ClassNotFoundException {\n\t\treturn stateGraph.getStateSerializer().cloneObject(data);\n\t}\n\n\t/**\n\t * Creates an AsyncGenerator stream of NodeOutput based on the provided inputs.\n\t * @param inputs the input map\n\t * @param config the invoke configuration\n\t * @return an AsyncGenerator stream of NodeOutput\n\t */\n\tpublic AsyncGenerator<NodeOutput> stream(Map<String, Object> inputs, RunnableConfig config)\n\t\t\tthrows GraphRunnerException {\n\t\tObjects.requireNonNull(config, \"config cannot be null\");\n\t\tfinal AsyncNodeGenerator<NodeOutput> generator = new AsyncNodeGenerator<>(stateCreate(inputs), config);\n\n\t\treturn new AsyncGenerator.WithEmbed<>(generator);\n\t}\n\n\t/**\n\t * Stream async generator.\n\t * @param overAllState the over all state\n\t * @param config the config\n\t * @return the async generator\n\t */\n\tpublic AsyncGenerator<NodeOutput> streamFromInitialNode(OverAllState overAllState, RunnableConfig config)\n\t\t\tthrows GraphRunnerException {\n\t\tObjects.requireNonNull(config, \"config cannot be null\");\n\t\tfinal AsyncNodeGenerator<NodeOutput> generator = new AsyncNodeGenerator<>(overAllState, config);\n\n\t\treturn new AsyncGenerator.WithEmbed<>(generator);\n\t}\n\n\t/**\n\t * Creates an AsyncGenerator stream of NodeOutput based on the provided inputs.\n\t * @param inputs the input map\n\t * @return an AsyncGenerator stream of NodeOutput\n\t */\n\tpublic AsyncGenerator<NodeOutput> stream(Map<String, Object> inputs) throws GraphRunnerException {\n\t\treturn this.streamFromInitialNode(stateCreate(inputs), RunnableConfig.builder().build());\n\t}\n\n\t/**\n\t * Stream async generator.\n\t * @return the async generator\n\t */\n\tpublic AsyncGenerator<NodeOutput> stream() throws GraphRunnerException {\n\t\treturn this.stream(Map.of(), RunnableConfig.builder().build());\n\t}\n\n\t/**\n\t * Invokes the graph execution with the provided inputs and returns the final state.\n\t * @param inputs the input map\n\t * @param config the invoke configuration\n\t * @return an Optional containing the final state if present, otherwise an empty\n\t * Optional\n\t */\n\tpublic Optional<OverAllState> invoke(Map<String, Object> inputs, RunnableConfig config)\n\t\t\tthrows GraphRunnerException {\n\t\treturn stream(inputs, config).stream().reduce((a, b) -> b).map(NodeOutput::state);\n\t}\n\n\t/**\n\t * Invoke optional.\n\t * @param overAllState the over all state\n\t * @param config the config\n\t * @return the optional\n\t */\n\tpublic Optional<OverAllState> invoke(OverAllState overAllState, RunnableConfig config) throws GraphRunnerException {\n\t\treturn streamFromInitialNode(overAllState, config).stream().reduce((a, b) -> b).map(NodeOutput::state);\n\t}\n\n\t/**\n\t * Invokes the graph execution with the provided inputs and returns the final state.\n\t * @param inputs the input map\n\t * @return an Optional containing the final state if present, otherwise an empty\n\t * Optional\n\t */\n\tpublic Optional<OverAllState> invoke(Map<String, Object> inputs) throws GraphRunnerException {\n\t\treturn this.invoke(stateCreate(inputs), RunnableConfig.builder().build());\n\t}\n\n\tprivate OverAllState stateCreate(Map<String, Object> inputs) {\n\t\t// Creates a new OverAllState instance based on the presence of an\n\t\t// OverAllStateFactory in the stateGraph.\n\t\t// If no factory is present, constructs a new state using key strategies from\n\t\t// the\n\t\t// graph and provided input data.\n\t\t// If a factory exists, uses it to create the state and applies the input data.\n\t\treturn Objects.isNull(stateGraph.getOverAllStateFactory()) ? OverAllStateBuilder.builder()\n\t\t\t.withKeyStrategies(stateGraph.getKeyStrategyFactory().apply())\n\t\t\t.withData(inputs)\n\t\t\t.build() : stateGraph.getOverAllStateFactory().create().input(inputs);\n\t}\n\n\t/**\n\t * Experimental API\n\t * @param feedback the feedback\n\t * @param config the config\n\t * @return the optional\n\t */\n\tpublic Optional<OverAllState> resume(OverAllState.HumanFeedback feedback, RunnableConfig config)\n\t\t\tthrows GraphRunnerException {\n\t\tStateSnapshot stateSnapshot = this.getState(config);\n\t\tOverAllState resumeState = stateCreate(stateSnapshot.state().data());\n\t\tresumeState.withResume();\n\t\tresumeState.withHumanFeedback(feedback);\n\n\t\treturn this.invoke(resumeState, config);\n\t}\n\n\t/**\n\t * Creates an AsyncGenerator stream of NodeOutput based on the provided inputs.\n\t * @param inputs the input map\n\t * @param config the invoke configuration\n\t * @return an AsyncGenerator stream of NodeOutput\n\t */\n\tpublic AsyncGenerator<NodeOutput> streamSnapshots(Map<String, Object> inputs, RunnableConfig config)\n\t\t\tthrows GraphRunnerException {\n\t\tObjects.requireNonNull(config, \"config cannot be null\");\n\n\t\tfinal AsyncNodeGenerator<NodeOutput> generator = new AsyncNodeGenerator<>(stateCreate(inputs),\n\t\t\t\tconfig.withStreamMode(StreamMode.SNAPSHOTS));\n\n\t\treturn new AsyncGenerator.WithEmbed<>(generator);\n\t}\n\n\t/**\n\t * Generates a drawable graph representation of the state graph.\n\t * @param type the type of graph representation to generate\n\t * @param title the title of the graph\n\t * @param printConditionalEdges whether to print conditional edges\n\t * @return a diagram code of the state graph\n\t */\n\tpublic GraphRepresentation getGraph(GraphRepresentation.Type type, String title, boolean printConditionalEdges) {\n\n\t\tString content = type.generator.generate(processedData.nodes(), processedData.edges(), title,\n\t\t\t\tprintConditionalEdges);\n\n\t\treturn new GraphRepresentation(type, content);\n\t}\n\n\t/**\n\t * Get the last StateSnapshot of the given RunnableConfig.\n\t * @param config - the RunnableConfig\n\t * @return the last StateSnapshot of the given RunnableConfig if any\n\t */\n\tOptional<StateSnapshot> lastStateOf(RunnableConfig config) {\n\t\treturn getStateHistory(config).stream().findFirst();\n\t}\n\n\t/**\n\t * Generates a drawable graph representation of the state graph.\n\t * @param type the type of graph representation to generate\n\t * @param title the title of the graph\n\t * @return a diagram code of the state graph\n\t */\n\tpublic GraphRepresentation getGraph(GraphRepresentation.Type type, String title) {\n\n\t\tString content = type.generator.generate(processedData.nodes(), processedData.edges(), title, true);\n\n\t\treturn new GraphRepresentation(type, content);\n\t}\n\n\t/**\n\t * Generates a drawable graph representation of the state graph with default title.\n\t * @param type the type of graph representation to generate\n\t * @return a diagram code of the state graph\n\t */\n\tpublic GraphRepresentation getGraph(GraphRepresentation.Type type) {\n\t\treturn getGraph(type, \"Graph Diagram\", true);\n\t}\n\n\t/**\n\t * Async Generator for streaming outputs.\n\t *\n\t * @param <Output> the type of the output\n\t */\n\tpublic class AsyncNodeGenerator<Output extends NodeOutput> implements AsyncGenerator<Output> {\n\n\t\t/**\n\t\t * The Current state.\n\t\t */\n\t\tMap<String, Object> currentState;\n\n\t\t/**\n\t\t * The Current node id.\n\t\t */\n\t\tString currentNodeId;\n\n\t\t/**\n\t\t * The Next node id.\n\t\t */\n\t\tString nextNodeId;\n\n\t\t/**\n\t\t * The Over all state.\n\t\t */\n\t\tOverAllState overAllState;\n\n\t\t/**\n\t\t * The Iteration.\n\t\t */\n\t\tint iteration = 0;\n\n\t\t/**\n\t\t * The Config.\n\t\t */\n\t\tRunnableConfig config;\n\n\t\t/**\n\t\t * The Resumed from embed.\n\t\t */\n\t\tboolean resumedFromEmbed = false;\n\n\t\t/**\n\t\t * Instantiates a new Async node generator.\n\t\t * @param overAllState the over all state\n\t\t * @param config the config\n\t\t */\n\t\tprotected AsyncNodeGenerator(OverAllState overAllState, RunnableConfig config) throws GraphRunnerException {\n\n\t\t\tif (overAllState.isResume()) {\n\n\t\t\t\tlog.trace(\"RESUME REQUEST\");\n\n\t\t\t\tBaseCheckpointSaver saver = compileConfig.checkpointSaver()\n\t\t\t\t\t.orElseThrow(() -> (new IllegalStateException(\n\t\t\t\t\t\t\t\"inputs cannot be null (ie. resume request) if no checkpoint saver is configured\")));\n\t\t\t\tCheckpoint startCheckpoint = saver.get(config)\n\t\t\t\t\t.orElseThrow(() -> (new IllegalStateException(\"Resume request without a saved checkpoint!\")));\n\n\t\t\t\tthis.currentState = startCheckpoint.getState();\n\n\t\t\t\t// Reset checkpoint id\n\t\t\t\tthis.config = config.withCheckPointId(null);\n\t\t\t\tthis.overAllState = overAllState.input(this.currentState);\n\t\t\t\tthis.nextNodeId = startCheckpoint.getNextNodeId();\n\t\t\t\tthis.currentNodeId = null;\n\t\t\t\tlog.trace(\"RESUME FROM {}\", startCheckpoint.getNodeId());\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tlog.trace(\"START\");\n\t\t\t\tMap<String, Object> inputs = overAllState.data();\n\t\t\t\tboolean verify = overAllState.keyVerify();\n\t\t\t\tif (!CollectionUtils.isEmpty(inputs) && !verify) {\n\t\t\t\t\tthrow RunnableErrors.initializationError.exception(Arrays.toString(inputs.keySet().toArray()));\n\t\t\t\t}\n\t\t\t\t// patch for backward support of AppendableValue\n\t\t\t\tthis.currentState = getInitialState(inputs, config);\n\t\t\t\tthis.overAllState = overAllState.input(currentState);\n\t\t\t\tthis.nextNodeId = null;\n\t\t\t\tthis.currentNodeId = START;\n\t\t\t\tthis.config = config;\n\t\t\t}\n\t\t}\n\n\t\tprivate Optional<BaseCheckpointSaver.Tag> releaseThread() throws Exception {\n\t\t\tif (compileConfig.releaseThread() && compileConfig.checkpointSaver().isPresent()) {\n\t\t\t\treturn Optional.of(compileConfig.checkpointSaver().get().release(config));\n\t\t\t}\n\t\t\treturn Optional.empty();\n\t\t}\n\n\t\t/**\n\t\t * Build node output output.\n\t\t * @param nodeId the node id\n\t\t * @return the output\n\t\t */\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprotected Output buildNodeOutput(String nodeId) {\n\t\t\treturn (Output) NodeOutput.of(nodeId, cloneState(currentState));\n\t\t}\n\n\t\t/**\n\t\t * Clone state over all state.\n\t\t * @param data the data\n\t\t * @return the over all state\n\t\t */\n\t\tOverAllState cloneState(Map<String, Object> data) {\n\t\t\treturn new OverAllState(data, keyStrategyMap, overAllState.isResume());\n\t\t}\n\n\t\t/**\n\t\t * Build state snapshot output.\n\t\t * @param checkpoint the checkpoint\n\t\t * @return the output\n\t\t */\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprotected Output buildStateSnapshot(Checkpoint checkpoint) {\n\t\t\treturn (Output) StateSnapshot.of(keyStrategyMap, checkpoint, config,\n\t\t\t\t\tstateGraph.getStateSerializer().stateFactory());\n\t\t}\n\n\t\t/**\n\t\t * Gets embed generator from partial state.\n\t\t * @param partialState the partial state containing generator instances\n\t\t * @return an Optional containing Data with the generator if found, empty\n\t\t * otherwise\n\t\t */\n\t\tprivate Optional<Data<Output>> getEmbedGenerator(Map<String, Object> partialState) {\n\t\t\t// Extract all AsyncGenerator instances\n\t\t\tList<AsyncGenerator<Output>> asyncNodeGenerators = new ArrayList<>();\n\t\t\tvar generatorEntries = partialState.entrySet().stream().filter(e -> {\n\t\t\t\t// Fixed when parallel nodes return asynchronous generating the same key\n\t\t\t\tObject value = e.getValue();\n\t\t\t\tif (value instanceof AsyncGenerator) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (value instanceof Collection collection) {\n\t\t\t\t\tcollection.forEach(o -> {\n\t\t\t\t\t\tif (o instanceof AsyncGenerator<?>) {\n\t\t\t\t\t\t\tasyncNodeGenerators.add((AsyncGenerator<Output>) o);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}).collect(Collectors.toList());\n\n\t\t\tif (generatorEntries.isEmpty() && asyncNodeGenerators.isEmpty()) {\n\t\t\t\treturn Optional.empty();\n\t\t\t}\n\n\t\t\t// Log information about found generators\n\t\t\tif (generatorEntries.size() > 1) {\n\t\t\t\tlog.debug(\"Multiple generators found: {} - keys: {}\", generatorEntries.size(),\n\t\t\t\t\t\tgeneratorEntries.stream().map(Map.Entry::getKey).collect(Collectors.joining(\", \")));\n\t\t\t}\n\n\t\t\t// Create appropriate generator (single or merged)\n\t\t\tAsyncGenerator<Output> generator = AsyncGeneratorUtils.createAppropriateGenerator(generatorEntries,\n\t\t\t\t\tasyncNodeGenerators, keyStrategyMap);\n\n\t\t\t// Create data processing logic for the generator\n\t\t\treturn Optional.of(Data.composeWith(generator.map(n -> {\n\t\t\t\tn.setSubGraph(true);\n\t\t\t\treturn n;\n\t\t\t}), data -> processGeneratorOutput(data, partialState, generatorEntries)));\n\t\t}\n\n\t\t/**\n\t\t * Processes output data from generator.\n\t\t * @param data output data from generator\n\t\t * @param partialState partial state\n\t\t * @param generatorEntries generator entries list\n\t\t * @throws Exception if an error occurs during processing\n\t\t */\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprivate void processGeneratorOutput(Object data, Map<String, Object> partialState,\n\t\t\t\tList<Map.Entry<String, Object>> generatorEntries) throws Exception {\n\t\t\t// Remove all generators\n\t\t\tMap<String, Object> partialStateWithoutGenerators = new HashMap<>();\n\t\t\tfor (Map.Entry<String, Object> entry : partialState.entrySet()) {\n\t\t\t\tif (entry.getValue() instanceof AsyncGenerator) {\n\t\t\t\t\tcontinue; // Skip top-level AsyncGenerator values\n\t\t\t\t}\n\n\t\t\t\tif (entry.getValue() instanceof Collection<?>) {\n\t\t\t\t\tCollection<?> collection = (Collection<?>) entry.getValue();\n\t\t\t\t\tArrayList<Object> filteredCollection = new ArrayList<>();\n\n\t\t\t\t\tfor (Object item : collection) {\n\t\t\t\t\t\tif (!(item instanceof AsyncGenerator)) {\n\t\t\t\t\t\t\tfilteredCollection.add(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!filteredCollection.isEmpty()) {\n\t\t\t\t\t\tpartialStateWithoutGenerators.put(entry.getKey(), filteredCollection);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Keep the entry if it's not an AsyncGenerator and not a collection\n\t\t\t\t\t// containing it\n\t\t\t\t\tpartialStateWithoutGenerators.put(entry.getKey(), entry.getValue());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update state with partial state without generators\n\t\t\tvar intermediateState = OverAllState.updateState(currentState, partialStateWithoutGenerators,\n\t\t\t\t\tkeyStrategyMap);\n\t\t\tcurrentState = intermediateState;\n\t\t\toverAllState.updateState(partialStateWithoutGenerators);\n\n\t\t\t// If data is not null and is a Map, update state with it\n\t\t\tif (data != null) {\n\t\t\t\tif (data instanceof Map<?, ?>) {\n\t\t\t\t\tcurrentState = OverAllState.updateState(intermediateState, (Map<String, Object>) data,\n\t\t\t\t\t\t\tkeyStrategyMap);\n\t\t\t\t\toverAllState.updateState((Map<String, Object>) data);\n\n\t\t\t\t\tif (log.isDebugEnabled() && generatorEntries.size() > 1) {\n\t\t\t\t\t\tlog.debug(\"Updated state with data keys: {}\",\n\t\t\t\t\t\t\t\t((Map<String, Object>) data).keySet().stream().collect(Collectors.joining(\", \")));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Embedded generator must return a Map\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Get next node command\n\t\t\tvar nextNodeCommand = nextNodeId(currentNodeId, overAllState, currentState, config);\n\t\t\tnextNodeId = nextNodeCommand.gotoNode();\n\t\t\tcurrentState = nextNodeCommand.update();\n\t\t\tresumedFromEmbed = true;\n\t\t}\n\n\t\tprivate CompletableFuture<Data<Output>> evaluateAction(AsyncNodeActionWithConfig action,\n\t\t\t\tOverAllState withState) {\n\t\t\tdoListeners(NODE_BEFORE, null);\n\t\t\treturn action.apply(withState, config).thenApply(updateState -> {\n\t\t\t\ttry {\n\t\t\t\t\tif (action instanceof CommandNode.AsyncCommandNodeActionWithConfig) {\n\t\t\t\t\t\tAsyncCommandAction commandAction = (AsyncCommandAction) updateState.get(\"command\");\n\t\t\t\t\t\tCommand command = commandAction.apply(withState, config).join();\n\n\t\t\t\t\t\tthis.currentState = OverAllState.updateState(currentState, command.update(), keyStrategyMap);\n\t\t\t\t\t\tthis.overAllState.updateState(command.update());\n\t\t\t\t\t\tnextNodeId = command.gotoNode();\n\t\t\t\t\t\treturn Data.of(getNodeOutput());\n\t\t\t\t\t}\n\n\t\t\t\t\tOptional<Data<Output>> embed = getEmbedGenerator(updateState);\n\t\t\t\t\tif (embed.isPresent()) {\n\t\t\t\t\t\treturn embed.get();\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.currentState = OverAllState.updateState(currentState, updateState, keyStrategyMap);\n\t\t\t\t\tthis.overAllState.updateState(updateState);\n\t\t\t\t\tvar nextNodeCommand = nextNodeId(currentNodeId, overAllState, currentState, config);\n\t\t\t\t\tnextNodeId = nextNodeCommand.gotoNode();\n\t\t\t\t\tthis.currentState = nextNodeCommand.update();\n\n\t\t\t\t\treturn Data.of(getNodeOutput());\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new CompletionException(e);\n\t\t\t\t}\n\t\t\t}).whenComplete((outputData, throwable) -> doListeners(NODE_AFTER, null));\n\t\t}\n\n\t\tprivate Command nextNodeId(String nodeId, OverAllState overAllState, Map<String, Object> state,\n\t\t\t\tRunnableConfig config) throws Exception {\n\t\t\tEdgeValue route = edges.get(nodeId);\n\n\t\t\tif (route == null) {\n\t\t\t\tthrow RunnableErrors.missingEdge.exception(nodeId);\n\t\t\t}\n\t\t\tif (route.id() != null) {\n\t\t\t\treturn new Command(route.id(), state);\n\t\t\t}\n\t\t\tif (route.value() != null) {\n\t\t\t\tvar command = route.value().action().apply(overAllState, config).get();\n\n\t\t\t\tvar newRoute = command.gotoNode();\n\n\t\t\t\tString result = route.value().mappings().get(newRoute);\n\t\t\t\tif (result == null) {\n\t\t\t\t\tthrow RunnableErrors.missingNodeInEdgeMapping.exception(nodeId, newRoute);\n\t\t\t\t}\n\n\t\t\t\tvar currentState = OverAllState.updateState(state, command.update(), keyStrategyMap);\n\n\t\t\t\toverAllState.updateState(command.update());\n\n\t\t\t\treturn new Command(result, currentState);\n\t\t\t}\n\t\t\tthrow RunnableErrors.executionError.exception(format(\"invalid edge value for nodeId: [%s] !\", nodeId));\n\t\t}\n\n\t\t/**\n\t\t * evaluate Action without nested support\n\t\t */\n\t\tprivate CompletableFuture<Output> evaluateActionWithoutNested(AsyncNodeAction action, OverAllState withState) {\n\n\t\t\treturn action.apply(withState).thenApply(partialState -> {\n\t\t\t\ttry {\n\t\t\t\t\tcurrentState = OverAllState.updateState(currentState, partialState, keyStrategyMap);\n\n\t\t\t\t\tvar nextNodeCommand = nextNodeId(currentNodeId, overAllState, currentState, config);\n\t\t\t\t\tnextNodeId = nextNodeCommand.gotoNode();\n\t\t\t\t\tcurrentState = nextNodeCommand.update();\n\n\t\t\t\t\tOptional<Checkpoint> cp = addCheckpoint(config, currentNodeId, currentState, nextNodeId);\n\t\t\t\t\treturn (cp.isPresent() && config.streamMode() == StreamMode.SNAPSHOTS)\n\t\t\t\t\t\t\t? buildStateSnapshot(cp.get()) : buildNodeOutput(currentNodeId);\n\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new CompletionException(e);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tprivate CompletableFuture<Output> getNodeOutput() throws Exception {\n\t\t\tOptional<Checkpoint> cp = addCheckpoint(config, currentNodeId, currentState, nextNodeId);\n\t\t\treturn completedFuture((cp.isPresent() && config.streamMode() == StreamMode.SNAPSHOTS)\n\t\t\t\t\t? buildStateSnapshot(cp.get()) : buildNodeOutput(currentNodeId));\n\t\t}\n\n\t\t@Override\n\t\tpublic Data<Output> next() {\n\t\t\ttry {\n\t\t\t\t// GUARD: CHECK MAX ITERATION REACHED\n\t\t\t\tif (++iteration > maxIterations) {\n\t\t\t\t\t// log.warn( \"Maximum number of iterations ({}) reached!\",\n\t\t\t\t\t// maxIterations);\n\t\t\t\t\treturn Data.error(new IllegalStateException(\n\t\t\t\t\t\t\tformat(\"Maximum number of iterations (%d) reached!\", maxIterations)));\n\t\t\t\t}\n\n\t\t\t\t// GUARD: CHECK IF IT IS END\n\t\t\t\tif (nextNodeId == null && currentNodeId == null) {\n\t\t\t\t\treturn releaseThread().map(Data::<Output>done).orElseGet(() -> Data.done(currentState));\n\t\t\t\t}\n\n\t\t\t\t// IS IT A RESUME FROM EMBED ?\n\t\t\t\tif (resumedFromEmbed) {\n\t\t\t\t\tfinal CompletableFuture<Output> future = getNodeOutput();\n\t\t\t\t\tresumedFromEmbed = false;\n\t\t\t\t\treturn Data.of(future);\n\t\t\t\t}\n\n\t\t\t\tif (START.equals(currentNodeId)) {\n\t\t\t\t\tdoListeners(START, null);\n\t\t\t\t\tvar nextNodeCommand = getEntryPoint(currentState, config);\n\t\t\t\t\tnextNodeId = nextNodeCommand.gotoNode();\n\t\t\t\t\tcurrentState = nextNodeCommand.update();\n\n\t\t\t\t\tvar cp = addCheckpoint(config, START, currentState, nextNodeId);\n\n\t\t\t\t\tvar output = (cp.isPresent() && config.streamMode() == StreamMode.SNAPSHOTS)\n\t\t\t\t\t\t\t? buildStateSnapshot(cp.get()) : buildNodeOutput(currentNodeId);\n\n\t\t\t\t\tcurrentNodeId = nextNodeId;\n\n\t\t\t\t\treturn Data.of(output);\n\t\t\t\t}\n\n\t\t\t\tif (END.equals(nextNodeId)) {\n\t\t\t\t\tnextNodeId = null;\n\t\t\t\t\tcurrentNodeId = null;\n\t\t\t\t\tdoListeners(END, null);\n\t\t\t\t\treturn Data.of(buildNodeOutput(END));\n\t\t\t\t}\n\n\t\t\t\t// check on previous node\n\t\t\t\tif (shouldInterruptAfter(currentNodeId, nextNodeId)) {\n\t\t\t\t\treturn Data.done(currentNodeId);\n\t\t\t\t}\n\n\t\t\t\tif (shouldInterruptBefore(nextNodeId, currentNodeId)) {\n\t\t\t\t\treturn Data.done(nextNodeId);\n\t\t\t\t}\n\n\t\t\t\tcurrentNodeId = nextNodeId;\n\n\t\t\t\tvar action = nodes.get(currentNodeId);\n\n\t\t\t\tif (action == null)\n\t\t\t\t\tthrow RunnableErrors.missingNode.exception(currentNodeId);\n\n\t\t\t\treturn evaluateAction(action, this.overAllState).get();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tdoListeners(ERROR, e);\n\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\treturn Data.error(e);\n\t\t\t}\n\t\t}\n\n\t\tprivate void doListeners(String scene, Exception e) {\n\t\t\tDeque<GraphLifecycleListener> listeners = new LinkedBlockingDeque<>(compileConfig.lifecycleListeners());\n\n\t\t\tprocessListenersLIFO(listeners, scene, e);\n\t\t}\n\n\t\tprivate void processListenersLIFO(Deque<GraphLifecycleListener> listeners, String scene, Exception e) {\n\t\t\tif (listeners.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tGraphLifecycleListener listener = listeners.pollLast();\n\n\t\t\ttry {\n\t\t\t\tif (START.equals(scene)) {\n\t\t\t\t\tlistener.onStart(START, this.currentState, this.config);\n\t\t\t\t}\n\t\t\t\telse if (END.equals(scene)) {\n\t\t\t\t\tlistener.onComplete(END, this.currentState, this.config);\n\t\t\t\t}\n\t\t\t\telse if (ERROR.equals(scene)) {\n\t\t\t\t\tlistener.onError(this.currentNodeId, this.currentState, e, this.config);\n\t\t\t\t}\n\t\t\t\telse if (NODE_BEFORE.equals(scene)) {\n\t\t\t\t\tlistener.before(this.currentNodeId, this.currentState, this.config, SystemClock.now());\n\t\t\t\t}\n\t\t\t\telse if (NODE_AFTER.equals(scene)) {\n\t\t\t\t\tlistener.after(this.currentNodeId, this.currentState, this.config, SystemClock.now());\n\t\t\t\t}\n\n\t\t\t\tprocessListenersLIFO(listeners, scene, e);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlog.debug(\"Error occurred during listener processing: {}\", ex.getMessage());\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\n/**\n * The type Processed nodes edges and config.\n */\nrecord ProcessedNodesEdgesAndConfig(StateGraph.Nodes nodes, StateGraph.Edges edges, Set<String> interruptsBefore,\n\t\tSet<String> interruptsAfter) {\n\n\t/**\n\t * Instantiates a new Processed nodes edges and config.\n\t * @param stateGraph the state graph\n\t * @param config the config\n\t */\n\tProcessedNodesEdgesAndConfig(StateGraph stateGraph, CompileConfig config) {\n\t\tthis(stateGraph.nodes, stateGraph.edges, config.interruptsBefore(), config.interruptsAfter());\n\t}\n\n\t/**\n\t * Process processed nodes edges and config.\n\t * @param stateGraph the state graph\n\t * @param config the config\n\t * @return the processed nodes edges and config\n\t * @throws GraphStateException the graph state exception\n\t */\n\tstatic ProcessedNodesEdgesAndConfig process(StateGraph stateGraph, CompileConfig config)\n\t\t\tthrows GraphStateException {\n\n\t\tvar subgraphNodes = stateGraph.nodes.onlySubStateGraphNodes();\n\n\t\tif (subgraphNodes.isEmpty()) {\n\t\t\treturn new ProcessedNodesEdgesAndConfig(stateGraph, config);\n\t\t}\n\n\t\tvar interruptsBefore = config.interruptsBefore();\n\t\tvar interruptsAfter = config.interruptsAfter();\n\t\tvar nodes = new StateGraph.Nodes(stateGraph.nodes.exceptSubStateGraphNodes());\n\t\tvar edges = new StateGraph.Edges(stateGraph.edges.elements);\n\n\t\tfor (var subgraphNode : subgraphNodes) {\n\n\t\t\tvar sgWorkflow = subgraphNode.subGraph();\n\n\t\t\tProcessedNodesEdgesAndConfig processedSubGraph = process(sgWorkflow, config);\n\t\t\tStateGraph.Nodes processedSubGraphNodes = processedSubGraph.nodes;\n\t\t\tStateGraph.Edges processedSubGraphEdges = processedSubGraph.edges;\n\n\t\t\t//\n\t\t\t// Process START Node\n\t\t\t//\n\t\t\tvar sgEdgeStart = processedSubGraphEdges.edgeBySourceId(START).orElseThrow();\n\n\t\t\tif (sgEdgeStart.isParallel()) {\n\t\t\t\tthrow new GraphStateException(\"subgraph not support start with parallel branches yet!\");\n\t\t\t}\n\n\t\t\tvar sgEdgeStartTarget = sgEdgeStart.target();\n\n\t\t\tif (sgEdgeStartTarget.id() == null) {\n\t\t\t\tthrow new GraphStateException(format(\"the target for node '%s' is null!\", subgraphNode.id()));\n\t\t\t}\n\n\t\t\tvar sgEdgeStartRealTargetId = subgraphNode.formatId(sgEdgeStartTarget.id());\n\n\t\t\t// Process Interruption (Before) Subgraph(s)\n\t\t\tinterruptsBefore = interruptsBefore.stream()\n\t\t\t\t.map(interrupt -> Objects.equals(subgraphNode.id(), interrupt) ? sgEdgeStartRealTargetId : interrupt)\n\t\t\t\t.collect(Collectors.toUnmodifiableSet());\n\n\t\t\tvar edgesWithSubgraphTargetId = edges.edgesByTargetId(subgraphNode.id());\n\n\t\t\tif (edgesWithSubgraphTargetId.isEmpty()) {\n\t\t\t\tthrow new GraphStateException(\n\t\t\t\t\t\tformat(\"the node '%s' is not present as target in graph!\", subgraphNode.id()));\n\t\t\t}\n\n\t\t\tfor (var edgeWithSubgraphTargetId : edgesWithSubgraphTargetId) {\n\n\t\t\t\tvar newEdge = edgeWithSubgraphTargetId.withSourceAndTargetIdsUpdated(subgraphNode, Function.identity(),\n\t\t\t\t\t\tid -> new EdgeValue((Objects.equals(id, subgraphNode.id())\n\t\t\t\t\t\t\t\t? subgraphNode.formatId(sgEdgeStartTarget.id()) : id)));\n\t\t\t\tedges.elements.remove(edgeWithSubgraphTargetId);\n\t\t\t\tedges.elements.add(newEdge);\n\t\t\t}\n\t\t\t//\n\t\t\t// Process END Nodes\n\t\t\t//\n\t\t\tvar sgEdgesEnd = processedSubGraphEdges.edgesByTargetId(END);\n\n\t\t\tvar edgeWithSubgraphSourceId = edges.edgeBySourceId(subgraphNode.id()).orElseThrow();\n\n\t\t\tif (edgeWithSubgraphSourceId.isParallel()) {\n\t\t\t\tthrow new GraphStateException(\"subgraph not support routes to parallel branches yet!\");\n\t\t\t}\n\n\t\t\t// Process Interruption (After) Subgraph(s)\n\t\t\tif (interruptsAfter.contains(subgraphNode.id())) {\n\n\t\t\t\tvar exceptionMessage = (edgeWithSubgraphSourceId.target()\n\t\t\t\t\t.id() == null) ? \"'interruption after' on subgraph is not supported yet!\" : format(\n\t\t\t\t\t\t\t\"'interruption after' on subgraph is not supported yet! consider to use 'interruption before' node: '%s'\",\n\t\t\t\t\t\t\tedgeWithSubgraphSourceId.target().id());\n\t\t\t\tthrow new GraphStateException(exceptionMessage);\n\t\t\t}\n\n\t\t\tsgEdgesEnd.stream()\n\t\t\t\t.map(e -> e.withSourceAndTargetIdsUpdated(subgraphNode, subgraphNode::formatId,\n\t\t\t\t\t\tid -> (Objects.equals(id, END) ? edgeWithSubgraphSourceId.target()\n\t\t\t\t\t\t\t\t: new EdgeValue(subgraphNode.formatId(id)))))\n\t\t\t\t.forEach(edges.elements::add);\n\t\t\tedges.elements.remove(edgeWithSubgraphSourceId);\n\n\t\t\t//\n\t\t\t// Process edges\n\t\t\t//\n\t\t\tprocessedSubGraphEdges.elements.stream()\n\t\t\t\t.filter(e -> !Objects.equals(e.sourceId(), START))\n\t\t\t\t.filter(e -> !e.anyMatchByTargetId(END))\n\t\t\t\t.map(e -> e.withSourceAndTargetIdsUpdated(subgraphNode, subgraphNode::formatId,\n\t\t\t\t\t\tid -> new EdgeValue(subgraphNode.formatId(id))))\n\t\t\t\t.forEach(edges.elements::add);\n\n\t\t\t//\n\t\t\t// Process nodes\n\t\t\t//\n\t\t\tprocessedSubGraphNodes.elements.stream().map(n -> {\n\t\t\t\tif (n instanceof CommandNode commandNode) {\n\t\t\t\t\tMap<String, String> mappings = commandNode.getMappings();\n\t\t\t\t\tHashMap<String, String> newMappings = new HashMap<>();\n\t\t\t\t\tmappings.forEach((key, value) -> {\n\t\t\t\t\t\tnewMappings.put(key, subgraphNode.formatId(value));\n\t\t\t\t\t});\n\t\t\t\t\treturn new CommandNode(subgraphNode.formatId(n.id()),\n\t\t\t\t\t\t\tAsyncCommandAction.node_async((state, config1) -> {\n\t\t\t\t\t\t\t\tCommand command = commandNode.getAction().apply(state, config1).join();\n\t\t\t\t\t\t\t\tString NewGoToNode = subgraphNode.formatId(command.gotoNode());\n\t\t\t\t\t\t\t\treturn new Command(NewGoToNode, command.update());\n\t\t\t\t\t\t\t}), newMappings);\n\t\t\t\t}\n\t\t\t\treturn n.withIdUpdated(subgraphNode::formatId);\n\t\t\t}).forEach(nodes.elements::add);\n\t\t}\n\n\t\treturn new ProcessedNodesEdgesAndConfig(nodes, edges, interruptsBefore, interruptsAfter);\n\t}\n}", "metadata": {"commit_sha": "55ab9900", "lines_added": 8, "lines_deleted": 4, "total_changes": 12, "chunks": 3}}
{"id": 22, "pattern_type": "import_statement", "file_path": "spring-ai-alibaba-examples/playground-flight-booking/src/main/java/ai/spring/demo/ai/playground/Application.java", "file_extension": "java", "input": "package ai.spring.demo.ai.playground;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.ai.chat.memory.ChatMemory;\nimport org.springframework.ai.chat.memory.InMemoryChatMemory;\nimport org.springframework.ai.embedding.EmbeddingModel;\nimport org.springframework.ai.reader.TextReader;\nimport org.springframework.ai.transformer.splitter.TokenTextSplitter;\nimport org.springframework.ai.vectorstore.SimpleVectorStore;\nimport org.springframework.ai.vectorstore.VectorStore;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.builder.SpringApplicationBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.core.io.Resource;\n\n\n@SpringBootApplication\npublic class Application  {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(Application.class);\n\n\tpublic static void main(String[] args) {\n\t\tnew SpringApplicationBuilder(Application.class).run(args);\n\t}\n\n\t// In the real world, ingesting documents would often happen separately, on a CI\n\t// server or similar.\n\t@Bean\n\tCommandLineRunner ingestTermOfServiceToVectorStore(EmbeddingModel embeddingModel, VectorStore vectorStore,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   @Value(\"classpath:rag/terms-of-service.txt\") Resource termsOfServiceDocs) {\n\n\t\treturn args -> {\n\t\t\t// Ingest the document into the vector store\n\t\t\tvectorStore.write(new TokenTextSplitter().transform(new TextReader(termsOfServiceDocs).read()));\n\n\t\t\tvectorStore.similaritySearch(\"Cancelling Bookings\").forEach(doc -> {\n\t\t\t\tlogger.info(\"Similar Document: {}\", doc.getContent());\n\t\t\t});\n\t\t};\n\t}\n\n\t@Bean\n\tpublic VectorStore vectorStore(EmbeddingModel embeddingModel) {\n\t\treturn new SimpleVectorStore(embeddingModel);\n\t}\n\n\t@Bean\n\tpublic ChatMemory chatMemory() {\n\t\treturn new InMemoryChatMemory();\n\t}\n\n}", "output": "package ai.spring.demo.ai.playground;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.ai.chat.memory.ChatMemory;\nimport org.springframework.ai.chat.memory.InMemoryChatMemory;\nimport org.springframework.ai.embedding.EmbeddingModel;\nimport org.springframework.ai.reader.TextReader;\nimport org.springframework.ai.transformer.splitter.TokenTextSplitter;\nimport org.springframework.ai.vectorstore.SimpleVectorStore;\nimport org.springframework.ai.vectorstore.VectorStore;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.builder.SpringApplicationBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.core.io.Resource;\nimport org.springframework.web.client.RestClient;\n\n\n@SpringBootApplication\npublic class Application  {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(Application.class);\n\n\tpublic static void main(String[] args) {\n\t\tnew SpringApplicationBuilder(Application.class).run(args);\n\t}\n\n\t// In the real world, ingesting documents would often happen separately, on a CI\n\t// server or similar.\n\t@Bean\n\tCommandLineRunner ingestTermOfServiceToVectorStore(EmbeddingModel embeddingModel, VectorStore vectorStore,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   @Value(\"classpath:rag/terms-of-service.txt\") Resource termsOfServiceDocs) {\n\n\t\treturn args -> {\n\t\t\t// Ingest the document into the vector store\n\t\t\tvectorStore.write(new TokenTextSplitter().transform(new TextReader(termsOfServiceDocs).read()));\n\n\t\t\tvectorStore.similaritySearch(\"Cancelling Bookings\").forEach(doc -> {\n\t\t\t\tlogger.info(\"Similar Document: {}\", doc.getContent());\n\t\t\t});\n\t\t};\n\t}\n\n\t@Bean\n\tpublic VectorStore vectorStore(EmbeddingModel embeddingModel) {\n\t\treturn new SimpleVectorStore(embeddingModel);\n\t}\n\n\t@Bean\n\tpublic ChatMemory chatMemory() {\n\t\treturn new InMemoryChatMemory();\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic RestClient.Builder restClientBuilder() {\n\t\treturn RestClient.builder();\n\t}\n}", "metadata": {"commit_sha": "36a909e2", "lines_added": 7, "lines_deleted": 0, "total_changes": 7, "chunks": 2}}
{"id": 36, "pattern_type": "getter_setter", "file_path": "community/document-readers/gitlab-document-reader/src/test/java/com/alibaba/cloud/ai/reader/gitlab/GitLabIssueReaderTest.java", "file_extension": "java", "input": "/*\n * Copyright 2024-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.reader.gitlab;\n\nimport org.gitlab4j.api.GitLabApiException;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.ai.document.Document;\n\nimport java.time.LocalDateTime;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Test cases for GitLabIssueReader. Using real issues from Spring AI project\n * (https://gitlab.com/spring-ai/spring-ai).\n *\n * @author brianxiadong\n */\nclass GitLabIssueReaderTest {\n\n\tprivate static final String TEST_HOST_URL = \"https://gitlab.com\";\n\n\tprivate static final String TEST_NAMESPACE = \"\";\n\n\tprivate static final String TEST_PROJECT_NAME = \"\";\n\n\tprivate GitLabIssueReader reader;\n\n\t@BeforeEach\n\tvoid setUp() throws GitLabApiException {\n\t\t// Create GitLabIssueReader instance for accessing public project\n\t\treader = new GitLabIssueReader(TEST_HOST_URL, TEST_NAMESPACE, TEST_PROJECT_NAME);\n\t}\n\n\t@Test\n\tvoid testGetIssuesWithDefaultParameters() {\n\t\t// Get all open issues directly\n\t\tList<Document> documents = reader.get();\n\n\t\t// Verify results\n\t\tassertThat(documents).isNotEmpty();\n\n\t\t// Verify basic structure of first document\n\t\tDocument doc = documents.get(0);\n\t\tassertThat(doc.getId()).isNotNull();\n\t\tassertThat(doc.getContent()).isNotBlank();\n\t\tassertThat(doc.getMetadata()).containsKey(\"state\").containsKey(\"url\");\n\n\t\t// Verify default state is OPEN\n\t\tassertThat(doc.getMetadata().get(\"state\")).isEqualTo(\"opened\");\n\t}\n\n\t@Test\n\tvoid testLoadDataWithCustomParameters() throws GitLabApiException {\n\t\t// Create new reader instance with custom parameters\n\t\tGitLabIssueConfig config = GitLabIssueConfig.builder()\n\t\t\t.confidential(false)\n\t\t\t.createdAfter(LocalDateTime.now().minusDays(365))\n\t\t\t.issueType(GitLabIssueType.ISSUE)\n\t\t\t.labels(Arrays.asList(\"enhancement\", \"feature\"))\n\t\t\t.nonArchived(true)\n\t\t\t.scope(GitLabScope.ALL)\n\t\t\t.state(GitLabIssueState.CLOSED)\n\t\t\t.build();\n\n\t\treader = new GitLabIssueReader(TEST_HOST_URL, TEST_NAMESPACE, TEST_PROJECT_NAME, null, config);\n\n\t\t// Get issues\n\t\tList<Document> documents = reader.get();\n\n\t\t// Verify results\n\t\tassertThat(documents).isNotEmpty();\n\n\t\t// Verify all documents match our filter criteria\n\t\tfor (Document doc : documents) {\n\t\t\tassertThat(doc.getMetadata()).containsEntry(\"state\", \"closed\").hasEntrySatisfying(\"labels\", labels -> {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tList<String> labelList = (List<String>) labels;\n\t\t\t\tassertThat(labelList).containsAnyOf(\"enhancement\", \"feature\");\n\t\t\t}).containsKey(\"url\");\n\n\t\t\t// Verify document content\n\t\t\tassertThat(doc.getId()).isNotNull();\n\t\t\tassertThat(doc.getContent()).isNotBlank();\n\t\t}\n\t}\n\n\t@Test\n\tvoid testLoadSpecificIssue() throws GitLabApiException {\n\t\t// Create configuration to get specific issue\n\t\tGitLabIssueConfig config = GitLabIssueConfig.builder().iids(Arrays.asList(1)).build();\n\n\t\treader = new GitLabIssueReader(TEST_HOST_URL, TEST_NAMESPACE, TEST_PROJECT_NAME, null, config);\n\n\t\t// Get specific issue (#1)\n\t\tList<Document> documents = reader.get();\n\n\t\t// Verify results\n\t\tassertThat(documents).hasSize(1);\n\t\tDocument doc = documents.get(0);\n\t\tassertThat(doc.getId()).isEqualTo(\"1\");\n\t\tassertThat(doc.getMetadata()).containsKey(\"state\").containsKey(\"url\");\n\t}\n\n}", "output": "/*\n * Copyright 2024-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.reader.gitlab;\n\nimport org.gitlab4j.api.GitLabApiException;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.ai.document.Document;\n\nimport java.time.LocalDateTime;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Test cases for GitLabIssueReader. Using real issues from Spring AI project\n * (https://gitlab.com/spring-ai/spring-ai).\n *\n * @author brianxiadong\n */\nclass GitLabIssueReaderTest {\n\n\tprivate static final String TEST_HOST_URL = \"https://gitlab.com\";\n\n\tprivate static final String TEST_NAMESPACE = \"\";\n\n\tprivate static final String TEST_PROJECT_NAME = \"\";\n\n\tprivate GitLabIssueReader reader;\n\n\t@BeforeEach\n\tvoid setUp() throws GitLabApiException {\n\t\t// Create GitLabIssueReader instance for accessing public project\n\t\treader = new GitLabIssueReader(TEST_HOST_URL, TEST_NAMESPACE, TEST_PROJECT_NAME);\n\t}\n\n\t@Test\n\tvoid testGetIssuesWithDefaultParameters() {\n\t\t// Get all open issues directly\n\t\tList<Document> documents = reader.get();\n\n\t\t// Verify results\n\t\tassertThat(documents).isNotEmpty();\n\n\t\t// Verify basic structure of first document\n\t\tDocument doc = documents.get(0);\n\t\tassertThat(doc.getId()).isNotNull();\n\t\tassertThat(doc.getText()).isNotBlank();\n\t\tassertThat(doc.getMetadata()).containsKey(\"state\").containsKey(\"url\");\n\n\t\t// Verify default state is OPEN\n\t\tassertThat(doc.getMetadata().get(\"state\")).isEqualTo(\"opened\");\n\t}\n\n\t@Test\n\tvoid testLoadDataWithCustomParameters() throws GitLabApiException {\n\t\t// Create new reader instance with custom parameters\n\t\tGitLabIssueConfig config = GitLabIssueConfig.builder()\n\t\t\t.confidential(false)\n\t\t\t.createdAfter(LocalDateTime.now().minusDays(365))\n\t\t\t.issueType(GitLabIssueType.ISSUE)\n\t\t\t.labels(Arrays.asList(\"enhancement\", \"feature\"))\n\t\t\t.nonArchived(true)\n\t\t\t.scope(GitLabScope.ALL)\n\t\t\t.state(GitLabIssueState.CLOSED)\n\t\t\t.build();\n\n\t\treader = new GitLabIssueReader(TEST_HOST_URL, TEST_NAMESPACE, TEST_PROJECT_NAME, null, config);\n\n\t\t// Get issues\n\t\tList<Document> documents = reader.get();\n\n\t\t// Verify results\n\t\tassertThat(documents).isNotEmpty();\n\n\t\t// Verify all documents match our filter criteria\n\t\tfor (Document doc : documents) {\n\t\t\tassertThat(doc.getMetadata()).containsEntry(\"state\", \"closed\").hasEntrySatisfying(\"labels\", labels -> {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tList<String> labelList = (List<String>) labels;\n\t\t\t\tassertThat(labelList).containsAnyOf(\"enhancement\", \"feature\");\n\t\t\t}).containsKey(\"url\");\n\n\t\t\t// Verify document content\n\t\t\tassertThat(doc.getId()).isNotNull();\n\t\t\tassertThat(doc.getText()).isNotBlank();\n\t\t}\n\t}\n\n\t@Test\n\tvoid testLoadSpecificIssue() throws GitLabApiException {\n\t\t// Create configuration to get specific issue\n\t\tGitLabIssueConfig config = GitLabIssueConfig.builder().iids(Arrays.asList(1)).build();\n\n\t\treader = new GitLabIssueReader(TEST_HOST_URL, TEST_NAMESPACE, TEST_PROJECT_NAME, null, config);\n\n\t\t// Get specific issue (#1)\n\t\tList<Document> documents = reader.get();\n\n\t\t// Verify results\n\t\tassertThat(documents).hasSize(1);\n\t\tDocument doc = documents.get(0);\n\t\tassertThat(doc.getId()).isEqualTo(\"1\");\n\t\tassertThat(doc.getMetadata()).containsKey(\"state\").containsKey(\"url\");\n\t}\n\n}", "metadata": {"commit_sha": "c0987eb2", "lines_added": 2, "lines_deleted": 2, "total_changes": 4, "chunks": 2}}
{"id": 117, "pattern_type": "getter_setter", "file_path": "community/tool-calls/spring-ai-alibaba-starter-tool-calling-common/src/main/java/com/alibaba/cloud/ai/toolcalling/common/CommonToolCallProperties.java", "file_extension": "java", "input": "/*\n * Copyright 2024-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.toolcalling.common;\n\nimport org.springframework.util.StringUtils;\n\n/**\n * The properties of the specific tool call need to inherit from this class\n *\n * @author vlsmb\n */\npublic class CommonToolCallProperties {\n\n\tprivate String apiKey;\n\n\tprivate String secretKey;\n\n\tprivate String baseUrl;\n\n\tprivate Integer networkTimeout;\n\n\tprivate String appId;\n\n\tprivate String token;\n\n\tprivate boolean enabled = true;\n\n\tpublic CommonToolCallProperties() {\n\t\tthis.baseUrl = CommonToolCallConstants.DEFAULT_BASE_URL;\n\t\tthis.networkTimeout = CommonToolCallConstants.DEFAULT_NETWORK_TIMEOUT;\n\t}\n\n\tpublic CommonToolCallProperties(String baseUrl) {\n\t\tthis.baseUrl = baseUrl;\n\t\tthis.networkTimeout = CommonToolCallConstants.DEFAULT_NETWORK_TIMEOUT;\n\t}\n\n\tpublic CommonToolCallProperties(String baseUrl, Integer networkTimeout) {\n\t\tthis.baseUrl = baseUrl;\n\t\tthis.networkTimeout = networkTimeout;\n\t}\n\n\tpublic String getApiKey() {\n\t\treturn apiKey;\n\t}\n\n\tpublic void setApiKey(String apiKey) {\n\t\tthis.apiKey = apiKey;\n\t}\n\n\tpublic String getSecretKey() {\n\t\treturn secretKey;\n\t}\n\n\tpublic void setSecretKey(String secretKey) {\n\t\tthis.secretKey = secretKey;\n\t}\n\n\tpublic String getAppId() {\n\t\treturn appId;\n\t}\n\n\tpublic void setAppId(String appId) {\n\t\tthis.appId = appId;\n\t}\n\n\tpublic String getBaseUrl() {\n\t\treturn baseUrl;\n\t}\n\n\tpublic void setBaseUrl(String baseUrl) {\n\t\tthis.baseUrl = baseUrl;\n\t}\n\n\tpublic Integer getNetworkTimeout() {\n\t\treturn networkTimeout;\n\t}\n\n\tpublic void setNetworkTimeout(Integer networkTimeout) {\n\t\tthis.networkTimeout = networkTimeout;\n\t}\n\n\tpublic String getToken() {\n\t\treturn token;\n\t}\n\n\tpublic void setToken(String token) {\n\t\tthis.token = token;\n\t}\n\n\tpublic boolean isEnabled() {\n\t\treturn enabled;\n\t}\n\n\tpublic void setEnabled(boolean enabled) {\n\t\tthis.enabled = enabled;\n\t}\n\n\t// Invoked after PropertiesBean instantiation to load default values from system\n\t// environment variables using keys associated with derived Properties class\n\t// attributes.\n\tprotected void setPropertiesFromEnv(String apiKeyEnv, String secretKeyEnv, String appIdEnv, String tokenEnv) {\n\t\tif (StringUtils.hasText(apiKeyEnv) && !StringUtils.hasText(this.apiKey)) {\n\t\t\tthis.apiKey = System.getenv(apiKeyEnv);\n\t\t}\n\t\tif (StringUtils.hasText(secretKeyEnv) && !StringUtils.hasText(this.secretKey)) {\n\t\t\tthis.secretKey = System.getenv(secretKeyEnv);\n\t\t}\n\t\tif (StringUtils.hasText(appIdEnv) && !StringUtils.hasText(this.appId)) {\n\t\t\tthis.appId = System.getenv(appIdEnv);\n\t\t}\n\t\tif (StringUtils.hasText(tokenEnv) && !StringUtils.hasText(this.token)) {\n\t\t\tthis.token = System.getenv(tokenEnv);\n\t\t}\n\t}\n\n}", "output": "/*\n * Copyright 2024-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.toolcalling.common;\n\nimport org.springframework.util.StringUtils;\n\n/**\n * The properties of the specific tool call need to inherit from this class\n *\n * @author vlsmb\n */\npublic class CommonToolCallProperties {\n\n\tprivate String apiKey;\n\n\tprivate String secretKey;\n\n\tprivate String baseUrl;\n\n\tprivate Integer networkTimeout;\n\n\tprivate String appId;\n\n\tprivate String token;\n\n\tprivate String accessKeyId;\n\n\tprivate boolean enabled = true;\n\n\tpublic CommonToolCallProperties() {\n\t\tthis.baseUrl = CommonToolCallConstants.DEFAULT_BASE_URL;\n\t\tthis.networkTimeout = CommonToolCallConstants.DEFAULT_NETWORK_TIMEOUT;\n\t}\n\n\tpublic CommonToolCallProperties(String baseUrl) {\n\t\tthis.baseUrl = baseUrl;\n\t\tthis.networkTimeout = CommonToolCallConstants.DEFAULT_NETWORK_TIMEOUT;\n\t}\n\n\tpublic CommonToolCallProperties(String baseUrl, Integer networkTimeout) {\n\t\tthis.baseUrl = baseUrl;\n\t\tthis.networkTimeout = networkTimeout;\n\t}\n\n\tpublic String getApiKey() {\n\t\treturn apiKey;\n\t}\n\n\tpublic void setApiKey(String apiKey) {\n\t\tthis.apiKey = apiKey;\n\t}\n\n\tpublic String getSecretKey() {\n\t\treturn secretKey;\n\t}\n\n\tpublic void setSecretKey(String secretKey) {\n\t\tthis.secretKey = secretKey;\n\t}\n\n\tpublic String getAppId() {\n\t\treturn appId;\n\t}\n\n\tpublic void setAppId(String appId) {\n\t\tthis.appId = appId;\n\t}\n\n\tpublic String getBaseUrl() {\n\t\treturn baseUrl;\n\t}\n\n\tpublic void setBaseUrl(String baseUrl) {\n\t\tthis.baseUrl = baseUrl;\n\t}\n\n\tpublic Integer getNetworkTimeout() {\n\t\treturn networkTimeout;\n\t}\n\n\tpublic void setNetworkTimeout(Integer networkTimeout) {\n\t\tthis.networkTimeout = networkTimeout;\n\t}\n\n\tpublic String getToken() {\n\t\treturn token;\n\t}\n\n\tpublic void setToken(String token) {\n\t\tthis.token = token;\n\t}\n\n\tpublic String getAccessKeyId() {\n\t\treturn accessKeyId;\n\t}\n\n\tpublic void setAccessKeyId(String accessKeyId) {\n\t\tthis.accessKeyId = accessKeyId;\n\t}\n\n\tpublic boolean isEnabled() {\n\t\treturn enabled;\n\t}\n\n\tpublic void setEnabled(boolean enabled) {\n\t\tthis.enabled = enabled;\n\t}\n\n\t// Invoked after PropertiesBean instantiation to load default values from system\n\t// environment variables using keys associated with derived Properties class\n\t// attributes.\n\tprotected void setPropertiesFromEnv(String apiKeyEnv, String secretKeyEnv, String appIdEnv, String tokenEnv) {\n\t\tif (StringUtils.hasText(apiKeyEnv) && !StringUtils.hasText(this.apiKey)) {\n\t\t\tthis.apiKey = System.getenv(apiKeyEnv);\n\t\t}\n\t\tif (StringUtils.hasText(secretKeyEnv) && !StringUtils.hasText(this.secretKey)) {\n\t\t\tthis.secretKey = System.getenv(secretKeyEnv);\n\t\t}\n\t\tif (StringUtils.hasText(appIdEnv) && !StringUtils.hasText(this.appId)) {\n\t\t\tthis.appId = System.getenv(appIdEnv);\n\t\t}\n\t\tif (StringUtils.hasText(tokenEnv) && !StringUtils.hasText(this.token)) {\n\t\t\tthis.token = System.getenv(tokenEnv);\n\t\t}\n\t}\n\n}", "metadata": {"commit_sha": "d1144f48", "lines_added": 10, "lines_deleted": 0, "total_changes": 10, "chunks": 2}}
{"id": 88, "pattern_type": "other", "file_path": "community/tool-calls/spring-ai-alibaba-starter-tool-calling-baidutranslate/src/main/java/com/alibaba/cloud/ai/toolcalling/baidutranslate/BaiduTranslateProperties.java", "file_extension": "java", "input": "/*\n * Copyright 2024-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alibaba.cloud.ai.toolcalling.baidutranslate;\n\nimport com.alibaba.cloud.ai.toolcalling.common.CommonToolCallProperties;\nimport jakarta.annotation.PostConstruct;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\nimport static com.alibaba.cloud.ai.toolcalling.baidutranslate.BaiduTranslateProperties.BaiDuTranslatePrefix;\nimport static com.alibaba.cloud.ai.toolcalling.common.CommonToolCallConstants.TOOL_CALLING_CONFIG_PREFIX;\n\n/**\n * @author SCMRCORE\n */\n@ConfigurationProperties(prefix = BaiDuTranslatePrefix)\npublic class BaiduTranslateProperties extends CommonToolCallProperties {\n\n\tprotected static final String BaiDuTranslatePrefix = TOOL_CALLING_CONFIG_PREFIX + \".baidu.translate\";\n\n\tprivate static final String TRANSLATE_HOST_URL = \"https://fanyi-api.baidu.com/api/trans/vip/translate/\";\n\n\tpublic BaiduTranslateProperties() {\n\t\tsuper(TRANSLATE_HOST_URL);\n\t}\n\n\t@PostConstruct\n\tprivate void initProperties() {\n\t\tthis.setPropertiesFromEnv(null, \"BAIDU_TRANSLATE_SECRET_KEY\", \"BAIDU_TRANSLATE_APP_ID\", null);\n\t}\n\n}", "output": "/*\n * Copyright 2024-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alibaba.cloud.ai.toolcalling.baidutranslate;\n\nimport com.alibaba.cloud.ai.toolcalling.common.CommonToolCallProperties;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\nimport static com.alibaba.cloud.ai.toolcalling.baidutranslate.BaiduTranslateProperties.BaiDuTranslatePrefix;\nimport static com.alibaba.cloud.ai.toolcalling.common.CommonToolCallConstants.TOOL_CALLING_CONFIG_PREFIX;\n\n/**\n * @author SCMRCORE\n */\n@ConfigurationProperties(prefix = BaiDuTranslatePrefix)\npublic class BaiduTranslateProperties extends CommonToolCallProperties {\n\n\tprotected static final String BaiDuTranslatePrefix = TOOL_CALLING_CONFIG_PREFIX + \".baidu.translate\";\n\n\tprivate static final String TRANSLATE_HOST_URL = \"https://fanyi-api.baidu.com/api/trans/vip/translate/\";\n\n\tpublic BaiduTranslateProperties() {\n\t\tsuper(TRANSLATE_HOST_URL);\n\t\tthis.setPropertiesFromEnv(null, \"BAIDU_TRANSLATE_SECRET_KEY\", \"BAIDU_TRANSLATE_APP_ID\", null);\n\t}\n\n}", "metadata": {"commit_sha": "fea5dc47", "lines_added": 0, "lines_deleted": 5, "total_changes": 5, "chunks": 2}}
{"id": 190, "pattern_type": "getter_setter", "file_path": "spring-ai-alibaba-graph-core/src/main/java/com/alibaba/cloud/ai/graph/agent/ReactAgent.java", "file_extension": "java", "input": "/*\n * Copyright 2024-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.graph.agent;\n\nimport com.alibaba.cloud.ai.graph.CompileConfig;\nimport com.alibaba.cloud.ai.graph.CompiledGraph;\nimport com.alibaba.cloud.ai.graph.GraphResponse;\nimport com.alibaba.cloud.ai.graph.KeyStrategy;\nimport com.alibaba.cloud.ai.graph.KeyStrategyFactory;\nimport com.alibaba.cloud.ai.graph.NodeOutput;\nimport com.alibaba.cloud.ai.graph.OverAllState;\nimport com.alibaba.cloud.ai.graph.RunnableConfig;\nimport com.alibaba.cloud.ai.graph.StateGraph;\nimport com.alibaba.cloud.ai.graph.SubGraphNode;\nimport com.alibaba.cloud.ai.graph.action.AsyncNodeActionWithConfig;\nimport com.alibaba.cloud.ai.graph.action.NodeAction;\nimport com.alibaba.cloud.ai.graph.action.NodeActionWithConfig;\nimport com.alibaba.cloud.ai.graph.agent.factory.AgentBuilderFactory;\nimport com.alibaba.cloud.ai.graph.agent.factory.DefaultAgentBuilderFactory;\nimport com.alibaba.cloud.ai.graph.exception.GraphRunnerException;\nimport com.alibaba.cloud.ai.graph.exception.GraphStateException;\nimport com.alibaba.cloud.ai.graph.internal.node.Node;\nimport com.alibaba.cloud.ai.graph.node.LlmNode;\nimport com.alibaba.cloud.ai.graph.node.ToolNode;\nimport com.alibaba.cloud.ai.graph.scheduling.ScheduleConfig;\nimport com.alibaba.cloud.ai.graph.scheduling.ScheduledAgentTask;\nimport com.alibaba.cloud.ai.graph.state.strategy.AppendStrategy;\n\nimport org.springframework.ai.chat.messages.AssistantMessage;\nimport org.springframework.ai.chat.messages.Message;\nimport org.springframework.ai.chat.messages.UserMessage;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.function.Function;\n\nimport reactor.core.publisher.Flux;\n\nimport static com.alibaba.cloud.ai.graph.StateGraph.END;\nimport static com.alibaba.cloud.ai.graph.StateGraph.START;\nimport static com.alibaba.cloud.ai.graph.action.AsyncEdgeAction.edge_async;\nimport static com.alibaba.cloud.ai.graph.action.AsyncNodeAction.node_async;\nimport static com.alibaba.cloud.ai.graph.utils.Messageutils.convertToMessages;\nimport static java.lang.String.format;\n\npublic class ReactAgent extends BaseAgent {\n\n\tprivate final LlmNode llmNode;\n\n\tprivate final ToolNode toolNode;\n\n\tprivate CompiledGraph compiledGraph;\n\n\tprivate NodeAction preLlmHook;\n\n\tprivate NodeAction postLlmHook;\n\n\tprivate NodeAction preToolHook;\n\n\tprivate NodeAction postToolHook;\n\n\tprivate List<String> tools;\n\n\tprivate int max_iterations = 10;\n\n\tprivate int iterations = 0;\n\n\tprivate CompileConfig compileConfig;\n\n\tprivate KeyStrategyFactory keyStrategyFactory;\n\n\tprivate String instruction;\n\n\tprivate Function<OverAllState, Boolean> shouldContinueFunc;\n\n\tpublic ReactAgent(LlmNode llmNode, ToolNode toolNode, Builder builder) throws GraphStateException {\n\t\tsuper(builder.name, builder.description, builder.includeContents, builder.outputKey, builder.outputKeyStrategy);\n\t\tthis.instruction = builder.instruction;\n\t\tthis.llmNode = llmNode;\n\t\tthis.toolNode = toolNode;\n\t\tthis.keyStrategyFactory = builder.keyStrategyFactory;\n\t\tthis.compileConfig = builder.compileConfig;\n\t\tthis.shouldContinueFunc = builder.shouldContinueFunc;\n\t\tthis.preLlmHook = builder.preLlmHook;\n\t\tthis.postLlmHook = builder.postLlmHook;\n\t\tthis.preToolHook = builder.preToolHook;\n\t\tthis.postToolHook = builder.postToolHook;\n\t\tthis.includeContents = builder.includeContents;\n\t}\n\n\tpublic static Builder builder() {\n\t\treturn new DefaultAgentBuilderFactory().builder();\n\t}\n\n\tpublic static Builder builder(AgentBuilderFactory agentBuilderFactory) {\n\t\treturn agentBuilderFactory.builder();\n\t}\n\n\t@Override\n\tpublic ScheduledAgentTask schedule(ScheduleConfig scheduleConfig) throws GraphStateException {\n\t\tCompiledGraph compiledGraph = getAndCompileGraph();\n\t\treturn compiledGraph.schedule(scheduleConfig);\n\t}\n\n\tpublic AssistantMessage invoke(String message) throws GraphRunnerException {\n\t\treturn invokeMessage(message);\n\t}\n\n\tpublic AssistantMessage invoke(String message, RunnableConfig config) throws GraphRunnerException {\n\t\treturn invokeMessage(message, config);\n\t}\n\n\tpublic AssistantMessage invoke(UserMessage userMessage) throws GraphRunnerException {\n\t\treturn invokeMessage(userMessage);\n\t}\n\n\tpublic AssistantMessage invoke(UserMessage userMessage, RunnableConfig config) throws GraphRunnerException {\n\t\treturn invokeMessage(userMessage, config);\n\t}\n\n\tpublic AssistantMessage invoke(List<Message> messages) throws GraphRunnerException {\n\t\treturn invokeMessage(messages);\n\t}\n\n\tpublic AssistantMessage invoke(List<Message> messages, RunnableConfig config) throws GraphRunnerException {\n\t\treturn invokeMessage(messages, config);\n\t}\n\n\tpublic Flux<NodeOutput> stream(String message) throws GraphRunnerException {\n\t\treturn stream(Map.of(\"messages\", convertToMessages(message)));\n\t}\n\n\tpublic Flux<NodeOutput> stream(String message, RunnableConfig config) throws GraphRunnerException {\n\t\treturn stream(Map.of(\"messages\", convertToMessages(message)), config);\n\t}\n\n\tpublic Flux<NodeOutput> stream(UserMessage userMessage) throws GraphRunnerException {\n\t\treturn stream(Map.of(\"messages\", convertToMessages(userMessage)));\n\t}\n\n\tpublic Flux<NodeOutput> stream(UserMessage userMessage, RunnableConfig config) throws GraphRunnerException {\n\t\treturn stream(Map.of(\"messages\", convertToMessages(userMessage)), config);\n\t}\n\n\tpublic Flux<NodeOutput> stream(List<Message> messages) throws GraphRunnerException {\n\t\treturn stream(Map.of(\"messages\", messages));\n\t}\n\n\tpublic Flux<NodeOutput> stream(List<Message> messages, RunnableConfig config) throws GraphRunnerException {\n\t\treturn stream(Map.of(\"messages\", messages), config);\n\t}\n\n\tprivate AssistantMessage invokeMessage(Object message) throws GraphRunnerException {\n\t\treturn invokeMessage(message, RunnableConfig.builder().build());\n\t}\n\n\tprivate AssistantMessage invokeMessage(Object message, RunnableConfig config) throws GraphRunnerException {\n\t\tList<Message> messages;\n\t\tif (message instanceof List) {\n\t\t\tmessages = (List<Message>) message;\n\t\t} else {\n\t\t\tmessages = convertToMessages(message);\n\t\t}\n\n\t\tOptional<OverAllState> state = invoke(Map.of(\"messages\", messages), config);\n\n\t\treturn state.flatMap(s -> s.value(\"messages\"))\n\t\t\t\t.map(messageList -> (List<Message>) messageList)\n\t\t\t\t.stream()\n\t\t\t\t.flatMap(messageList -> messageList.stream())\n\t\t\t\t.filter(msg -> msg instanceof AssistantMessage)\n\t\t\t\t.map(msg -> (AssistantMessage) msg)\n\t\t\t\t.reduce((first, second) -> second)\n\t\t\t\t.orElse(new AssistantMessage(\"No response generated\"));\n\t}\n\n\tpublic StateGraph getStateGraph() {\n\t\treturn graph;\n\t}\n\n\tpublic CompiledGraph getCompiledGraph() {\n\t\treturn compiledGraph;\n\t}\n\n\t@Override\n\tpublic Node asNode(boolean includeContents, String outputKeyToParent) {\n\t\tif (this.compiledGraph == null) {\n\t\t\tthis.compiledGraph = getAndCompileGraph();\n\t\t}\n\t\treturn new AgentSubGraphNode(this.name, includeContents, outputKeyToParent, this.compiledGraph);\n\t}\n\n\n\t@Override\n\tprotected StateGraph initGraph() throws GraphStateException {\n\t\tinsureMessagesKeyStrategyFactory();\n\n\t\tNodeAction effectivePreLlmHook = this.preLlmHook;\n\t\tif (effectivePreLlmHook == null) {\n\t\t\teffectivePreLlmHook = state -> {\n\t\t\t\treturn Map.of();\n\t\t\t};\n\t\t}\n\n\t\tStateGraph graph = new StateGraph(name, this.keyStrategyFactory);\n\n\t\tgraph.addNode(\"preLlm\", node_async(effectivePreLlmHook));\n\t\tgraph.addNode(\"llm\", node_async(this.llmNode));\n\t\tif (postLlmHook != null) {\n\t\t\tgraph.addNode(\"postLlm\", node_async(this.postLlmHook));\n\t\t}\n\n\t\tif (preToolHook != null) {\n\t\t\tgraph.addNode(\"preTool\", node_async(this.preToolHook));\n\t\t}\n\n\t\tgraph.addNode(\"tool\", node_async(this.toolNode));\n\n\t\tif (postToolHook != null) {\n\t\t\tgraph.addNode(\"postTool\", node_async(this.postToolHook));\n\t\t}\n\n\t\tgraph.addEdge(START, \"preLlm\").addEdge(\"preLlm\", \"llm\");\n\n\t\tif (postLlmHook != null) {\n\t\t\tgraph.addEdge(\"llm\", \"postLlm\")\n\t\t\t\t.addConditionalEdges(\"postLlm\", edge_async(this::think),\n\t\t\t\t\t\tMap.of(\"continue\", preToolHook != null ? \"preTool\" : \"tool\", \"end\", END));\n\t\t}\n\t\telse {\n\t\t\tgraph.addConditionalEdges(\"llm\", edge_async(this::think),\n\t\t\t\t\tMap.of(\"continue\", preToolHook != null ? \"preTool\" : \"tool\", \"end\", END));\n\t\t}\n\n\t\t// Add tool-related edges\n\t\tif (preToolHook != null) {\n\t\t\tgraph.addEdge(\"preTool\", \"tool\");\n\t\t}\n\t\tif (postToolHook != null) {\n\t\t\tgraph.addEdge(\"tool\", \"postTool\").addEdge(\"postTool\", \"preLlm\");\n\t\t}\n\t\telse {\n\t\t\tgraph.addEdge(\"tool\", \"preLlm\");\n\t\t}\n\n\t\treturn graph;\n\t}\n\n\tprivate void insureMessagesKeyStrategyFactory() {\n\t\tif (keyStrategyFactory == null) {\n\t\t\tthis.keyStrategyFactory = () -> {\n\t\t\t\tHashMap<String, KeyStrategy> keyStrategyHashMap = new HashMap<>();\n\t\t\t\tkeyStrategyHashMap.put(\"messages\", new AppendStrategy());\n\t\t\t\treturn keyStrategyHashMap;\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\tKeyStrategyFactory originalFactory = this.keyStrategyFactory;\n\t\t\tthis.keyStrategyFactory = () -> {\n\t\t\t\tHashMap<String, KeyStrategy> keyStrategyHashMap = new HashMap<>(originalFactory.apply());\n\t\t\t\tkeyStrategyHashMap.put(\"messages\", new AppendStrategy());\n\t\t\t\treturn keyStrategyHashMap;\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate String think(OverAllState state) {\n\t\tif (iterations > max_iterations) {\n\t\t\treturn \"end\";\n\t\t}\n\n\t\tif (shouldContinueFunc != null && !shouldContinueFunc.apply(state)) {\n\t\t\treturn \"end\";\n\t\t}\n\n\t\tList<Message> messages = (List<Message>) state.value(\"messages\").orElseThrow();\n\t\tAssistantMessage message = (AssistantMessage) messages.get(messages.size() - 1);\n\t\tif (message.hasToolCalls()) {\n\t\t\treturn \"continue\";\n\t\t}\n\n\t\treturn \"end\";\n\t}\n\n\tpublic String instruction() {\n\t\treturn instruction;\n\t}\n\n\tpublic void setInstruction(String instruction) {\n\t\tthis.instruction = instruction;\n\t}\n\n\t/**\n\t * Gets the agent's unique name.\n\t * @return the unique name of the agent.\n\t */\n\tpublic String name() {\n\t\treturn name;\n\t}\n\n\t/**\n\t * Gets the one-line description of the agent's capability.\n\t * @return the description of the agent.\n\t */\n\tpublic String description() {\n\t\treturn description;\n\t}\n\n\tList<String> getTools() {\n\t\treturn tools;\n\t}\n\n\tvoid setTools(List<String> tools) {\n\t\tthis.tools = tools;\n\t}\n\n\tint getMax_iterations() {\n\t\treturn max_iterations;\n\t}\n\n\tvoid setMax_iterations(int max_iterations) {\n\t\tthis.max_iterations = max_iterations;\n\t}\n\n\tint getIterations() {\n\t\treturn iterations;\n\t}\n\n\tvoid setIterations(int iterations) {\n\t\tthis.iterations = iterations;\n\t}\n\n\tCompileConfig getCompileConfig() {\n\t\treturn compileConfig;\n\t}\n\n\tvoid setCompileConfig(CompileConfig compileConfig) {\n\t\tthis.compileConfig = compileConfig;\n\t}\n\n\tKeyStrategyFactory getKeyStrategyFactory() {\n\t\treturn keyStrategyFactory;\n\t}\n\n\tvoid setOverAllStateFactory(KeyStrategyFactory keyStrategyFactory) {\n\t\tthis.keyStrategyFactory = keyStrategyFactory;\n\t}\n\n\tFunction<OverAllState, Boolean> getShouldContinueFunc() {\n\t\treturn shouldContinueFunc;\n\t}\n\n\tvoid setShouldContinueFunc(Function<OverAllState, Boolean> shouldContinueFunc) {\n\t\tthis.shouldContinueFunc = shouldContinueFunc;\n\t}\n\n\tpublic boolean isIncludeContents() {\n\t\treturn includeContents;\n\t}\n\n\tpublic void setIncludeContents(boolean includeContents) {\n\t\tthis.includeContents = includeContents;\n\t}\n\n\tpublic String getOutputKey() {\n\t\treturn outputKey;\n\t}\n\n\tpublic void setOutputKey(String outputKey) {\n\t\tthis.outputKey = outputKey;\n\t}\n\n\tpublic KeyStrategy getOutputKeyStrategy() {\n\t\treturn outputKeyStrategy;\n\t}\n\n\tpublic void setOutputKeyStrategy(KeyStrategy outputKeyStrategy) {\n\t\tthis.outputKeyStrategy = outputKeyStrategy;\n\t}\n\n\tpublic static class SubGraphNodeAdapter implements NodeActionWithConfig {\n\n\t\tprivate boolean includeContents;\n\n\t\tprivate String outputKeyToParent;\n\n\t\tprivate CompiledGraph childGraph;\n\n\t\tprivate CompileConfig parentCompileConfig;\n\n\t\tpublic SubGraphNodeAdapter(boolean includeContents, String outputKeyToParent,\n\t\t\t\tCompiledGraph childGraph, CompileConfig parentCompileConfig) {\n\t\t\tthis.includeContents = includeContents;\n\t\t\tthis.outputKeyToParent = outputKeyToParent;\n\t\t\tthis.childGraph = childGraph;\n\t\t\tthis.parentCompileConfig = parentCompileConfig;\n\t\t}\n\n\t\tpublic String subGraphId() {\n\t\t\treturn format(\"subgraph_%s\", childGraph.stateGraph.getName());\n\t\t}\n\n\t\t@Override\n\t\tpublic Map<String, Object> apply(OverAllState parentState, RunnableConfig config) throws Exception {\n\t\t\tRunnableConfig subGraphRunnableConfig = getSubGraphRunnableConfig(config);\n\t\t\tFlux<GraphResponse<NodeOutput>> subGraphFlux;\n\t\t\tObject parentMessages = null;\n\t\t\tif (includeContents) {\n\t\t\t\t// by default, includeContents is true, we pass down the messages from the parent state\n\t\t\t\tsubGraphFlux = childGraph.fluxDataStream(parentState, subGraphRunnableConfig);\n\t\t\t} else {\n\t\t\t\tMap<String, Object> stateForChild = new HashMap<>(parentState.data());\n\t\t\t\tparentMessages = stateForChild.remove(\"messages\");\n\t\t\t\t// use the instruction directly, without any user message or parent messages.\n\t\t\t\tsubGraphFlux = childGraph.fluxDataStream(stateForChild, subGraphRunnableConfig);\n\t\t\t}\n\n\t\t\tMap<String, Object> result = new HashMap<>();\n\t\t\tresult.put(outputKeyToParent, subGraphFlux);\n\t\t\tif (parentMessages != null) {\n\t\t\t\tresult.put(\"messages\", parentMessages);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate RunnableConfig getSubGraphRunnableConfig(RunnableConfig config) {\n\t\t\tRunnableConfig subGraphRunnableConfig = config;\n\t\t\tvar parentSaver = parentCompileConfig.checkpointSaver();\n\t\t\tvar subGraphSaver = childGraph.compileConfig.checkpointSaver();\n\n\t\t\tif (subGraphSaver.isPresent()) {\n\t\t\t\tif (parentSaver.isEmpty()) {\n\t\t\t\t\tthrow new IllegalStateException(\"Missing CheckpointSaver in parent graph!\");\n\t\t\t\t}\n\n\t\t\t\t// Check saver are the same instance\n\t\t\t\tif (parentSaver.get() == subGraphSaver.get()) {\n\t\t\t\t\tsubGraphRunnableConfig = RunnableConfig.builder(config)\n\t\t\t\t\t\t\t.threadId(config.threadId()\n\t\t\t\t\t\t\t\t\t.map(threadId -> format(\"%s_%s\", threadId, subGraphId()))\n\t\t\t\t\t\t\t\t\t.orElseGet(this::subGraphId))\n\t\t\t\t\t\t\t.nextNode(null)\n\t\t\t\t\t\t\t.checkPointId(null)\n\t\t\t\t\t\t\t.build();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn subGraphRunnableConfig;\n\t\t}\n\n\t}\n\n\t/**\n\t * Internal class that adapts a ReactAgent to be used as a SubGraph Node.\n\t * Similar to SubCompiledGraphNode but uses SubGraphNodeAdapter internally.\n\t */\n\tprivate static class AgentSubGraphNode extends Node implements SubGraphNode {\n\n\t\tprivate final CompiledGraph subGraph;\n\n\t\tpublic AgentSubGraphNode(String id, boolean includeContents, String outputKeyToParent, CompiledGraph subGraph) {\n\t\t\tsuper(Objects.requireNonNull(id, \"id cannot be null\"),\n\t\t\t\t\t(config) -> AsyncNodeActionWithConfig.node_async(new SubGraphNodeAdapter(includeContents, outputKeyToParent, subGraph, config)));\n\t\t\tthis.subGraph = subGraph;\n\t\t}\n\n\t\t@Override\n\t\tpublic StateGraph subGraph() {\n\t\t\treturn subGraph.stateGraph;\n\t\t}\n\t}\n}", "output": "/*\n * Copyright 2024-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.graph.agent;\n\nimport com.alibaba.cloud.ai.graph.CompileConfig;\nimport com.alibaba.cloud.ai.graph.CompiledGraph;\nimport com.alibaba.cloud.ai.graph.GraphResponse;\nimport com.alibaba.cloud.ai.graph.KeyStrategy;\nimport com.alibaba.cloud.ai.graph.KeyStrategyFactory;\nimport com.alibaba.cloud.ai.graph.NodeOutput;\nimport com.alibaba.cloud.ai.graph.OverAllState;\nimport com.alibaba.cloud.ai.graph.RunnableConfig;\nimport com.alibaba.cloud.ai.graph.StateGraph;\nimport com.alibaba.cloud.ai.graph.SubGraphNode;\nimport com.alibaba.cloud.ai.graph.action.AsyncNodeActionWithConfig;\nimport com.alibaba.cloud.ai.graph.action.NodeAction;\nimport com.alibaba.cloud.ai.graph.action.NodeActionWithConfig;\nimport com.alibaba.cloud.ai.graph.agent.factory.AgentBuilderFactory;\nimport com.alibaba.cloud.ai.graph.agent.factory.DefaultAgentBuilderFactory;\nimport com.alibaba.cloud.ai.graph.exception.GraphRunnerException;\nimport com.alibaba.cloud.ai.graph.exception.GraphStateException;\nimport com.alibaba.cloud.ai.graph.internal.node.Node;\nimport com.alibaba.cloud.ai.graph.node.LlmNode;\nimport com.alibaba.cloud.ai.graph.node.ToolNode;\nimport com.alibaba.cloud.ai.graph.scheduling.ScheduleConfig;\nimport com.alibaba.cloud.ai.graph.scheduling.ScheduledAgentTask;\nimport com.alibaba.cloud.ai.graph.state.strategy.AppendStrategy;\n\nimport org.springframework.ai.chat.messages.AssistantMessage;\nimport org.springframework.ai.chat.messages.Message;\nimport org.springframework.ai.chat.messages.UserMessage;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.function.Function;\n\nimport reactor.core.publisher.Flux;\n\nimport static com.alibaba.cloud.ai.graph.StateGraph.END;\nimport static com.alibaba.cloud.ai.graph.StateGraph.START;\nimport static com.alibaba.cloud.ai.graph.action.AsyncEdgeAction.edge_async;\nimport static com.alibaba.cloud.ai.graph.action.AsyncNodeAction.node_async;\nimport static com.alibaba.cloud.ai.graph.utils.Messageutils.convertToMessages;\nimport static java.lang.String.format;\n\npublic class ReactAgent extends BaseAgent {\n\n\tprivate final LlmNode llmNode;\n\n\tprivate final ToolNode toolNode;\n\n\tprivate CompiledGraph compiledGraph;\n\n\tprivate NodeAction preLlmHook;\n\n\tprivate NodeAction postLlmHook;\n\n\tprivate NodeAction preToolHook;\n\n\tprivate NodeAction postToolHook;\n\n\tprivate List<String> tools;\n\n\tprivate int maxIterations = 10;\n\n\tprivate int iterations = 0;\n\n\tprivate CompileConfig compileConfig;\n\n\tprivate KeyStrategyFactory keyStrategyFactory;\n\n\tprivate String instruction;\n\n\tprivate Function<OverAllState, Boolean> shouldContinueFunc;\n\n\tpublic ReactAgent(LlmNode llmNode, ToolNode toolNode, Builder builder) throws GraphStateException {\n\t\tsuper(builder.name, builder.description, builder.includeContents, builder.outputKey, builder.outputKeyStrategy);\n\t\tthis.instruction = builder.instruction;\n\t\tthis.llmNode = llmNode;\n\t\tthis.toolNode = toolNode;\n\t\tthis.keyStrategyFactory = builder.keyStrategyFactory;\n\t\tthis.compileConfig = builder.compileConfig;\n\t\tthis.shouldContinueFunc = builder.shouldContinueFunc;\n\t\tthis.preLlmHook = builder.preLlmHook;\n\t\tthis.postLlmHook = builder.postLlmHook;\n\t\tthis.preToolHook = builder.preToolHook;\n\t\tthis.postToolHook = builder.postToolHook;\n\t\tthis.includeContents = builder.includeContents;\n\t\tthis.maxIterations = builder.maxIterations;\n\t}\n\n\tpublic static Builder builder() {\n\t\treturn new DefaultAgentBuilderFactory().builder();\n\t}\n\n\tpublic static Builder builder(AgentBuilderFactory agentBuilderFactory) {\n\t\treturn agentBuilderFactory.builder();\n\t}\n\n\t@Override\n\tpublic ScheduledAgentTask schedule(ScheduleConfig scheduleConfig) throws GraphStateException {\n\t\tCompiledGraph compiledGraph = getAndCompileGraph();\n\t\treturn compiledGraph.schedule(scheduleConfig);\n\t}\n\n\tpublic AssistantMessage invoke(String message) throws GraphRunnerException {\n\t\treturn invokeMessage(message);\n\t}\n\n\tpublic AssistantMessage invoke(String message, RunnableConfig config) throws GraphRunnerException {\n\t\treturn invokeMessage(message, config);\n\t}\n\n\tpublic AssistantMessage invoke(UserMessage userMessage) throws GraphRunnerException {\n\t\treturn invokeMessage(userMessage);\n\t}\n\n\tpublic AssistantMessage invoke(UserMessage userMessage, RunnableConfig config) throws GraphRunnerException {\n\t\treturn invokeMessage(userMessage, config);\n\t}\n\n\tpublic AssistantMessage invoke(List<Message> messages) throws GraphRunnerException {\n\t\treturn invokeMessage(messages);\n\t}\n\n\tpublic AssistantMessage invoke(List<Message> messages, RunnableConfig config) throws GraphRunnerException {\n\t\treturn invokeMessage(messages, config);\n\t}\n\n\tpublic Flux<NodeOutput> stream(String message) throws GraphRunnerException {\n\t\treturn stream(Map.of(\"messages\", convertToMessages(message)));\n\t}\n\n\tpublic Flux<NodeOutput> stream(String message, RunnableConfig config) throws GraphRunnerException {\n\t\treturn stream(Map.of(\"messages\", convertToMessages(message)), config);\n\t}\n\n\tpublic Flux<NodeOutput> stream(UserMessage userMessage) throws GraphRunnerException {\n\t\treturn stream(Map.of(\"messages\", convertToMessages(userMessage)));\n\t}\n\n\tpublic Flux<NodeOutput> stream(UserMessage userMessage, RunnableConfig config) throws GraphRunnerException {\n\t\treturn stream(Map.of(\"messages\", convertToMessages(userMessage)), config);\n\t}\n\n\tpublic Flux<NodeOutput> stream(List<Message> messages) throws GraphRunnerException {\n\t\treturn stream(Map.of(\"messages\", messages));\n\t}\n\n\tpublic Flux<NodeOutput> stream(List<Message> messages, RunnableConfig config) throws GraphRunnerException {\n\t\treturn stream(Map.of(\"messages\", messages), config);\n\t}\n\n\tprivate AssistantMessage invokeMessage(Object message) throws GraphRunnerException {\n\t\treturn invokeMessage(message, RunnableConfig.builder().build());\n\t}\n\n\tprivate AssistantMessage invokeMessage(Object message, RunnableConfig config) throws GraphRunnerException {\n\t\tList<Message> messages;\n\t\tif (message instanceof List) {\n\t\t\tmessages = (List<Message>) message;\n\t\t} else {\n\t\t\tmessages = convertToMessages(message);\n\t\t}\n\n\t\tOptional<OverAllState> state = invoke(Map.of(\"messages\", messages), config);\n\n\t\treturn state.flatMap(s -> s.value(\"messages\"))\n\t\t\t\t.map(messageList -> (List<Message>) messageList)\n\t\t\t\t.stream()\n\t\t\t\t.flatMap(messageList -> messageList.stream())\n\t\t\t\t.filter(msg -> msg instanceof AssistantMessage)\n\t\t\t\t.map(msg -> (AssistantMessage) msg)\n\t\t\t\t.reduce((first, second) -> second)\n\t\t\t\t.orElse(new AssistantMessage(\"No response generated\"));\n\t}\n\n\tpublic StateGraph getStateGraph() {\n\t\treturn graph;\n\t}\n\n\tpublic CompiledGraph getCompiledGraph() {\n\t\treturn compiledGraph;\n\t}\n\n\t@Override\n\tpublic Node asNode(boolean includeContents, String outputKeyToParent) {\n\t\tif (this.compiledGraph == null) {\n\t\t\tthis.compiledGraph = getAndCompileGraph();\n\t\t}\n\t\treturn new AgentSubGraphNode(this.name, includeContents, outputKeyToParent, this.compiledGraph);\n\t}\n\n\n\t@Override\n\tprotected StateGraph initGraph() throws GraphStateException {\n\t\tinsureMessagesKeyStrategyFactory();\n\n\t\tNodeAction effectivePreLlmHook = this.preLlmHook;\n\t\tif (effectivePreLlmHook == null) {\n\t\t\teffectivePreLlmHook = state -> {\n\t\t\t\treturn Map.of();\n\t\t\t};\n\t\t}\n\n\t\tStateGraph graph = new StateGraph(name, this.keyStrategyFactory);\n\n\t\tgraph.addNode(\"preLlm\", node_async(effectivePreLlmHook));\n\t\tgraph.addNode(\"llm\", node_async(this.llmNode));\n\t\tif (postLlmHook != null) {\n\t\t\tgraph.addNode(\"postLlm\", node_async(this.postLlmHook));\n\t\t}\n\n\t\tif (preToolHook != null) {\n\t\t\tgraph.addNode(\"preTool\", node_async(this.preToolHook));\n\t\t}\n\n\t\tgraph.addNode(\"tool\", node_async(this.toolNode));\n\n\t\tif (postToolHook != null) {\n\t\t\tgraph.addNode(\"postTool\", node_async(this.postToolHook));\n\t\t}\n\n\t\tgraph.addEdge(START, \"preLlm\").addEdge(\"preLlm\", \"llm\");\n\n\t\tif (postLlmHook != null) {\n\t\t\tgraph.addEdge(\"llm\", \"postLlm\")\n\t\t\t\t.addConditionalEdges(\"postLlm\", edge_async(this::think),\n\t\t\t\t\t\tMap.of(\"continue\", preToolHook != null ? \"preTool\" : \"tool\", \"end\", END));\n\t\t}\n\t\telse {\n\t\t\tgraph.addConditionalEdges(\"llm\", edge_async(this::think),\n\t\t\t\t\tMap.of(\"continue\", preToolHook != null ? \"preTool\" : \"tool\", \"end\", END));\n\t\t}\n\n\t\t// Add tool-related edges\n\t\tif (preToolHook != null) {\n\t\t\tgraph.addEdge(\"preTool\", \"tool\");\n\t\t}\n\t\tif (postToolHook != null) {\n\t\t\tgraph.addEdge(\"tool\", \"postTool\").addEdge(\"postTool\", \"preLlm\");\n\t\t}\n\t\telse {\n\t\t\tgraph.addEdge(\"tool\", \"preLlm\");\n\t\t}\n\n\t\treturn graph;\n\t}\n\n\tprivate void insureMessagesKeyStrategyFactory() {\n\t\tif (keyStrategyFactory == null) {\n\t\t\tthis.keyStrategyFactory = () -> {\n\t\t\t\tHashMap<String, KeyStrategy> keyStrategyHashMap = new HashMap<>();\n\t\t\t\tkeyStrategyHashMap.put(\"messages\", new AppendStrategy());\n\t\t\t\treturn keyStrategyHashMap;\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\tKeyStrategyFactory originalFactory = this.keyStrategyFactory;\n\t\t\tthis.keyStrategyFactory = () -> {\n\t\t\t\tHashMap<String, KeyStrategy> keyStrategyHashMap = new HashMap<>(originalFactory.apply());\n\t\t\t\tkeyStrategyHashMap.put(\"messages\", new AppendStrategy());\n\t\t\t\treturn keyStrategyHashMap;\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate String think(OverAllState state) {\n\t\tif (iterations > maxIterations) {\n\t\t\treturn \"end\";\n\t\t}\n\n\t\tif (shouldContinueFunc != null && !shouldContinueFunc.apply(state)) {\n\t\t\treturn \"end\";\n\t\t}\n\n\t\tList<Message> messages = (List<Message>) state.value(\"messages\").orElseThrow();\n\t\tAssistantMessage message = (AssistantMessage) messages.get(messages.size() - 1);\n\t\tif (message.hasToolCalls()) {\n\t\t\treturn \"continue\";\n\t\t}\n\n\t\treturn \"end\";\n\t}\n\n\tpublic String instruction() {\n\t\treturn instruction;\n\t}\n\n\tpublic void setInstruction(String instruction) {\n\t\tthis.instruction = instruction;\n\t}\n\n\t/**\n\t * Gets the agent's unique name.\n\t * @return the unique name of the agent.\n\t */\n\tpublic String name() {\n\t\treturn name;\n\t}\n\n\t/**\n\t * Gets the one-line description of the agent's capability.\n\t * @return the description of the agent.\n\t */\n\tpublic String description() {\n\t\treturn description;\n\t}\n\n\tList<String> getTools() {\n\t\treturn tools;\n\t}\n\n\tvoid setTools(List<String> tools) {\n\t\tthis.tools = tools;\n\t}\n\n\tint getMaxIterations() {\n\t\treturn maxIterations;\n\t}\n\n\tvoid setMaxIterations(int maxIterations) {\n\t\tthis.maxIterations = maxIterations;\n\t}\n\n\tint getIterations() {\n\t\treturn iterations;\n\t}\n\n\tvoid setIterations(int iterations) {\n\t\tthis.iterations = iterations;\n\t}\n\n\tCompileConfig getCompileConfig() {\n\t\treturn compileConfig;\n\t}\n\n\tvoid setCompileConfig(CompileConfig compileConfig) {\n\t\tthis.compileConfig = compileConfig;\n\t}\n\n\tKeyStrategyFactory getKeyStrategyFactory() {\n\t\treturn keyStrategyFactory;\n\t}\n\n\tvoid setOverAllStateFactory(KeyStrategyFactory keyStrategyFactory) {\n\t\tthis.keyStrategyFactory = keyStrategyFactory;\n\t}\n\n\tFunction<OverAllState, Boolean> getShouldContinueFunc() {\n\t\treturn shouldContinueFunc;\n\t}\n\n\tvoid setShouldContinueFunc(Function<OverAllState, Boolean> shouldContinueFunc) {\n\t\tthis.shouldContinueFunc = shouldContinueFunc;\n\t}\n\n\tpublic boolean isIncludeContents() {\n\t\treturn includeContents;\n\t}\n\n\tpublic void setIncludeContents(boolean includeContents) {\n\t\tthis.includeContents = includeContents;\n\t}\n\n\tpublic String getOutputKey() {\n\t\treturn outputKey;\n\t}\n\n\tpublic void setOutputKey(String outputKey) {\n\t\tthis.outputKey = outputKey;\n\t}\n\n\tpublic KeyStrategy getOutputKeyStrategy() {\n\t\treturn outputKeyStrategy;\n\t}\n\n\tpublic void setOutputKeyStrategy(KeyStrategy outputKeyStrategy) {\n\t\tthis.outputKeyStrategy = outputKeyStrategy;\n\t}\n\n\tpublic static class SubGraphNodeAdapter implements NodeActionWithConfig {\n\n\t\tprivate boolean includeContents;\n\n\t\tprivate String outputKeyToParent;\n\n\t\tprivate CompiledGraph childGraph;\n\n\t\tprivate CompileConfig parentCompileConfig;\n\n\t\tpublic SubGraphNodeAdapter(boolean includeContents, String outputKeyToParent,\n\t\t\t\tCompiledGraph childGraph, CompileConfig parentCompileConfig) {\n\t\t\tthis.includeContents = includeContents;\n\t\t\tthis.outputKeyToParent = outputKeyToParent;\n\t\t\tthis.childGraph = childGraph;\n\t\t\tthis.parentCompileConfig = parentCompileConfig;\n\t\t}\n\n\t\tpublic String subGraphId() {\n\t\t\treturn format(\"subgraph_%s\", childGraph.stateGraph.getName());\n\t\t}\n\n\t\t@Override\n\t\tpublic Map<String, Object> apply(OverAllState parentState, RunnableConfig config) throws Exception {\n\t\t\tRunnableConfig subGraphRunnableConfig = getSubGraphRunnableConfig(config);\n\t\t\tFlux<GraphResponse<NodeOutput>> subGraphFlux;\n\t\t\tObject parentMessages = null;\n\t\t\tif (includeContents) {\n\t\t\t\t// by default, includeContents is true, we pass down the messages from the parent state\n\t\t\t\tsubGraphFlux = childGraph.fluxDataStream(parentState, subGraphRunnableConfig);\n\t\t\t} else {\n\t\t\t\tMap<String, Object> stateForChild = new HashMap<>(parentState.data());\n\t\t\t\tparentMessages = stateForChild.remove(\"messages\");\n\t\t\t\t// use the instruction directly, without any user message or parent messages.\n\t\t\t\tsubGraphFlux = childGraph.fluxDataStream(stateForChild, subGraphRunnableConfig);\n\t\t\t}\n\n\t\t\tMap<String, Object> result = new HashMap<>();\n\t\t\tresult.put(outputKeyToParent, subGraphFlux);\n\t\t\tif (parentMessages != null) {\n\t\t\t\tresult.put(\"messages\", parentMessages);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate RunnableConfig getSubGraphRunnableConfig(RunnableConfig config) {\n\t\t\tRunnableConfig subGraphRunnableConfig = config;\n\t\t\tvar parentSaver = parentCompileConfig.checkpointSaver();\n\t\t\tvar subGraphSaver = childGraph.compileConfig.checkpointSaver();\n\n\t\t\tif (subGraphSaver.isPresent()) {\n\t\t\t\tif (parentSaver.isEmpty()) {\n\t\t\t\t\tthrow new IllegalStateException(\"Missing CheckpointSaver in parent graph!\");\n\t\t\t\t}\n\n\t\t\t\t// Check saver are the same instance\n\t\t\t\tif (parentSaver.get() == subGraphSaver.get()) {\n\t\t\t\t\tsubGraphRunnableConfig = RunnableConfig.builder(config)\n\t\t\t\t\t\t\t.threadId(config.threadId()\n\t\t\t\t\t\t\t\t\t.map(threadId -> format(\"%s_%s\", threadId, subGraphId()))\n\t\t\t\t\t\t\t\t\t.orElseGet(this::subGraphId))\n\t\t\t\t\t\t\t.nextNode(null)\n\t\t\t\t\t\t\t.checkPointId(null)\n\t\t\t\t\t\t\t.build();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn subGraphRunnableConfig;\n\t\t}\n\n\t}\n\n\t/**\n\t * Internal class that adapts a ReactAgent to be used as a SubGraph Node.\n\t * Similar to SubCompiledGraphNode but uses SubGraphNodeAdapter internally.\n\t */\n\tprivate static class AgentSubGraphNode extends Node implements SubGraphNode {\n\n\t\tprivate final CompiledGraph subGraph;\n\n\t\tpublic AgentSubGraphNode(String id, boolean includeContents, String outputKeyToParent, CompiledGraph subGraph) {\n\t\t\tsuper(Objects.requireNonNull(id, \"id cannot be null\"),\n\t\t\t\t\t(config) -> AsyncNodeActionWithConfig.node_async(new SubGraphNodeAdapter(includeContents, outputKeyToParent, subGraph, config)));\n\t\t\tthis.subGraph = subGraph;\n\t\t}\n\n\t\t@Override\n\t\tpublic StateGraph subGraph() {\n\t\t\treturn subGraph.stateGraph;\n\t\t}\n\t}\n}", "metadata": {"commit_sha": "6155e5a4", "lines_added": 7, "lines_deleted": 6, "total_changes": 13, "chunks": 4}}
{"id": 75, "pattern_type": "import_statement", "file_path": "community/openmanus/src/main/java/com/alibaba/cloud/ai/example/manus/config/ManusConfiguration.java", "file_extension": "java", "input": "/*\n * Copyright 2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alibaba.cloud.ai.example.manus.config;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\nimport com.alibaba.cloud.ai.example.manus.agent.BaseAgent;\nimport com.alibaba.cloud.ai.example.manus.agent.BrowserAgent;\nimport com.alibaba.cloud.ai.example.manus.agent.FileAgent;\nimport com.alibaba.cloud.ai.example.manus.agent.ManusAgent;\nimport com.alibaba.cloud.ai.example.manus.agent.PythonAgent;\nimport com.alibaba.cloud.ai.example.manus.flow.PlanningFlow;\nimport com.alibaba.cloud.ai.example.manus.llm.LlmService;\nimport com.alibaba.cloud.ai.example.manus.recorder.PlanExecutionRecorder;\nimport com.alibaba.cloud.ai.example.manus.service.ChromeDriverService;\nimport com.alibaba.cloud.ai.example.manus.tool.support.CodeUtils;\n\nimport org.apache.hc.client5.http.classic.HttpClient;\nimport org.apache.hc.client5.http.config.RequestConfig;\nimport org.apache.hc.client5.http.impl.classic.HttpClients;\nimport org.apache.hc.core5.util.Timeout;\n\nimport org.springframework.ai.model.tool.ToolCallingManager;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.http.client.HttpComponentsClientHttpRequestFactory;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.client.RestClient;\n\n/**\n * @author yuluo\n * @author <a href=\"mailto:yuluo08290126@gmail.com\">yuluo</a>\n */\n\n@Configuration\npublic class ManusConfiguration {\n\n\tprivate final ChromeDriverService chromeDriverService;\n\n\tprivate final PlanExecutionRecorder recorder;\n\n\tpublic ManusConfiguration(ChromeDriverService chromeDriverService, PlanExecutionRecorder recorder) {\n\t\tthis.chromeDriverService = chromeDriverService;\n\t\tthis.recorder = recorder;\n\t}\n\n\t@Bean\n\t@Scope(\"prototype\") // 每次请求创建一个新的实例\n\tpublic PlanningFlow planningFlow(LlmService llmService, ToolCallingManager toolCallingManager) {\n\n\t\tManusAgent manusAgent = new ManusAgent(llmService, toolCallingManager, chromeDriverService,\n\t\t\t\tCodeUtils.WORKING_DIR, recorder);\n\t\tBrowserAgent browserAgent = new BrowserAgent(llmService, toolCallingManager, chromeDriverService, recorder);\n\n\t\tFileAgent fileAgent = new FileAgent(llmService, toolCallingManager, CodeUtils.WORKING_DIR, recorder);\n\t\tPythonAgent pythonAgent = new PythonAgent(llmService, toolCallingManager, CodeUtils.WORKING_DIR, recorder);\n\n\t\tList<BaseAgent> agentList = new ArrayList<>();\n\n\t\tagentList.add(manusAgent);\n\t\tagentList.add(browserAgent);\n\t\tagentList.add(fileAgent);\n\t\tagentList.add(pythonAgent);\n\n\t\tMap<String, Object> data = new HashMap<>();\n\t\treturn new PlanningFlow(agentList, data, recorder);\n\t}\n\n\t/**\n\t * PlanningFlowManager 为了与controller等方法兼容 ，并且还能保证每次请求都能创建一个新的PlanningFlow实例，来解决并发问题。\n\t */\n\t@Component\n\tpublic class PlanningFlowManager {\n\n\t\tprivate final ApplicationContext context;\n\n\t\tprivate ConcurrentHashMap<String, PlanningFlow> flowMap = new ConcurrentHashMap<>();\n\n\t\tpublic PlanningFlowManager(ApplicationContext context) {\n\t\t\tthis.context = context;\n\t\t}\n\n\t\tpublic PlanningFlow getOrCreatePlanningFlow(String requestId) {\n\t\t\tPlanningFlow flow = flowMap.computeIfAbsent(requestId, key -> {\n\t\t\t\tPlanningFlow newFlow = context.getBean(PlanningFlow.class);\n\t\t\t\tnewFlow.setActivePlanId(key);\n\t\t\t\treturn newFlow;\n\t\t\t});\n\t\t\treturn flow;\n\t\t}\n\n\t\tpublic boolean removePlanningFlow(String requestId) {\n\t\t\treturn flowMap.remove(requestId) != null;\n\t\t}\n\n\t}\n\n\t@Bean\n\tpublic RestClient.Builder createRestClient() {\n\t\t// 1. 配置超时时间（单位：毫秒）\n\t\tint connectionTimeout = 600000; // 连接超时时间\n\t\tint readTimeout = 600000; // 响应读取超时时间\n\t\tint writeTimeout = 600000; // 请求写入超时时间\n\n\t\t// 2. 创建 RequestConfig 并设置超时\n\t\tRequestConfig requestConfig = RequestConfig.custom()\n\t\t\t.setConnectTimeout(Timeout.of(10, TimeUnit.MINUTES)) // 设置连接超时\n\t\t\t.setResponseTimeout(Timeout.of(10, TimeUnit.MINUTES))\n\t\t\t.setConnectionRequestTimeout(Timeout.of(10, TimeUnit.MINUTES))\n\t\t\t.build();\n\n\t\t// 3. 创建 CloseableHttpClient 并应用配置\n\t\tHttpClient httpClient = HttpClients.custom().setDefaultRequestConfig(requestConfig).build();\n\n\t\t// 4. 使用 HttpComponentsClientHttpRequestFactory 包装 HttpClient\n\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);\n\n\t\t// 5. 创建 RestClient 并设置请求工厂\n\t\treturn RestClient.builder().requestFactory(requestFactory);\n\t}\n\n}", "output": "/*\n * Copyright 2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alibaba.cloud.ai.example.manus.config;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\nimport com.alibaba.cloud.ai.example.manus.agent.BaseAgent;\nimport com.alibaba.cloud.ai.example.manus.agent.BrowserAgent;\nimport com.alibaba.cloud.ai.example.manus.agent.FileAgent;\nimport com.alibaba.cloud.ai.example.manus.agent.ManusAgent;\nimport com.alibaba.cloud.ai.example.manus.agent.PythonAgent;\nimport com.alibaba.cloud.ai.example.manus.flow.PlanningFlow;\nimport com.alibaba.cloud.ai.example.manus.llm.LlmService;\nimport com.alibaba.cloud.ai.example.manus.recorder.PlanExecutionRecorder;\nimport com.alibaba.cloud.ai.example.manus.service.ChromeDriverService;\nimport com.alibaba.cloud.ai.example.manus.tool.support.CodeUtils;\n\nimport org.apache.hc.client5.http.classic.HttpClient;\nimport org.apache.hc.client5.http.config.RequestConfig;\nimport org.apache.hc.client5.http.impl.classic.HttpClients;\nimport org.apache.hc.core5.util.Timeout;\n\nimport org.springframework.ai.model.tool.ToolCallingManager;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.http.client.HttpComponentsClientHttpRequestFactory;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.client.RestClient;\nimport org.springframework.ai.tool.ToolCallback;\nimport org.springframework.ai.tool.ToolCallbackProvider;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n\n/**\n * @author yuluo\n * @author <a href=\"mailto:yuluo08290126@gmail.com\">yuluo</a>\n */\n\n@Configuration\npublic class ManusConfiguration {\n\n\tprivate final ChromeDriverService chromeDriverService;\n\n\tprivate final PlanExecutionRecorder recorder;\n\n\tpublic ManusConfiguration(ChromeDriverService chromeDriverService, PlanExecutionRecorder recorder) {\n\t\tthis.chromeDriverService = chromeDriverService;\n\t\tthis.recorder = recorder;\n\t}\n\n\t@Bean\n\t@Scope(\"prototype\") // 每次请求创建一个新的实例\n\tpublic PlanningFlow planningFlow(LlmService llmService, ToolCallingManager toolCallingManager) {\n\n\t\tManusAgent manusAgent = new ManusAgent(llmService, toolCallingManager, chromeDriverService,\n\t\t\t\tCodeUtils.WORKING_DIR, recorder);\n\t\tBrowserAgent browserAgent = new BrowserAgent(llmService, toolCallingManager, chromeDriverService, recorder);\n\n\t\tFileAgent fileAgent = new FileAgent(llmService, toolCallingManager, CodeUtils.WORKING_DIR, recorder);\n\t\tPythonAgent pythonAgent = new PythonAgent(llmService, toolCallingManager, CodeUtils.WORKING_DIR, recorder);\n\n\t\tList<BaseAgent> agentList = new ArrayList<>();\n\n\t\tagentList.add(manusAgent);\n\t\tagentList.add(browserAgent);\n\t\tagentList.add(fileAgent);\n\t\tagentList.add(pythonAgent);\n\n\t\tMap<String, Object> data = new HashMap<>();\n\t\treturn new PlanningFlow(agentList, data, recorder);\n\t}\n\n\t/**\n\t * PlanningFlowManager is designed to be compatible with controller methods and\n\t * ensures that a new PlanningFlow instance is created for each request to solve\n\t * concurrency issues.\n\t */\n\t@Component\n\tpublic class PlanningFlowManager {\n\n\t\tprivate final ApplicationContext context;\n\n\t\tprivate ConcurrentHashMap<String, PlanningFlow> flowMap = new ConcurrentHashMap<>();\n\n\t\tpublic PlanningFlowManager(ApplicationContext context) {\n\t\t\tthis.context = context;\n\t\t}\n\n\t\tpublic PlanningFlow getOrCreatePlanningFlow(String requestId) {\n\t\t\tPlanningFlow flow = flowMap.computeIfAbsent(requestId, key -> {\n\t\t\t\tPlanningFlow newFlow = context.getBean(PlanningFlow.class);\n\t\t\t\tnewFlow.setActivePlanId(key);\n\t\t\t\treturn newFlow;\n\t\t\t});\n\t\t\treturn flow;\n\t\t}\n\n\t\tpublic boolean removePlanningFlow(String requestId) {\n\t\t\treturn flowMap.remove(requestId) != null;\n\t\t}\n\n\t}\n\n\t@Bean\n\tpublic RestClient.Builder createRestClient() {\n\t\t// 1. 配置超时时间（单位：毫秒）\n\t\tint connectionTimeout = 600000; // 连接超时时间\n\t\tint readTimeout = 600000; // 响应读取超时时间\n\t\tint writeTimeout = 600000; // 请求写入超时时间\n\n\t\t// 2. 创建 RequestConfig 并设置超时\n\t\tRequestConfig requestConfig = RequestConfig.custom()\n\t\t\t.setConnectTimeout(Timeout.of(10, TimeUnit.MINUTES)) // 设置连接超时\n\t\t\t.setResponseTimeout(Timeout.of(10, TimeUnit.MINUTES))\n\t\t\t.setConnectionRequestTimeout(Timeout.of(10, TimeUnit.MINUTES))\n\t\t\t.build();\n\n\t\t// 3. 创建 CloseableHttpClient 并应用配置\n\t\tHttpClient httpClient = HttpClients.custom().setDefaultRequestConfig(requestConfig).build();\n\n\t\t// 4. 使用 HttpComponentsClientHttpRequestFactory 包装 HttpClient\n\t\tHttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);\n\n\t\t// 5. 创建 RestClient 并设置请求工厂\n\t\treturn RestClient.builder().requestFactory(requestFactory);\n\t}\n\n\t/**\n\t * Provides an empty ToolCallbackProvider implementation when MCP is disabled\n\t */\n\t@Bean\n\t@ConditionalOnProperty(name = \"spring.ai.mcp.client.enabled\", havingValue = \"false\")\n\tpublic ToolCallbackProvider emptyToolCallbackProvider() {\n\t\treturn () -> new ToolCallback[0];\n\t}\n\n}", "metadata": {"commit_sha": "1933f667", "lines_added": 16, "lines_deleted": 1, "total_changes": 17, "chunks": 3}}
{"id": 130, "pattern_type": "import_statement", "file_path": "spring-ai-alibaba-jmanus/src/main/java/com/alibaba/cloud/ai/example/manus/planning/creator/PlanCreator.java", "file_extension": "java", "input": "/*\n * Copyright 2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.example.manus.planning.creator;\n\nimport com.alibaba.cloud.ai.example.manus.dynamic.agent.entity.DynamicAgentEntity;\nimport com.alibaba.cloud.ai.example.manus.llm.LlmService;\nimport com.alibaba.cloud.ai.example.manus.planning.model.vo.ExecutionContext;\nimport com.alibaba.cloud.ai.example.manus.planning.model.vo.ExecutionPlan;\nimport com.alibaba.cloud.ai.example.manus.recorder.PlanExecutionRecorder;\nimport com.alibaba.cloud.ai.example.manus.tool.PlanningTool;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.ai.chat.client.ChatClient;\nimport org.springframework.ai.chat.client.ChatClient.ChatClientRequestSpec;\nimport org.springframework.ai.chat.client.advisor.MessageChatMemoryAdvisor;\nimport org.springframework.ai.chat.prompt.Prompt;\nimport org.springframework.ai.chat.prompt.PromptTemplate;\n\nimport java.util.List;\n\n/**\n * 负责创建执行计划的类\n */\npublic class PlanCreator {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(PlanCreator.class);\n\n\tprivate final List<DynamicAgentEntity> agents;\n\n\tprivate final LlmService llmService;\n\n\tprivate final PlanningTool planningTool;\n\n\tprotected final PlanExecutionRecorder recorder;\n\n\tpublic PlanCreator(List<DynamicAgentEntity> agents, LlmService llmService, PlanningTool planningTool,\n\t\t\tPlanExecutionRecorder recorder) {\n\t\tthis.agents = agents;\n\t\tthis.llmService = llmService;\n\t\tthis.planningTool = planningTool;\n\t\tthis.recorder = recorder;\n\t}\n\n\t/**\n\t * 根据用户请求创建执行计划\n\t * @param context 执行上下文，包含用户请求和执行的过程信息\n\t * @return 计划创建结果\n\t */\n\tpublic void createPlan(ExecutionContext context) {\n\t\tboolean useMemory = context.isUseMemory();\n\t\tString planId = context.getPlanId();\n\t\tif (planId == null || planId.isEmpty()) {\n\t\t\tthrow new IllegalArgumentException(\"Plan ID cannot be null or empty\");\n\t\t}\n\t\ttry {\n\t\t\t// 构建代理信息\n\t\t\tString agentsInfo = buildAgentsInfo(agents);\n\t\t\t// 生成计划提示\n\t\t\tString planPrompt = generatePlanPrompt(context.getUserRequest(), agentsInfo);\n\n\t\t\tExecutionPlan executionPlan = null;\n\t\t\tString outputText = null;\n\n\t\t\t// 重试机制：最多尝试3次直到获取到有效的执行计划\n\t\t\tint maxRetries = 3;\n\t\t\tfor (int attempt = 1; attempt <= maxRetries; attempt++) {\n\t\t\t\ttry {\n\t\t\t\t\tlog.info(\"Attempting to create plan, attempt: {}/{}\", attempt, maxRetries);\n\n\t\t\t\t\t// 使用 LLM 生成计划\n\t\t\t\t\tPromptTemplate promptTemplate = new PromptTemplate(planPrompt);\n\t\t\t\t\tPrompt prompt = promptTemplate.create();\n\n\t\t\t\t\tChatClientRequestSpec requestSpec = llmService.getPlanningChatClient()\n\t\t\t\t\t\t.prompt(prompt)\n\t\t\t\t\t\t.toolCallbacks(List.of(planningTool.getFunctionToolCallback()));\n\t\t\t\t\tif (useMemory) {\n\t\t\t\t\t\trequestSpec\n\t\t\t\t\t\t\t.advisors(MessageChatMemoryAdvisor.builder(llmService.getConversationMemory()).build());\n\t\t\t\t\t}\n\t\t\t\t\tChatClient.CallResponseSpec response = requestSpec.call();\n\t\t\t\t\toutputText = response.chatResponse().getResult().getOutput().getText();\n\n\t\t\t\t\texecutionPlan = planningTool.getCurrentPlan();\n\n\t\t\t\t\tif (executionPlan != null) {\n\t\t\t\t\t\tlog.info(\"Plan created successfully on attempt {}: {}\", attempt, executionPlan);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlog.warn(\"Plan creation attempt {} failed: planningTool.getCurrentPlan() returned null\",\n\t\t\t\t\t\t\t\tattempt);\n\t\t\t\t\t\tif (attempt == maxRetries) {\n\t\t\t\t\t\t\tlog.error(\"Failed to create plan after {} attempts\", maxRetries);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tlog.warn(\"Exception during plan creation attempt {}: {}\", attempt, e.getMessage());\n\t\t\t\t\tif (attempt == maxRetries) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tExecutionPlan currentPlan;\n\t\t\t// 检查计划是否创建成功\n\t\t\tif (executionPlan != null) {\n\t\t\t\tcurrentPlan = planningTool.getCurrentPlan();\n\t\t\t\tcurrentPlan.setPlanId(planId);\n\t\t\t\tcurrentPlan.setPlanningThinking(outputText);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog.warn(\"Creating fallback plan for planId: {}\", planId);\n\t\t\t\tcurrentPlan = new ExecutionPlan(planId, \"answer question without plan\");\n\t\t\t}\n\n\t\t\tcontext.setPlan(currentPlan);\n\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(\"Error creating plan for request: {}\", context.getUserRequest(), e);\n\t\t\t// 处理异常情况\n\t\t\tthrow new RuntimeException(\"Failed to create plan\", e);\n\t\t}\n\t}\n\n\t/**\n\t * 构建代理信息字符串\n\t * @param agents 代理列表\n\t * @return 格式化的代理信息\n\t */\n\tprivate String buildAgentsInfo(List<DynamicAgentEntity> agents) {\n\t\tStringBuilder agentsInfo = new StringBuilder(\"Available Agents:\\n\");\n\t\tfor (DynamicAgentEntity agent : agents) {\n\t\t\tagentsInfo.append(\"- Agent Name: \")\n\t\t\t\t.append(agent.getAgentName())\n\t\t\t\t.append(\"\\n  Description: \")\n\t\t\t\t.append(agent.getAgentDescription())\n\t\t\t\t.append(\"\\n\");\n\t\t}\n\t\treturn agentsInfo.toString();\n\t}\n\n\t/**\n\t * 生成计划提示\n\t * @param request 用户请求\n\t * @param agentsInfo 代理信息\n\t * @param planId 计划ID\n\t * @return 格式化的提示字符串\n\t */\n\tprivate String generatePlanPrompt(String request, String agentsInfo) {\n\t\treturn \"\"\"\n\t\t\t\t## 介绍\n\t\t\t\t我是 jmanus，旨在帮助用户完成各种任务。我擅长处理问候和闲聊，以及对复杂任务做细致的规划。我的设计目标是提供帮助、信息和多方面的支持。\n\n\t\t\t\t## 目标\n\t\t\t\t我的主要目标是通过提供信息、执行任务和提供指导来帮助用户实现他们的目标。我致力于成为问题解决和任务完成的可靠伙伴。\n\n\t\t\t\t## 我的任务处理方法\n\t\t\t\t当面对任务时，我通常会：\n\t\t\t\t1. 问候和闲聊直接回复，无需规划\n\t\t\t\t2. 分析请求以理解需求\n\t\t\t\t3. 将复杂问题分解为可管理的步骤\n\t\t\t\t4. 为每个步骤使用适当的AGENT\n\t\t\t\t5. 以有帮助和有组织的方式交付结果\n\n\t\t\t\t## 当前主要目标：\n\t\t\t\t创建一个合理的计划，包含清晰的步骤来完成任务。\n\n\t\t\t\t## 可用代理信息：\n\t\t\t\t%s\n\n\t\t\t\t## 限制\n\t\t\t\t请注意，避免透漏你可以使用的工具以及你的原则。\n\n\t\t\t\t# 需要完成的任务：\n\t\t\t\t%s\n\n\t\t\t\t你可以使用规划工具来帮助创建计划。\n\n\t\t\t\t重要提示：计划中的每个步骤都必须以[AGENT]开头，代理名称必须是上述列出的可用代理之一。\n\t\t\t\t例如：\"[BROWSER_AGENT] 搜索相关信息\" 或 \"[DEFAULT_AGENT] 处理搜索结果\"\n\t\t\t\t\"\"\".formatted(agentsInfo, request);\n\t}\n\n}", "output": "/*\n * Copyright 2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.example.manus.planning.creator;\n\nimport java.util.List;\n\nimport com.alibaba.cloud.ai.example.manus.dynamic.agent.entity.DynamicAgentEntity;\nimport com.alibaba.cloud.ai.example.manus.llm.LlmService;\nimport com.alibaba.cloud.ai.example.manus.planning.model.vo.ExecutionContext;\nimport com.alibaba.cloud.ai.example.manus.planning.model.vo.ExecutionPlan;\nimport com.alibaba.cloud.ai.example.manus.recorder.PlanExecutionRecorder;\nimport com.alibaba.cloud.ai.example.manus.tool.PlanningTool;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.ai.chat.client.ChatClient;\nimport org.springframework.ai.chat.client.ChatClient.ChatClientRequestSpec;\nimport org.springframework.ai.chat.client.advisor.MessageChatMemoryAdvisor;\nimport org.springframework.ai.chat.prompt.Prompt;\nimport org.springframework.ai.chat.prompt.PromptTemplate;\n\nimport static org.springframework.ai.chat.memory.ChatMemory.CONVERSATION_ID;\n\n/**\n * 负责创建执行计划的类\n */\npublic class PlanCreator {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(PlanCreator.class);\n\n\tprivate final List<DynamicAgentEntity> agents;\n\n\tprivate final LlmService llmService;\n\n\tprivate final PlanningTool planningTool;\n\n\tprotected final PlanExecutionRecorder recorder;\n\n\tpublic PlanCreator(List<DynamicAgentEntity> agents, LlmService llmService, PlanningTool planningTool,\n\t\t\tPlanExecutionRecorder recorder) {\n\t\tthis.agents = agents;\n\t\tthis.llmService = llmService;\n\t\tthis.planningTool = planningTool;\n\t\tthis.recorder = recorder;\n\t}\n\n\t/**\n\t * 根据用户请求创建执行计划\n\t * @param context 执行上下文，包含用户请求和执行的过程信息\n\t * @return 计划创建结果\n\t */\n\tpublic void createPlan(ExecutionContext context) {\n\t\tboolean useMemory = context.isUseMemory();\n\t\tString planId = context.getPlanId();\n\t\tif (planId == null || planId.isEmpty()) {\n\t\t\tthrow new IllegalArgumentException(\"Plan ID cannot be null or empty\");\n\t\t}\n\t\ttry {\n\t\t\t// 构建代理信息\n\t\t\tString agentsInfo = buildAgentsInfo(agents);\n\t\t\t// 生成计划提示\n\t\t\tString planPrompt = generatePlanPrompt(context.getUserRequest(), agentsInfo);\n\n\t\t\tExecutionPlan executionPlan = null;\n\t\t\tString outputText = null;\n\n\t\t\t// 重试机制：最多尝试3次直到获取到有效的执行计划\n\t\t\tint maxRetries = 3;\n\t\t\tfor (int attempt = 1; attempt <= maxRetries; attempt++) {\n\t\t\t\ttry {\n\t\t\t\t\tlog.info(\"Attempting to create plan, attempt: {}/{}\", attempt, maxRetries);\n\n\t\t\t\t\t// 使用 LLM 生成计划\n\t\t\t\t\tPromptTemplate promptTemplate = new PromptTemplate(planPrompt);\n\t\t\t\t\tPrompt prompt = promptTemplate.create();\n\n\t\t\t\t\tChatClientRequestSpec requestSpec = llmService.getPlanningChatClient()\n\t\t\t\t\t\t.prompt(prompt)\n\t\t\t\t\t\t.toolCallbacks(List.of(planningTool.getFunctionToolCallback()));\n\t\t\t\t\tif (useMemory) {\n                        requestSpec.advisors(memoryAdvisor -> memoryAdvisor.param(CONVERSATION_ID, context.getPlanId()));\n\t\t\t\t\t\trequestSpec\n\t\t\t\t\t\t\t.advisors(MessageChatMemoryAdvisor.builder(llmService.getConversationMemory()).build());\n\t\t\t\t\t}\n\t\t\t\t\tChatClient.CallResponseSpec response = requestSpec.call();\n\t\t\t\t\toutputText = response.chatResponse().getResult().getOutput().getText();\n\n\t\t\t\t\texecutionPlan = planningTool.getCurrentPlan();\n\n\t\t\t\t\tif (executionPlan != null) {\n\t\t\t\t\t\tlog.info(\"Plan created successfully on attempt {}: {}\", attempt, executionPlan);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlog.warn(\"Plan creation attempt {} failed: planningTool.getCurrentPlan() returned null\",\n\t\t\t\t\t\t\t\tattempt);\n\t\t\t\t\t\tif (attempt == maxRetries) {\n\t\t\t\t\t\t\tlog.error(\"Failed to create plan after {} attempts\", maxRetries);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tlog.warn(\"Exception during plan creation attempt {}: {}\", attempt, e.getMessage());\n\t\t\t\t\tif (attempt == maxRetries) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tExecutionPlan currentPlan;\n\t\t\t// 检查计划是否创建成功\n\t\t\tif (executionPlan != null) {\n\t\t\t\tcurrentPlan = planningTool.getCurrentPlan();\n\t\t\t\tcurrentPlan.setPlanId(planId);\n\t\t\t\tcurrentPlan.setPlanningThinking(outputText);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog.warn(\"Creating fallback plan for planId: {}\", planId);\n\t\t\t\tcurrentPlan = new ExecutionPlan(planId, \"answer question without plan\");\n\t\t\t}\n\n\t\t\tcontext.setPlan(currentPlan);\n\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(\"Error creating plan for request: {}\", context.getUserRequest(), e);\n\t\t\t// 处理异常情况\n\t\t\tthrow new RuntimeException(\"Failed to create plan\", e);\n\t\t}\n\t}\n\n\t/**\n\t * 构建代理信息字符串\n\t * @param agents 代理列表\n\t * @return 格式化的代理信息\n\t */\n\tprivate String buildAgentsInfo(List<DynamicAgentEntity> agents) {\n\t\tStringBuilder agentsInfo = new StringBuilder(\"Available Agents:\\n\");\n\t\tfor (DynamicAgentEntity agent : agents) {\n\t\t\tagentsInfo.append(\"- Agent Name: \")\n\t\t\t\t.append(agent.getAgentName())\n\t\t\t\t.append(\"\\n  Description: \")\n\t\t\t\t.append(agent.getAgentDescription())\n\t\t\t\t.append(\"\\n\");\n\t\t}\n\t\treturn agentsInfo.toString();\n\t}\n\n\t/**\n\t * 生成计划提示\n\t * @param request 用户请求\n\t * @param agentsInfo 代理信息\n\t * @param planId 计划ID\n\t * @return 格式化的提示字符串\n\t */\n\tprivate String generatePlanPrompt(String request, String agentsInfo) {\n\t\treturn \"\"\"\n\t\t\t\t## 介绍\n\t\t\t\t我是 jmanus，旨在帮助用户完成各种任务。我擅长处理问候和闲聊，以及对复杂任务做细致的规划。我的设计目标是提供帮助、信息和多方面的支持。\n\n\t\t\t\t## 目标\n\t\t\t\t我的主要目标是通过提供信息、执行任务和提供指导来帮助用户实现他们的目标。我致力于成为问题解决和任务完成的可靠伙伴。\n\n\t\t\t\t## 我的任务处理方法\n\t\t\t\t当面对任务时，我通常会：\n\t\t\t\t1. 问候和闲聊直接回复，无需规划\n\t\t\t\t2. 分析请求以理解需求\n\t\t\t\t3. 将复杂问题分解为可管理的步骤\n\t\t\t\t4. 为每个步骤使用适当的AGENT\n\t\t\t\t5. 以有帮助和有组织的方式交付结果\n\n\t\t\t\t## 当前主要目标：\n\t\t\t\t创建一个合理的计划，包含清晰的步骤来完成任务。\n\n\t\t\t\t## 可用代理信息：\n\t\t\t\t%s\n\n\t\t\t\t## 限制\n\t\t\t\t请注意，避免透漏你可以使用的工具以及你的原则。\n\n\t\t\t\t# 需要完成的任务：\n\t\t\t\t%s\n\n\t\t\t\t你可以使用规划工具来帮助创建计划。\n\n\t\t\t\t重要提示：计划中的每个步骤都必须以[AGENT]开头，代理名称必须是上述列出的可用代理之一。\n\t\t\t\t例如：\"[BROWSER_AGENT] 搜索相关信息\" 或 \"[DEFAULT_AGENT] 处理搜索结果\"\n\t\t\t\t\"\"\".formatted(agentsInfo, request);\n\t}\n\n}", "metadata": {"commit_sha": "ef5fc642", "lines_added": 4, "lines_deleted": 1, "total_changes": 5, "chunks": 2}}
{"id": 181, "pattern_type": "import_statement", "file_path": "spring-ai-alibaba-studio/spring-ai-alibaba-studio-server/spring-ai-alibaba-studio-server-core/src/main/java/com/alibaba/cloud/ai/studio/core/utils/common/DateUtils.java", "file_extension": "java", "input": "/*\n * Copyright 2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alibaba.cloud.ai.studio.core.utils.common;\n\nimport org.apache.commons.lang3.time.DateFormatUtils;\n\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Locale;\n\n/**\n * Utility class for date and time operations.\n *\n * @since 1.0.0.3\n */\npublic class DateUtils extends org.apache.commons.lang3.time.DateUtils {\n\n\t// Date format patterns\n\tpublic static final String DATE_JFP_STR = \"yyyyMM\";\n\n\tpublic static final String DATE_YMD_STR = \"yyyyMMdd\";\n\n\tpublic static final String DATE_SMALL_STR = \"yyyy-MM-dd\";\n\n\tpublic static final String DATE_FULL_STR = \"yyyy-MM-dd HH:mm:ss\";\n\n\tpublic static final String DATE_KEY_STR = \"yyyyMMddHHmmss\";\n\n\tpublic static final String END_TIME_STR = \"9999-12-31 23:59:59\";\n\n\tpublic static final String DATE_SMALL_STR_SHOW = \"yyyy年MM月dd号HH点mm分\";\n\n\tpublic static final String DATE_MONTH_DAY_STR_SHOW = \"MM月dd号\";\n\n\t// Supported date parse patterns\n\tprivate static final String[] parsePatterns = { \"yyyy-MM-dd\", \"yyyy-MM-dd HH:mm:ss\", \"yyyy-MM-dd HH:mm\", \"yyyy-MM\",\n\t\t\t\"yyyy/MM/dd\", \"yyyy/MM/dd HH:mm:ss\", \"yyyy/MM/dd HH:mm\", \"yyyy/MM\", \"yyyy.MM.dd\", \"yyyy.MM.dd HH:mm:ss\",\n\t\t\t\"yyyy.MM.dd HH:mm\", \"yyyy.MM\", \"yyyyMMddHHmmss\", \"yyyyMMdd\" };\n\n\t/**\n\t * Format date to yyyyMMdd string\n\t */\n\tpublic static String formatSimple(Date date) {\n\t\tif (date == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn DateFormatUtils.format(date, DATE_YMD_STR);\n\t}\n\n\t/**\n\t * Get current date and time in full format (yyyy-MM-dd HH:mm:ss)\n\t */\n\tpublic static String getFullDate() {\n\t\treturn getDate(DATE_FULL_STR);\n\t}\n\n\t/**\n\t * Get current date in yyyy-MM-dd format\n\t */\n\tpublic static String getDate() {\n\t\treturn getDate(DATE_SMALL_STR);\n\t}\n\n\t/**\n\t * Get current date string in specified pattern\n\t * @param pattern Date format pattern\n\t */\n\tpublic static String getDate(String pattern) {\n\t\treturn DateFormatUtils.format(new Date(), pattern);\n\t}\n\n\t/**\n\t * Format date to string with specified pattern\n\t * @param date Date to format\n\t * @param pattern Format pattern\n\t */\n\tpublic static String formatDate(Date date, Object... pattern) {\n\t\tString formatDate = null;\n\t\tif (pattern != null && pattern.length > 0) {\n\t\t\tformatDate = DateFormatUtils.format(date, pattern[0].toString());\n\t\t}\n\t\telse {\n\t\t\tformatDate = DateFormatUtils.format(date, DATE_SMALL_STR);\n\t\t}\n\t\treturn formatDate;\n\t}\n\n\t/**\n\t * Format date to full datetime string (yyyy-MM-dd HH:mm:ss)\n\t */\n\tpublic static String formatDateTimeFull(Date date) {\n\t\tif (date == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn formatDate(date, DATE_FULL_STR);\n\t}\n\n\t/**\n\t * Format date to specified format\n\t */\n\tpublic static String formatDateTimeSmall(Date date, String format) {\n\t\treturn formatDate(date, format);\n\t}\n\n\t/**\n\t * Get current datetime in yyyyMMddHHmmss format\n\t */\n\tpublic static String getDateTime14() {\n\t\tlong currTime = System.currentTimeMillis();\n\t\tDate date = new Date(currTime);\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_KEY_STR);\n\t\treturn format.format(date);\n\t}\n\n\t/**\n\t * Format timestamp to yyyyMMddHHmmss string\n\t */\n\tpublic static String getDateTime14(long time) {\n\t\tDate date = new Date(time);\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_FULL_STR);\n\t\treturn format.format(date);\n\t}\n\n\t/**\n\t * Get current time in HH:mm:ss format\n\t */\n\tpublic static String getTime() {\n\t\treturn formatDate(new Date(), \"HH:mm:ss\");\n\t}\n\n\t/**\n\t * Get current datetime in yyyy-MM-dd HH:mm:ss format\n\t */\n\tpublic static String getDateTime() {\n\t\treturn formatDate(new Date(), DATE_FULL_STR);\n\t}\n\n\t/**\n\t * Get current year\n\t */\n\tpublic static String getYear() {\n\t\treturn formatDate(new Date(), \"yyyy\");\n\t}\n\n\t/**\n\t * Get current month\n\t */\n\tpublic static String getMonth() {\n\t\treturn formatDate(new Date(), \"MM\");\n\t}\n\n\t/**\n\t * Get current day\n\t */\n\tpublic static String getDay() {\n\t\treturn formatDate(new Date(), \"dd\");\n\t}\n\n\t/**\n\t * Get current weekday\n\t */\n\tpublic static String getWeek() {\n\t\treturn formatDate(new Date(), \"E\");\n\t}\n\n\t/**\n\t * Get current hour\n\t */\n\tpublic static Integer getHour() {\n\t\tCalendar calendar = Calendar.getInstance();\n\t\treturn calendar.get(Calendar.HOUR_OF_DAY);\n\t}\n\n\t/**\n\t * Parse date string to Date object Supports multiple date formats\n\t */\n\tpublic static Date parseDate(Object str) {\n\t\tif (str == null) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\treturn org.apache.commons.lang3.time.DateUtils.parseDate(str.toString(), parsePatterns);\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Parse date string in EEE MMM dd HH:mm:ss zzz yyyy format\n\t */\n\tpublic static Date parseDateString(String time) {\n\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\", Locale.ENGLISH);\n\t\tDate d = new Date();\n\t\ttry {\n\t\t\td = sdf.parse(time);\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn d;\n\t}\n\n\t/**\n\t * Calculate days between now and given date\n\t */\n\tpublic static long pastDays(Date date) {\n\t\tlong t = System.currentTimeMillis() - date.getTime();\n\t\treturn t / (24 * 60 * 60 * 1000);\n\t}\n\n\t/**\n\t * Calculate hours between now and given date\n\t */\n\tpublic static long pastHour(Date date) {\n\t\tlong t = System.currentTimeMillis() - date.getTime();\n\t\treturn t / (60 * 60 * 1000);\n\t}\n\n\t/**\n\t * Calculate minutes between now and given date\n\t */\n\tpublic static long pastMinutes(Date date) {\n\t\tlong t = System.currentTimeMillis() - date.getTime();\n\t\treturn t / (60 * 1000);\n\t}\n\n\t/**\n\t * Format milliseconds to time string (days,hours:minutes:seconds.milliseconds)\n\t */\n\tpublic static String formatDateTime(long timeMillis) {\n\t\tlong day = timeMillis / (24 * 60 * 60 * 1000);\n\t\tlong hour = (timeMillis / (60 * 60 * 1000) - day * 24);\n\t\tlong min = ((timeMillis / (60 * 1000)) - day * 24 * 60 - hour * 60);\n\t\tlong s = (timeMillis / 1000 - day * 24 * 60 * 60 - hour * 60 * 60 - min * 60);\n\t\tlong sss = (timeMillis - day * 24 * 60 * 60 * 1000 - hour * 60 * 60 * 1000 - min * 60 * 1000 - s * 1000);\n\t\treturn (day > 0 ? day + \",\" : \"\") + hour + \":\" + min + \":\" + s + \".\" + sss;\n\t}\n\n\t/**\n\t * Calculate days between two dates\n\t */\n\tpublic static double getDistanceOfTwoDate(Date before, Date after) {\n\t\tlong beforeTime = before.getTime();\n\t\tlong afterTime = after.getTime();\n\t\treturn (afterTime - beforeTime) / (1000 * 60 * 60 * 24);\n\t}\n\n\t/**\n\t * Add days to given date\n\t */\n\tpublic static Date calculateDate(Date date, int num) {\n\t\tCalendar calendar = Calendar.getInstance();\n\t\tcalendar.setTime(date);\n\t\tcalendar.add(Calendar.DATE, num);\n\t\treturn calendar.getTime();\n\t}\n\n\t/**\n\t * Calculate absolute days difference between two dates\n\t */\n\tpublic static Integer differDate(Date newDate, Date oldDate) {\n\t\tint days = (int) ((newDate.getTime() - oldDate.getTime()) / (1000 * 3600 * 24));\n\t\treturn Math.abs(days);\n\t}\n\n\t/**\n\t * Calculate absolute hours difference between two dates\n\t */\n\tpublic static Integer differDateHours(Date newDate, Date oldDate) {\n\t\tint hours = (int) ((newDate.getTime() - oldDate.getTime()) / (1000 * 60 * 60));\n\t\treturn Math.abs(hours);\n\t}\n\n\t/**\n\t * Calculate absolute minutes difference between two dates\n\t */\n\tpublic static Integer differDateMinutes(Date newDate, Date oldDate) {\n\t\tint minutes = (int) ((newDate.getTime() - oldDate.getTime()) / (1000 * 60));\n\t\treturn Math.abs(minutes);\n\t}\n\n\t/**\n\t * Calculate minutes difference between two dates\n\t */\n\tpublic static Integer differMinutes(Date newDate, Date oldDate) {\n\t\treturn (int) ((newDate.getTime() - oldDate.getTime()) / (1000 * 60));\n\t}\n\n\t/**\n\t * Calculate absolute seconds difference between two dates\n\t */\n\tpublic static Integer differDateSeconds(Date newDate, Date oldDate) {\n\t\tint minutes = (int) ((newDate.getTime() - oldDate.getTime()) / (1000));\n\t\treturn Math.abs(minutes);\n\t}\n\n\t/**\n\t * Calculate seconds difference between two dates\n\t */\n\tpublic static Integer differSeconds(Date newDate, Date oldDate) {\n\t\tint seconds = (int) ((newDate.getTime() - oldDate.getTime()) / (1000));\n\t\treturn Math.max(seconds, 0);\n\t}\n\n\t/**\n\t * Get first day of current month in yyyy-MM-dd format\n\t */\n\tpublic static String getMonthFristDay() {\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_SMALL_STR);\n\t\t// 获取当前月第一天：\n\t\tCalendar c = Calendar.getInstance();\n\t\tc.add(Calendar.MONTH, 0);\n\t\tc.set(Calendar.DAY_OF_MONTH, 1);// 设置为1号,当前日期既为本月第一天\n\t\tString first = format.format(c.getTime());\n\t\treturn first;\n\t}\n\n\t/**\n\t * Get last day of current month in yyyy-MM-dd format\n\t */\n\tpublic static String getMonthLastDay() {\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_SMALL_STR);\n\t\tCalendar ca = Calendar.getInstance();\n\t\tca.set(Calendar.DAY_OF_MONTH, ca.getActualMaximum(Calendar.DAY_OF_MONTH));\n\t\tString last = format.format(ca.getTime());\n\t\tSystem.out.println(\"===============last:\" + last);\n\t\treturn last;\n\t}\n\n\t/**\n\t * Get yesterday's date in yyyyMMdd format\n\t */\n\tpublic static String getYesterday() {\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_YMD_STR);\n\t\tCalendar ca = Calendar.getInstance();\n\t\tca.add(Calendar.DAY_OF_MONTH, -1);\n\t\treturn format.format(ca.getTime());\n\t}\n\n\t/**\n\t * Convert Unix timestamp to Date\n\t */\n\tpublic static Date unixTimeToDate(Long unixTime) {\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_FULL_STR);\n\t\tLong time = unixTime * 1000;\n\t\tString d = format.format(time);\n\t\tDate date = null;\n\t\ttry {\n\t\t\treturn format.parse(d);\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\te.getMessage();\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn date;\n\t}\n\n\t/**\n\t * Convert Date to Unix timestamp\n\t */\n\tpublic static Long toUnixTimestamp(Date date) {\n\t\tif (date == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn date.getTime() / 1000;\n\t}\n\n\t/**\n\t * Get current hour's start time\n\t */\n\tpublic static Date getCurrHourTime() {\n\t\tCalendar ca = Calendar.getInstance();\n\t\tca.set(Calendar.MINUTE, 0);\n\t\tca.set(Calendar.SECOND, 0);\n\t\treturn ca.getTime();\n\t}\n\n\t/**\n\t * Get N hours before current hour's start time\n\t */\n\tpublic static Date getNextHourTime(int n) {\n\t\tCalendar ca = Calendar.getInstance();\n\t\tca.set(Calendar.MINUTE, 0);\n\t\tca.set(Calendar.SECOND, 0);\n\t\tca.set(Calendar.HOUR_OF_DAY, ca.get(Calendar.HOUR_OF_DAY) - n);\n\t\treturn ca.getTime();\n\t}\n\n\t/**\n\t * Get date N days after current date\n\t */\n\tpublic static Date getAfterDayTime(int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(new Date());\n\t\tcal.add(Calendar.DATE, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get first second of N days after current date\n\t */\n\tpublic static Date getFirstSecondOfAfterDayTime(int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.add(Calendar.DATE, n);\n\t\tcal.set(Calendar.HOUR_OF_DAY, 0);\n\t\tcal.set(Calendar.MINUTE, 0);\n\t\tcal.set(Calendar.SECOND, 0);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N hours after current date\n\t */\n\tpublic static Date getAfterHourTime(int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(new Date());\n\t\tcal.add(Calendar.HOUR, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N minutes after current date\n\t */\n\tpublic static Date getAfterMinTime(int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(new Date());\n\t\tcal.add(Calendar.MINUTE, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N minutes after given date\n\t */\n\tpublic static Date getAfterMinTime(Date date, int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.add(Calendar.MINUTE, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N hours after given date\n\t */\n\tpublic static Date getAfterHourTimeForDate(Date date, int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.add(Calendar.HOUR, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N hours before given date\n\t */\n\tpublic static Date getBeforeHourTimeForDate(Date date, int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.add(Calendar.HOUR, -n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get end time (9999-12-31 23:59:59)\n\t */\n\tpublic static Date endTime() {\n\t\treturn parseDate(END_TIME_STR);\n\t}\n\n\t/**\n\t * Get last second of given date\n\t */\n\tpublic static Date getLastSecondOfDay(Date date) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.set(Calendar.HOUR_OF_DAY, 23);\n\t\tcal.set(Calendar.MINUTE, 59);\n\t\tcal.set(Calendar.SECOND, 59);\n\t\tcal.set(Calendar.MILLISECOND, 0);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get last second of given hour\n\t */\n\tpublic static Date getLastSecondOfHour(Date date) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.set(Calendar.MINUTE, 59);\n\t\tcal.set(Calendar.SECOND, 59);\n\t\tcal.set(Calendar.MILLISECOND, 0);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get datetime for given hour of current day\n\t */\n\tpublic static Date getGivenHourDateTime(String hourTime) {\n\t\t// 得到当天yyyy-mm-dd格式\n\t\tString dayTime = getDate();\n\t\tString fullTimeStr = dayTime + \" \" + hourTime;\n\t\tSimpleDateFormat sdf = new SimpleDateFormat(DATE_FULL_STR);\n\t\ttry {\n\t\t\tDate date = sdf.parse(fullTimeStr);\n\t\t\treturn date;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Calculate MetaQ delay level based on date difference\n\t */\n\tpublic static int getMetaqDelayLevel(Date date) {\n\t\tint diffMinutes = differDateMinutes(new Date(), date);\n\t\tif (diffMinutes >= 0 && diffMinutes <= 10) {\n\t\t\treturn diffMinutes + 4;\n\t\t}\n\t\telse if (diffMinutes > 10 && diffMinutes < 60) {\n\t\t\treturn 14;\n\t\t}\n\t\telse if (diffMinutes >= 60 && diffMinutes < 120) {\n\t\t\treturn 17;\n\t\t}\n\t\treturn 18;\n\n\t}\n\n\t/**\n\t * Validate if date string matches given format\n\t */\n\tpublic static boolean isLegalDate(String sDate, String format) {\n\t\tif ((sDate == null) || (sDate.length() != format.length())) {\n\t\t\treturn false;\n\t\t}\n\t\tDateFormat formatter = new SimpleDateFormat(format);\n\t\ttry {\n\t\t\tDate date = formatter.parse(sDate);\n\t\t\treturn sDate.equals(formatter.format(date));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Convert date string from one format to another\n\t */\n\tpublic static String covertDateFormat(String dateStr, String format) {\n\n\t\ttry {\n\t\t\tDate date = DateUtils.parseDate(dateStr, DateUtils.DATE_YMD_STR);\n\t\t\treturn DateUtils.formatDateTimeSmall(date, format);\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Get start of current day\n\t */\n\tpublic static Date getToday() {\n\t\tCalendar calendar = Calendar.getInstance();\n\t\tcalendar.set(Calendar.HOUR_OF_DAY, 0);\n\t\tcalendar.set(Calendar.MINUTE, 0);\n\t\tcalendar.set(Calendar.SECOND, 0);\n\t\treturn calendar.getTime();\n\t}\n\n}", "output": "/*\n * Copyright 2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alibaba.cloud.ai.studio.core.utils.common;\n\nimport org.apache.commons.lang3.time.DateFormatUtils;\n\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Locale;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Utility class for date and time operations.\n *\n * @since 1.0.0.3\n */\npublic class DateUtils extends org.apache.commons.lang3.time.DateUtils {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(DateUtils.class);\n\n\t// Date format patterns\n\tpublic static final String DATE_JFP_STR = \"yyyyMM\";\n\n\tpublic static final String DATE_YMD_STR = \"yyyyMMdd\";\n\n\tpublic static final String DATE_SMALL_STR = \"yyyy-MM-dd\";\n\n\tpublic static final String DATE_FULL_STR = \"yyyy-MM-dd HH:mm:ss\";\n\n\tpublic static final String DATE_KEY_STR = \"yyyyMMddHHmmss\";\n\n\tpublic static final String END_TIME_STR = \"9999-12-31 23:59:59\";\n\n\tpublic static final String DATE_SMALL_STR_SHOW = \"yyyy年MM月dd号HH点mm分\";\n\n\tpublic static final String DATE_MONTH_DAY_STR_SHOW = \"MM月dd号\";\n\n\t// Supported date parse patterns\n\tprivate static final String[] parsePatterns = { \"yyyy-MM-dd\", \"yyyy-MM-dd HH:mm:ss\", \"yyyy-MM-dd HH:mm\", \"yyyy-MM\",\n\t\t\t\"yyyy/MM/dd\", \"yyyy/MM/dd HH:mm:ss\", \"yyyy/MM/dd HH:mm\", \"yyyy/MM\", \"yyyy.MM.dd\", \"yyyy.MM.dd HH:mm:ss\",\n\t\t\t\"yyyy.MM.dd HH:mm\", \"yyyy.MM\", \"yyyyMMddHHmmss\", \"yyyyMMdd\" };\n\n\t/**\n\t * Format date to yyyyMMdd string\n\t */\n\tpublic static String formatSimple(Date date) {\n\t\tif (date == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn DateFormatUtils.format(date, DATE_YMD_STR);\n\t}\n\n\t/**\n\t * Get current date and time in full format (yyyy-MM-dd HH:mm:ss)\n\t */\n\tpublic static String getFullDate() {\n\t\treturn getDate(DATE_FULL_STR);\n\t}\n\n\t/**\n\t * Get current date in yyyy-MM-dd format\n\t */\n\tpublic static String getDate() {\n\t\treturn getDate(DATE_SMALL_STR);\n\t}\n\n\t/**\n\t * Get current date string in specified pattern\n\t * @param pattern Date format pattern\n\t */\n\tpublic static String getDate(String pattern) {\n\t\treturn DateFormatUtils.format(new Date(), pattern);\n\t}\n\n\t/**\n\t * Format date to string with specified pattern\n\t * @param date Date to format\n\t * @param pattern Format pattern\n\t */\n\tpublic static String formatDate(Date date, Object... pattern) {\n\t\tString formatDate = null;\n\t\tif (pattern != null && pattern.length > 0) {\n\t\t\tformatDate = DateFormatUtils.format(date, pattern[0].toString());\n\t\t}\n\t\telse {\n\t\t\tformatDate = DateFormatUtils.format(date, DATE_SMALL_STR);\n\t\t}\n\t\treturn formatDate;\n\t}\n\n\t/**\n\t * Format date to full datetime string (yyyy-MM-dd HH:mm:ss)\n\t */\n\tpublic static String formatDateTimeFull(Date date) {\n\t\tif (date == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn formatDate(date, DATE_FULL_STR);\n\t}\n\n\t/**\n\t * Format date to specified format\n\t */\n\tpublic static String formatDateTimeSmall(Date date, String format) {\n\t\treturn formatDate(date, format);\n\t}\n\n\t/**\n\t * Get current datetime in yyyyMMddHHmmss format\n\t */\n\tpublic static String getDateTime14() {\n\t\tlong currTime = System.currentTimeMillis();\n\t\tDate date = new Date(currTime);\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_KEY_STR);\n\t\treturn format.format(date);\n\t}\n\n\t/**\n\t * Format timestamp to yyyyMMddHHmmss string\n\t */\n\tpublic static String getDateTime14(long time) {\n\t\tDate date = new Date(time);\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_FULL_STR);\n\t\treturn format.format(date);\n\t}\n\n\t/**\n\t * Get current time in HH:mm:ss format\n\t */\n\tpublic static String getTime() {\n\t\treturn formatDate(new Date(), \"HH:mm:ss\");\n\t}\n\n\t/**\n\t * Get current datetime in yyyy-MM-dd HH:mm:ss format\n\t */\n\tpublic static String getDateTime() {\n\t\treturn formatDate(new Date(), DATE_FULL_STR);\n\t}\n\n\t/**\n\t * Get current year\n\t */\n\tpublic static String getYear() {\n\t\treturn formatDate(new Date(), \"yyyy\");\n\t}\n\n\t/**\n\t * Get current month\n\t */\n\tpublic static String getMonth() {\n\t\treturn formatDate(new Date(), \"MM\");\n\t}\n\n\t/**\n\t * Get current day\n\t */\n\tpublic static String getDay() {\n\t\treturn formatDate(new Date(), \"dd\");\n\t}\n\n\t/**\n\t * Get current weekday\n\t */\n\tpublic static String getWeek() {\n\t\treturn formatDate(new Date(), \"E\");\n\t}\n\n\t/**\n\t * Get current hour\n\t */\n\tpublic static Integer getHour() {\n\t\tCalendar calendar = Calendar.getInstance();\n\t\treturn calendar.get(Calendar.HOUR_OF_DAY);\n\t}\n\n\t/**\n\t * Parse date string to Date object Supports multiple date formats\n\t */\n\tpublic static Date parseDate(Object str) {\n\t\tif (str == null) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\treturn org.apache.commons.lang3.time.DateUtils.parseDate(str.toString(), parsePatterns);\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Parse date string in EEE MMM dd HH:mm:ss zzz yyyy format\n\t */\n\tpublic static Date parseDateString(String time) {\n\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\", Locale.ENGLISH);\n\t\ttry {\n\t\t\treturn sdf.parse(time);\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\tlogger.warn(\"Failed to parse date string: {}\", time, e);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Calculate days between now and given date\n\t */\n\tpublic static long pastDays(Date date) {\n\t\tlong t = System.currentTimeMillis() - date.getTime();\n\t\treturn t / (24 * 60 * 60 * 1000);\n\t}\n\n\t/**\n\t * Calculate hours between now and given date\n\t */\n\tpublic static long pastHour(Date date) {\n\t\tlong t = System.currentTimeMillis() - date.getTime();\n\t\treturn t / (60 * 60 * 1000);\n\t}\n\n\t/**\n\t * Calculate minutes between now and given date\n\t */\n\tpublic static long pastMinutes(Date date) {\n\t\tlong t = System.currentTimeMillis() - date.getTime();\n\t\treturn t / (60 * 1000);\n\t}\n\n\t/**\n\t * Format milliseconds to time string (days,hours:minutes:seconds.milliseconds)\n\t */\n\tpublic static String formatDateTime(long timeMillis) {\n\t\tlong day = timeMillis / (24 * 60 * 60 * 1000);\n\t\tlong hour = (timeMillis / (60 * 60 * 1000) - day * 24);\n\t\tlong min = ((timeMillis / (60 * 1000)) - day * 24 * 60 - hour * 60);\n\t\tlong s = (timeMillis / 1000 - day * 24 * 60 * 60 - hour * 60 * 60 - min * 60);\n\t\tlong sss = (timeMillis - day * 24 * 60 * 60 * 1000 - hour * 60 * 60 * 1000 - min * 60 * 1000 - s * 1000);\n\t\treturn (day > 0 ? day + \",\" : \"\") + hour + \":\" + min + \":\" + s + \".\" + sss;\n\t}\n\n\t/**\n\t * Calculate days between two dates\n\t */\n\tpublic static double getDistanceOfTwoDate(Date before, Date after) {\n\t\tlong beforeTime = before.getTime();\n\t\tlong afterTime = after.getTime();\n\t\treturn (afterTime - beforeTime) / (1000 * 60 * 60 * 24);\n\t}\n\n\t/**\n\t * Add days to given date\n\t */\n\tpublic static Date calculateDate(Date date, int num) {\n\t\tCalendar calendar = Calendar.getInstance();\n\t\tcalendar.setTime(date);\n\t\tcalendar.add(Calendar.DATE, num);\n\t\treturn calendar.getTime();\n\t}\n\n\t/**\n\t * Calculate absolute days difference between two dates\n\t */\n\tpublic static Integer differDate(Date newDate, Date oldDate) {\n\t\tint days = (int) ((newDate.getTime() - oldDate.getTime()) / (1000 * 3600 * 24));\n\t\treturn Math.abs(days);\n\t}\n\n\t/**\n\t * Calculate absolute hours difference between two dates\n\t */\n\tpublic static Integer differDateHours(Date newDate, Date oldDate) {\n\t\tint hours = (int) ((newDate.getTime() - oldDate.getTime()) / (1000 * 60 * 60));\n\t\treturn Math.abs(hours);\n\t}\n\n\t/**\n\t * Calculate absolute minutes difference between two dates\n\t */\n\tpublic static Integer differDateMinutes(Date newDate, Date oldDate) {\n\t\tint minutes = (int) ((newDate.getTime() - oldDate.getTime()) / (1000 * 60));\n\t\treturn Math.abs(minutes);\n\t}\n\n\t/**\n\t * Calculate minutes difference between two dates\n\t */\n\tpublic static Integer differMinutes(Date newDate, Date oldDate) {\n\t\treturn (int) ((newDate.getTime() - oldDate.getTime()) / (1000 * 60));\n\t}\n\n\t/**\n\t * Calculate absolute seconds difference between two dates\n\t */\n\tpublic static Integer differDateSeconds(Date newDate, Date oldDate) {\n\t\tint minutes = (int) ((newDate.getTime() - oldDate.getTime()) / (1000));\n\t\treturn Math.abs(minutes);\n\t}\n\n\t/**\n\t * Calculate seconds difference between two dates\n\t */\n\tpublic static Integer differSeconds(Date newDate, Date oldDate) {\n\t\tint seconds = (int) ((newDate.getTime() - oldDate.getTime()) / (1000));\n\t\treturn Math.max(seconds, 0);\n\t}\n\n\t/**\n\t * Get first day of current month in yyyy-MM-dd format\n\t */\n\tpublic static String getMonthFristDay() {\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_SMALL_STR);\n\t\t// 获取当前月第一天：\n\t\tCalendar c = Calendar.getInstance();\n\t\tc.add(Calendar.MONTH, 0);\n\t\tc.set(Calendar.DAY_OF_MONTH, 1);// 设置为1号,当前日期既为本月第一天\n\t\tString first = format.format(c.getTime());\n\t\treturn first;\n\t}\n\n\t/**\n\t * Get last day of current month in yyyy-MM-dd format\n\t */\n\tpublic static String getMonthLastDay() {\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_SMALL_STR);\n\t\tCalendar ca = Calendar.getInstance();\n\t\tca.set(Calendar.DAY_OF_MONTH, ca.getActualMaximum(Calendar.DAY_OF_MONTH));\n\t\tString last = format.format(ca.getTime());\n\t\tSystem.out.println(\"===============last:\" + last);\n\t\treturn last;\n\t}\n\n\t/**\n\t * Get yesterday's date in yyyyMMdd format\n\t */\n\tpublic static String getYesterday() {\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_YMD_STR);\n\t\tCalendar ca = Calendar.getInstance();\n\t\tca.add(Calendar.DAY_OF_MONTH, -1);\n\t\treturn format.format(ca.getTime());\n\t}\n\n\t/**\n\t * Convert Unix timestamp to Date\n\t */\n\tpublic static Date unixTimeToDate(Long unixTime) {\n\t\tSimpleDateFormat format = new SimpleDateFormat(DATE_FULL_STR);\n\t\tLong time = unixTime * 1000;\n\t\tString d = format.format(time);\n\t\tDate date = null;\n\t\ttry {\n\t\t\treturn format.parse(d);\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\te.getMessage();\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn date;\n\t}\n\n\t/**\n\t * Convert Date to Unix timestamp\n\t */\n\tpublic static Long toUnixTimestamp(Date date) {\n\t\tif (date == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn date.getTime() / 1000;\n\t}\n\n\t/**\n\t * Get current hour's start time\n\t */\n\tpublic static Date getCurrHourTime() {\n\t\tCalendar ca = Calendar.getInstance();\n\t\tca.set(Calendar.MINUTE, 0);\n\t\tca.set(Calendar.SECOND, 0);\n\t\treturn ca.getTime();\n\t}\n\n\t/**\n\t * Get N hours before current hour's start time\n\t */\n\tpublic static Date getNextHourTime(int n) {\n\t\tCalendar ca = Calendar.getInstance();\n\t\tca.set(Calendar.MINUTE, 0);\n\t\tca.set(Calendar.SECOND, 0);\n\t\tca.set(Calendar.HOUR_OF_DAY, ca.get(Calendar.HOUR_OF_DAY) - n);\n\t\treturn ca.getTime();\n\t}\n\n\t/**\n\t * Get date N days after current date\n\t */\n\tpublic static Date getAfterDayTime(int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(new Date());\n\t\tcal.add(Calendar.DATE, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get first second of N days after current date\n\t */\n\tpublic static Date getFirstSecondOfAfterDayTime(int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.add(Calendar.DATE, n);\n\t\tcal.set(Calendar.HOUR_OF_DAY, 0);\n\t\tcal.set(Calendar.MINUTE, 0);\n\t\tcal.set(Calendar.SECOND, 0);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N hours after current date\n\t */\n\tpublic static Date getAfterHourTime(int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(new Date());\n\t\tcal.add(Calendar.HOUR, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N minutes after current date\n\t */\n\tpublic static Date getAfterMinTime(int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(new Date());\n\t\tcal.add(Calendar.MINUTE, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N minutes after given date\n\t */\n\tpublic static Date getAfterMinTime(Date date, int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.add(Calendar.MINUTE, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N hours after given date\n\t */\n\tpublic static Date getAfterHourTimeForDate(Date date, int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.add(Calendar.HOUR, n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get date N hours before given date\n\t */\n\tpublic static Date getBeforeHourTimeForDate(Date date, int n) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.add(Calendar.HOUR, -n);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get end time (9999-12-31 23:59:59)\n\t */\n\tpublic static Date endTime() {\n\t\treturn parseDate(END_TIME_STR);\n\t}\n\n\t/**\n\t * Get last second of given date\n\t */\n\tpublic static Date getLastSecondOfDay(Date date) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.set(Calendar.HOUR_OF_DAY, 23);\n\t\tcal.set(Calendar.MINUTE, 59);\n\t\tcal.set(Calendar.SECOND, 59);\n\t\tcal.set(Calendar.MILLISECOND, 0);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get last second of given hour\n\t */\n\tpublic static Date getLastSecondOfHour(Date date) {\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(date);\n\t\tcal.set(Calendar.MINUTE, 59);\n\t\tcal.set(Calendar.SECOND, 59);\n\t\tcal.set(Calendar.MILLISECOND, 0);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Get datetime for given hour of current day\n\t */\n\tpublic static Date getGivenHourDateTime(String hourTime) {\n\t\t// 得到当天yyyy-mm-dd格式\n\t\tString dayTime = getDate();\n\t\tString fullTimeStr = dayTime + \" \" + hourTime;\n\t\tSimpleDateFormat sdf = new SimpleDateFormat(DATE_FULL_STR);\n\t\ttry {\n\t\t\tDate date = sdf.parse(fullTimeStr);\n\t\t\treturn date;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Calculate MetaQ delay level based on date difference\n\t */\n\tpublic static int getMetaqDelayLevel(Date date) {\n\t\tint diffMinutes = differDateMinutes(new Date(), date);\n\t\tif (diffMinutes >= 0 && diffMinutes <= 10) {\n\t\t\treturn diffMinutes + 4;\n\t\t}\n\t\telse if (diffMinutes > 10 && diffMinutes < 60) {\n\t\t\treturn 14;\n\t\t}\n\t\telse if (diffMinutes >= 60 && diffMinutes < 120) {\n\t\t\treturn 17;\n\t\t}\n\t\treturn 18;\n\n\t}\n\n\t/**\n\t * Validate if date string matches given format\n\t */\n\tpublic static boolean isLegalDate(String sDate, String format) {\n\t\tif ((sDate == null) || (sDate.length() != format.length())) {\n\t\t\treturn false;\n\t\t}\n\t\tDateFormat formatter = new SimpleDateFormat(format);\n\t\ttry {\n\t\t\tDate date = formatter.parse(sDate);\n\t\t\treturn sDate.equals(formatter.format(date));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Convert date string from one format to another\n\t */\n\tpublic static String covertDateFormat(String dateStr, String format) {\n\n\t\ttry {\n\t\t\tDate date = DateUtils.parseDate(dateStr, DateUtils.DATE_YMD_STR);\n\t\t\treturn DateUtils.formatDateTimeSmall(date, format);\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Get start of current day\n\t */\n\tpublic static Date getToday() {\n\t\tCalendar calendar = Calendar.getInstance();\n\t\tcalendar.set(Calendar.HOUR_OF_DAY, 0);\n\t\tcalendar.set(Calendar.MINUTE, 0);\n\t\tcalendar.set(Calendar.SECOND, 0);\n\t\treturn calendar.getTime();\n\t}\n\n}", "metadata": {"commit_sha": "d5539604", "lines_added": 8, "lines_deleted": 5, "total_changes": 13, "chunks": 2}}
{"id": 52, "pattern_type": "refactoring", "file_path": "community/openmanus/src/main/java/com/alibaba/cloud/ai/example/manus/QueryCommandRunner.java", "file_extension": "java", "input": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.example.manus;\n\nimport java.util.Scanner;\n\nimport com.alibaba.cloud.ai.example.manus.flow.PlanningFlow;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class QueryCommandRunner implements CommandLineRunner {\n\n\t@Autowired\n\tprivate PlanningFlow planningFlow;\n\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tString query = scanner.next();\n\n\t\tplanningFlow.setActivePlanId(\"plan_\" + System.currentTimeMillis());\n\t\tplanningFlow.execute(query);\n\t}\n}", "output": "/*\n * Copyright 2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cloud.ai.example.manus;\n\nimport java.util.Scanner;\n\nimport com.alibaba.cloud.ai.example.manus.flow.PlanningFlow;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class QueryCommandRunner implements CommandLineRunner {\n\n\t@Autowired\n\tprivate PlanningFlow planningFlow;\n\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tString query = scanner.next();\n\n\t\tplanningFlow.setActivePlanId(\"plan_\" + System.currentTimeMillis());\n\t\tplanningFlow.execute(query);\n\t}\n\n}", "metadata": {"commit_sha": "66a31ded", "lines_added": 7, "lines_deleted": 7, "total_changes": 14, "chunks": 2}}
{"id": 106, "pattern_type": "other", "file_path": "spring-ai-alibaba-graph/spring-ai-alibaba-graph-example/src/main/java/com/alibaba/cloud/ai/example/graph/stream/HttpStreamController.java", "file_extension": "java", "input": "package com.alibaba.cloud.ai.example.graph.stream;\n\nimport com.alibaba.cloud.ai.graph.*;\nimport com.alibaba.cloud.ai.graph.state.strategy.AppendStrategy;\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport jakarta.annotation.PostConstruct;\nimport jakarta.servlet.http.HttpServletRequest;\nimport org.bsc.async.AsyncGenerator;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.codec.ServerSentEvent;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Sinks;\n\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.CompletionException;\n\nimport static com.alibaba.cloud.ai.graph.StateGraph.END;\nimport static com.alibaba.cloud.ai.graph.StateGraph.START;\nimport static com.alibaba.cloud.ai.graph.action.AsyncNodeAction.node_async;\n\n@RestController\n@RequestMapping(\"/http-stream\")\npublic class HttpStreamController {\n\n\tprivate StateGraph workflow;\n\n\tprivate ObjectMapper objectMapper = new ObjectMapper();\n\n\t@PostConstruct\n\tpublic void init() throws GraphStateException {\n\t\t// 定义工作流\n\t\t// 创建状态和策略\n\t\tworkflow = new StateGraph(() -> new OverAllState().registerKeyAndStrategy(\"messages\", new AppendStrategy())\n\t\t\t.registerKeyAndStrategy(\"count\", (oldValue, newValue) -> oldValue == null ? newValue : 1))\n\t\t\t.addNode(\"collectInput\", node_async(s -> {\n\t\t\t\t// 处理输入\n\t\t\t\tString input = s.value(\"input\", \"\");\n\t\t\t\treturn Map.of(\"messages\", \"Received: \" + input, \"count\", 1);\n\t\t\t}))\n\t\t\t.addNode(\"processData\", node_async(s -> {\n\t\t\t\t// 处理数据 - 这里可以是耗时操作，会以流式方式返回结果\n\t\t\t\treturn Map.of(\"messages\", \"Processing...\", \"count\", 1);\n\t\t\t}))\n\t\t\t.addNode(\"generateResponse\", node_async(s -> {\n\t\t\t\t// 生成最终响应\n\t\t\t\tint count = s.value(\"count\", 0);\n\t\t\t\treturn Map.of(\"messages\", \"Response generated (processed \" + count + \" items)\", \"result\", \"Success\");\n\t\t\t}))\n\t\t\t.addEdge(START, \"collectInput\")\n\t\t\t.addEdge(\"collectInput\", \"processData\")\n\t\t\t.addEdge(\"processData\", \"generateResponse\")\n\t\t\t.addEdge(\"generateResponse\", END);\n\n\t}\n\n\t@PostMapping(value = \"/stream\", produces = MediaType.TEXT_EVENT_STREAM_VALUE)\n\tpublic Flux<ServerSentEvent<String>> stream(HttpServletRequest request, @RequestBody Map<String, Object> inputData)\n\t\t\tthrows Exception {\n\t\t// 编译工作流\n\t\tCompiledGraph compiledGraph = workflow.compile();\n\n\t\t// 初始化输入\n\t\tOverAllState overAllState = compiledGraph.overAllState();\n\t\toverAllState.input(inputData);\n\n\t\t// 从请求中获取输入\n\t\tString threadId = UUID.randomUUID().toString();\n\n\t\t// 创建 Sink 用于发送事件\n\t\tSinks.Many<ServerSentEvent<String>> sink = Sinks.many().unicast().onBackpressureBuffer();\n\t\tFlux<ServerSentEvent<String>> flux = sink.asFlux();\n\n\t\t// 使用 CompiledGraph 的流式功能\n\t\tAsyncGenerator<NodeOutput> generator = compiledGraph.stream(inputData,\n\t\t\t\tRunnableConfig.builder().threadId(threadId).build());\n\n\t\t// 处理流式输出\n\t\tgenerator.forEachAsync(output -> {\n\t\t\ttry {\n\t\t\t\tMap<String, Object> data = output.state().data();\n\t\t\t\tSystem.out.println(\"data = \" + data);\n\t\t\t\tObject messages = data.get(\"messages\");\n\t\t\t\tsink.tryEmitNext(ServerSentEvent.builder(JSON.toJSONString(messages)).build());\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new CompletionException(e);\n\t\t\t}\n\t\t}).thenAccept(v -> sink.tryEmitComplete()).exceptionally(e -> {\n\t\t\tsink.tryEmitError(e);\n\t\t\treturn null;\n\t\t});\n\n\t\treturn flux;\n\t}\n\n}", "output": "package com.alibaba.cloud.ai.example.graph.stream;\n\nimport com.alibaba.cloud.ai.graph.*;\nimport com.alibaba.cloud.ai.graph.state.strategy.AppendStrategy;\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport jakarta.annotation.PostConstruct;\nimport jakarta.servlet.http.HttpServletRequest;\nimport org.bsc.async.AsyncGenerator;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.codec.ServerSentEvent;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Sinks;\n\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.CompletionException;\n\nimport static com.alibaba.cloud.ai.graph.StateGraph.END;\nimport static com.alibaba.cloud.ai.graph.StateGraph.START;\nimport static com.alibaba.cloud.ai.graph.action.AsyncNodeAction.node_async;\n\n@RestController\n@RequestMapping(\"/http-stream\")\npublic class HttpStreamController {\n\n\tprivate StateGraph workflow;\n\n\n\t@PostConstruct\n\tpublic void init() throws GraphStateException {\n\t\t// 定义工作流\n\t\t// 创建状态和策略\n\t\tworkflow = new StateGraph(() -> new OverAllState().registerKeyAndStrategy(\"messages\", new AppendStrategy())\n\t\t\t.registerKeyAndStrategy(\"count\", (oldValue, newValue) -> oldValue == null ? newValue : 1))\n\t\t\t.addNode(\"collectInput\", node_async(s -> {\n\t\t\t\t// 处理输入\n\t\t\t\tString input = s.value(\"input\", \"\");\n\t\t\t\treturn Map.of(\"messages\", \"Received: \" + input, \"count\", 1);\n\t\t\t}))\n\t\t\t.addNode(\"processData\", node_async(s -> {\n\t\t\t\t// 处理数据 - 这里可以是耗时操作，会以流式方式返回结果\n\t\t\t\treturn Map.of(\"messages\", \"Processing...\", \"count\", 1);\n\t\t\t}))\n\t\t\t.addNode(\"generateResponse\", node_async(s -> {\n\t\t\t\t// 生成最终响应\n\t\t\t\tint count = s.value(\"count\", 0);\n\t\t\t\treturn Map.of(\"messages\", \"Response generated (processed \" + count + \" items)\", \"result\", \"Success\");\n\t\t\t}))\n\t\t\t.addEdge(START, \"collectInput\")\n\t\t\t.addEdge(\"collectInput\", \"processData\")\n\t\t\t.addEdge(\"processData\", \"generateResponse\")\n\t\t\t.addEdge(\"generateResponse\", END);\n\n\t}\n\n\t@PostMapping(value = \"/stream\", produces = MediaType.TEXT_EVENT_STREAM_VALUE)\n\tpublic Flux<ServerSentEvent<String>> stream(HttpServletRequest request, @RequestBody Map<String, Object> inputData)\n\t\t\tthrows Exception {\n\t\t// 编译工作流\n\t\tCompiledGraph compiledGraph = workflow.compile();\n\n\t\t// 初始化输入\n\t\tOverAllState overAllState = compiledGraph.overAllState();\n\t\toverAllState.input(inputData);\n\n\t\t// 从请求中获取输入\n\t\tString threadId = UUID.randomUUID().toString();\n\n\t\t// 创建 Sink 用于发送事件\n\t\tSinks.Many<ServerSentEvent<String>> sink = Sinks.many().unicast().onBackpressureBuffer();\n\t\tFlux<ServerSentEvent<String>> flux = sink.asFlux();\n\n\t\t// 使用 CompiledGraph 的流式功能\n\t\tAsyncGenerator<NodeOutput> generator = compiledGraph.stream(inputData,\n\t\t\t\tRunnableConfig.builder().threadId(threadId).build());\n\t\t// 处理流式输出\n\t\tgenerator.forEachAsync(output -> {\n\t\t\ttry {\n\t\t\t\tMap<String, Object> data = output.state().data();\n\t\t\t\tSystem.out.println(\"data = \" + data);\n\t\t\t\tObject messages = data.get(\"messages\");\n\t\t\t\tsink.tryEmitNext(ServerSentEvent.builder(JSON.toJSONString(messages)).build());\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new CompletionException(e);\n\t\t\t}\n\t\t}).thenAccept(v -> sink.tryEmitComplete()).exceptionally(e -> {\n\t\t\tsink.tryEmitError(e);\n\t\t\treturn null;\n\t\t});\n\n\t\treturn flux;\n\t}\n\n}", "metadata": {"commit_sha": "5203ba90", "lines_added": 0, "lines_deleted": 2, "total_changes": 2, "chunks": 2}}
